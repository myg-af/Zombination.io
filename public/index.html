<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Zombination.io</title>
<style>
  /* Styles inchangés sauf joystick repositionné et centré correctement */
  body {
    margin: 0; padding: 0; overflow: hidden;
    background: #111;
    font-family: Arial, sans-serif;
    color: white;
  }
  #gameCanvas {
    display: block;
    background-color: #222;
  }
  .joystickWrapper {
    position: fixed;
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.12);
    touch-action: none;
    user-select: none;
    z-index: 1000;
    /* Centrage */
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .joystickStick {
    width: 60px;
    height: 60px;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    /* Centré par défaut */
    transform: translate(0, 0);
    transition: transform 0.05s;
  }
  #joystickMove {
    bottom: 100px;
    left: 40px;
  }
  #joystickAim {
    bottom: 100px;
    right: 40px;
  }
  #lobbyScreen {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #222;
    padding: 20px;
    border-radius: 15px;
    width: 320px;
    text-align: center;
    box-shadow: 0 0 20px rgba(0,255,0,0.5);
  }
  #lobbyScreen input {
    width: 80%;
    padding: 8px;
    margin: 10px 0;
    font-size: 16px;
  }
  #lobbyJoin {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    background-color: #3b7;
    border: none;
    border-radius: 8px;
    color: white;
  }
  #deathScreen {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #222;
    padding: 25px;
    border-radius: 15px;
    width: 320px;
    text-align: center;
    box-shadow: 0 0 20px rgba(255,0,0,0.7);
    z-index: 2000;
    color: white;
  }
  #btnReplay {
    margin-top: 15px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    background-color: #c33;
    border: none;
    border-radius: 8px;
    color: white;
  }
  #waveMessage {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    color: #ffa;
    text-shadow: 0 0 10px #ffa;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    z-index: 1500;
  }
  #hud {
    position: fixed;
    top: 10px;
    left: 10px;
    color: white;
    font-weight: bold;
    z-index: 1500;
    font-size: 18px;
  }
  #hud > div {
    margin-bottom: 5px;
  }
</style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div id="lobbyScreen">
    <h1 id="lobbyTitle"><b>Zombination.io</b></h1>
    <input id="pseudoInput" type="text" maxlength="15" placeholder="Entrez votre pseudo" autocomplete="off" />
    <button id="lobbyJoin">Rejoindre</button>
    <div id="lobbyPlayers"></div>
    <div id="lobbyTimer"></div>
    <div id="lobbyStatus"></div>
    <div style="font-size:12px; margin-top:10px;">Version 1.0.0 par Myg</div>
  </div>

  <div id="deathScreen">
    <h2 id="deathTitle">Vous êtes mort</h2>
    <div id="deathStats"></div>
    <button id="btnReplay">Rejouer</button>
  </div>

  <div id="hud">
    <div id="hudAlive"></div>
    <div id="hudZombies"></div>
    <div id="hudKills"></div>
    <div id="hudRound"></div>
    <div id="hudHP"></div>
  </div>

  <div id="waveMessage"></div>

  <script src="/translations.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let map = [];
    let MAP_ROWS = 0, MAP_COLS = 0;

    let playersHealth = {};
    let zombies = {};
    let bullets = {};

    let myId = null;
    let playerHealth = 100;
    let currentRound = 1;
    let myKills = 0;
    let isDead = false;

    let lobbyJoined = false;
    let lobbyStarted = false;

    const keys = {};
    let mouseDown = false;
    let mousePos = { x: 0, y: 0 };

    // Joystick elements & states
    const joystickMove = document.createElement('div');
    joystickMove.id = 'joystickMove';
    joystickMove.className = 'joystickWrapper';
    joystickMove.style.display = 'none';

    const joystickMoveStick = document.createElement('div');
    joystickMoveStick.className = 'joystickStick';
    joystickMove.appendChild(joystickMoveStick);
    document.body.appendChild(joystickMove);

    const joystickAim = document.createElement('div');
    joystickAim.id = 'joystickAim';
    joystickAim.className = 'joystickWrapper';
    joystickAim.style.display = 'none';

    const joystickAimStick = document.createElement('div');
    joystickAimStick.className = 'joystickStick';
    joystickAim.appendChild(joystickAimStick);
    document.body.appendChild(joystickAim);

    // Joystick state
    let moveTouchId = null;
    let aimTouchId = null;

    let moveDir = { x: 0, y: 0 };
    let aimDir = { x: 0, y: 0 };

    // Canvas resize
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Joystick utility
    function handleJoystickTouchStart(e, joystick, isMove) {
      for (const touch of e.changedTouches) {
        if (isMove && moveTouchId === null) {
          moveTouchId = touch.identifier;
          updateJoystick(touch, joystick, true);
          break;
        } else if (!isMove && aimTouchId === null) {
          aimTouchId = touch.identifier;
          updateJoystick(touch, joystick, false);
          break;
        }
      }
    }

    function handleJoystickTouchMove(e, joystick, isMove) {
      for (const touch of e.changedTouches) {
        if ((isMove && touch.identifier === moveTouchId) || (!isMove && touch.identifier === aimTouchId)) {
          updateJoystick(touch, joystick, isMove);
          break;
        }
      }
    }

    function handleJoystickTouchEnd(e, joystick, isMove) {
      for (const touch of e.changedTouches) {
        if ((isMove && touch.identifier === moveTouchId) || (!isMove && touch.identifier === aimTouchId)) {
          resetJoystick(joystick, isMove);
          if (isMove) moveTouchId = null;
          else aimTouchId = null;
          break;
        }
      }
    }

    function updateJoystick(touch, joystick, isMove) {
      const rect = joystick.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      let dx = touch.clientX - centerX;
      let dy = touch.clientY - centerY;
      const maxDist = rect.width / 2;

      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
      }

      joystick.firstChild.style.transform = `translate(${dx}px, ${dy}px)`;

      const normX = dx / maxDist;
      const normY = dy / maxDist;

      if (isMove) {
        moveDir = { x: normX, y: normY };
      } else {
        aimDir = { x: normX, y: normY };
      }
    }

    function resetJoystick(joystick, isMove) {
      joystick.firstChild.style.transform = `translate(0px, 0px)`;
      if (isMove) moveDir = { x: 0, y: 0 };
      else aimDir = { x: 0, y: 0 };
    }

    // Attach touch events
    joystickMove.addEventListener('touchstart', e => { e.preventDefault(); handleJoystickTouchStart(e, joystickMove, true); }, { passive: false });
    joystickMove.addEventListener('touchmove', e => { e.preventDefault(); handleJoystickTouchMove(e, joystickMove, true); }, { passive: false });
    joystickMove.addEventListener('touchend', e => { e.preventDefault(); handleJoystickTouchEnd(e, joystickMove, true); }, { passive: false });
    joystickMove.addEventListener('touchcancel', e => { e.preventDefault(); handleJoystickTouchEnd(e, joystickMove, true); }, { passive: false });

    joystickAim.addEventListener('touchstart', e => { e.preventDefault(); handleJoystickTouchStart(e, joystickAim, false); }, { passive: false });
    joystickAim.addEventListener('touchmove', e => { e.preventDefault(); handleJoystickTouchMove(e, joystickAim, false); }, { passive: false });
    joystickAim.addEventListener('touchend', e => { e.preventDefault(); handleJoystickTouchEnd(e, joystickAim, false); }, { passive: false });
    joystickAim.addEventListener('touchcancel', e => { e.preventDefault(); handleJoystickTouchEnd(e, joystickAim, false); }, { passive: false });

    // Main game loop
    let lastTime = 0;
    function gameLoop(timestamp = 0) {
      const deltaTime = (timestamp - lastTime) / 1000 || 0.016;
      lastTime = timestamp;

      // For PC keyboard movement: only move if key is held
      let inputDir = { x: 0, y: 0 };
      if (!isMobile) {
        if (keys['arrowup'] || keys['w']) inputDir.y -= 1;
        if (keys['arrowdown'] || keys['s']) inputDir.y += 1;
        if (keys['arrowleft'] || keys['a']) inputDir.x -= 1;
        if (keys['arrowright'] || keys['d']) inputDir.x += 1;
      } else {
        inputDir = moveDir;
      }
      // Normalize inputDir
      const length = Math.sqrt(inputDir.x * inputDir.x + inputDir.y * inputDir.y);
      if (length > 0) {
        inputDir.x /= length;
        inputDir.y /= length;
      }

      // Send movement input to server if changed
      if (inputDir.x !== lastSentMoveDir.x || inputDir.y !== lastSentMoveDir.y) {
        socket.emit('playerInput', inputDir);
        lastSentMoveDir = { ...inputDir };
      }

      // For aiming
      if (isMobile) {
        // On mobile, emit shoot continuously if aim joystick is moved significantly
        const aimLength = Math.sqrt(aimDir.x * aimDir.x + aimDir.y * aimDir.y);
        if (aimLength > 0.3) {
          socket.emit('playerShoot', aimDir);
        }
      } else {
        // On PC, mouse click shooting (already handled by mousedown, see below)
      }

      update(deltaTime);
      updateCamera();

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      drawPlayers();
      drawZombies();
      drawBullets();
      drawHUD();

      requestAnimationFrame(gameLoop);
    }

    let lastSentMoveDir = { x: 0, y: 0 };

    // PC mouse shooting
    canvas.addEventListener('mousedown', e => {
      if (!isMobile) {
        mouseDown = true;
        mousePos.x = e.clientX;
        mousePos.y = e.clientY;
      }
    });
    canvas.addEventListener('mouseup', e => {
      if (!isMobile) {
        mouseDown = false;
      }
    });
    canvas.addEventListener('mousemove', e => {
      if (!isMobile) {
        mousePos.x = e.clientX;
        mousePos.y = e.clientY;
      }
    });

    // PC shooting loop
    function pcShootingLoop() {
      if (mouseDown) {
        const player = playersHealth[myId];
        if (player && player.alive) {
          const mouseWorldX = cameraX + mousePos.x;
          const mouseWorldY = cameraY + mousePos.y;
          const dx = mouseWorldX - player.x;
          const dy = mouseWorldY - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 1) {
            socket.emit('playerShoot', { x: dx / dist, y: dy / dist });
          }
        }
      }
      setTimeout(pcShootingLoop, 50);
    }
    pcShootingLoop();

    // Rest of the game code and event handlers here (unchanged)...

    // Detect mobile device
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);

    // Camera and HUD update functions (unchanged)...

    // Socket event handlers to update game state (unchanged)...

    // Start the loop
    gameLoop();

  </script>
</body>
</html>
