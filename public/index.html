<!DOCTYPE html>

<html lang="fr">
<head>

<script>
// Set a stable client id (zid) for sticky balancing per-player even on same IP
(function(){
  try {
    function getCookie(name){
      var m = document.cookie.match(new RegExp('(?:^|; )'+name+'=([^;]*)'));
      return m ? decodeURIComponent(m[1]) : '';
    }
    if (!getCookie('zid')) {
      var rnd = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Math.random().toString(16).slice(2)+Date.now().toString(16));
      var exp = new Date(Date.now() + 365*24*3600*1000).toUTCString();
      document.cookie = 'zid='+encodeURIComponent(rnd)+'; path=/; SameSite=Lax; expires='+exp;
    }
  } catch(_){}
})();
</script>

<script>
// Safe null-object for removed #lobbyJoin (Solo) button
(function(){
  if (!('lobbyJoin' in window)) {
    var noop = function(){};
    window.lobbyJoin = {
      disabled: false,
      style: {},
      dataset: {},
      addEventListener: noop,
      removeEventListener: noop,
      click: noop,
      set textContent(v){},
      get textContent(){ return ''; },
      set onclick(v){},
      get onclick(){ return null; }
    };
  }

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        try{ ev.stopPropagation(); if (ev.stopImmediatePropagation) ev.stopImmediatePropagation(); }catch(_){}
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport"/>
<title>Zombination.io</title>
<style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #222; color: white; font-family: Arial, sans-serif; }
    #gameCanvas { display: block; background: #222; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
	#gameCanvas { touch-action: none; }
	.joystick-base, .joystick-stick { touch-action: none; }
	html, body { overscroll-behavior: none; }
    #hudStats { position: fixed; left: 8px; left: calc(env(safe-area-inset-left, 0px) + 8px); bottom: 8px; bottom: calc(env(safe-area-inset-bottom, 0px) + 8px); background: rgba(0,0,0,0.7); border-radius: 7px; padding: 10px 20px 10px 15px; font-size: 18px; user-select: none; display: inline-block; width: -moz-fit-content; width: fit-content; max-width: min(96vw, 520px); white-space: nowrap; }
    #hudAlive { font-weight: bold; color: #fd7; }
    #deathScreen { display: none; position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; background: rgba(30,0,0,0.8); z-index: 3; justify-content: center; align-items: center; flex-direction: column; }
    #deathScreenInner { background: #181818; border-radius: 20px; padding: 35px 45px; color: #fff; box-shadow: 0 6px 30px #000c; text-align: center; min-width: 320px; }
    #deathScreen h2 { margin: 0 0 15px 0; color: #fc2c3c; }
    #deathStats { margin-bottom: 15px; font-size: 20px; }
    #btnReplay { background: #222; color: #fff; padding: 10px 32px; border: none; border-radius: 10px; font-size: 20px; cursor: pointer; transition: background 0.16s; }
    #btnSpectate { background: #222; color: #fff; padding: 10px 18px; border: 0; border-radius: 10px; font-size: 20px; cursor: pointer; transition: background 0.16s; margin-left: 10px; }
    #btnSpectate:hover { background: #339; color: #fff; }
    #spectateReplayBtn { display:none; position: fixed; left: 50%; transform: translateX(-50%); bottom: 20px; background: #222; color:#fff; border:0; border-radius: 10px; padding:10px 18px; font-size:18px; cursor:pointer; box-shadow:0 4px 16px #0008; }
    #btnReplay:hover { background: #393; color: #fff; }
    /* --- LOBBY --- */
    #lobbyScreen { display: flex; flex-direction: column; align-items: center; justify-content: center; position: fixed; left:0;top:0;width:100vw;height:100vh;z-index:10; background: #181c; }
    #lobbyBox { background: #19191e; border-radius: 20px; padding: 36px 42px; box-shadow: 0 6px 30px #000c; min-width: 350px; min-height: 190px; text-align: center; }
    #lobbyBox input[type=text] { font-size: 20px; padding: 7px 12px; border-radius: 7px; border: 1px solid #444; outline: none; margin-bottom: 10px; width: 175px; background:#fff; color:#000; text-align:center; }
    #pseudoInput::placeholder { text-align: center; }

    #lobbyJoin { padding: 7px 32px; border-radius: 8px; border:none; font-size: 20px; background:#49c749; color: #fff; cursor: pointer; margin-top: 7px; }
    #lobbyJoin[disabled] { opacity: 0.6; cursor: not-allowed; }
    #btnJoinLobbyList[disabled], #btnCreateLobby[disabled] { opacity: 0.6; cursor: not-allowed; }
    
    #btnLadder[disabled], #btnLogin[disabled], #btnSignup[disabled], #btnLogout[disabled], #btnSettings[disabled], #btnAccountShop[disabled] { opacity: 0.6; cursor: not-allowed; }
#lobbyPlayers { margin: 18px 0 12px 0; color: #9fd; }
    #lobbyTimer { font-size: 17px; margin-bottom: 9px; }
    #lobbyStatus { margin: 4px 0 0 0; color: #ccc; font-size: 14px; }

    /* --- LANG SELECT --- */
    #langSelectRow {
      margin-top: 18px;
      display: flex;
      justify-content: center;
      gap: 13px;
      user-select: none;
    }
    .langFlag {
      width: 38px;
      height: 26px;
      border-radius: 6px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: border 0.14s, transform 0.12s;
      background: #fff2;
      object-fit: cover;
      box-shadow: 0 2px 10px #0003;
    }
    .langFlag.selected {
      border: 2.5px solid #33fc69;
      transform: scale(1.07);
      box-shadow: 0 2px 16px #33fc6930;
    }

    
    /* --- MOBILE: LANG FLAGS on 2 rows (5 + 5) --- */
    @media (max-width: 768px) {
      #langSelectRow {
        display: grid;
        grid-template-columns: repeat(5, 38px);
        justify-content: center;
        gap: 12px;
      }
    }
/* --- WAVE MESSAGE --- */
    #waveMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #f2f263;
      font-size: 48px;
      font-weight: bold;
      text-shadow: 2px 2px 6px #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease-in-out;
      z-index: 20;
      user-select: none;
    }
    /* Version */
    #versionBox { position: fixed; right: 20px; bottom: 14px; color: #ccc; font-size: 14px; opacity: 0.8; z-index: 20; user-select: none; }
    /* Worker badge (top-right) */
    #workerBox { position: fixed; right: 20px; top: 14px; color: #ccc; font-size: 14px; opacity: 0.9; z-index: 20; user-select: none; }
    /* Ajout des joysticks mobile */
	.joystick-container {
	  position: fixed;
	  z-index: 10000;
	  touch-action: none;
	  pointer-events: auto; /* <-- IMPORTANT : le conteneur doit capter les events */
	}
    .joystick-base, .joystick-stick {
      pointer-events: auto;
      user-select: none;
    }
	#shopModal {
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  max-height: min(78vh, 640px);
  overflow: hidden;
}

	#shopModal { z-index: 10010 !important; }
	#shopModal:focus-within { outline: 2px solid #4dfc82; }
	#shopModal::-webkit-scrollbar { width: 6px; }
	#shopModal::-webkit-scrollbar-thumb { background: #2a5; border-radius: 4px; }

	/* Étape 1 — structure interne du panneau (scroll propre) */
	#shopModal {
	  display: flex;
	  flex-direction: column;
	}

	#shopUpgrades {
  overflow-y: auto;
  flex: 1 1 auto;
  min-height: 0;
  max-height: 100%;
  -webkit-overflow-scrolling: touch;
  height:auto;
  max-height: calc(100dvh - 180px);
  padding-right:6px;
}

		
@media (hover: none) and (pointer: coarse) {
  /* Contraintes + anim spécifiques mobile */
  #shopModal {
    box-sizing: border-box;

    /* dimensions qui tiennent toujours dans l'écran */
    width: auto;
    max-width: min(92vw, 420px) !important;
    max-height: calc(100dvh - 24px) !important;

    overflow-y: auto;
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;

    /* apparition mobile + easing voulu */
    transform: scale(0.5);
    transform-origin: bottom right;
    animation: shopPopInMobile 0.22s ease-out;
  }

  /* Le bouton doit passer sous le panneau */
  #shopBtn { z-index: 10005 !important; }
}

@keyframes shopPopInMobile {
  0%   { opacity: 0; transform: translateY(80px) scale(0.5); }
  100% { opacity: 1; transform: scale(0.5); }
}

	@keyframes shopPopIn {
	  0% { opacity: 0; transform: translateY(80px) scale(0.97);}
	  100% { opacity: 1; transform: none; }
	}
	#shopClose:hover { color: #ff6464; transform: scale(1.13); }
	.bought-flash {
	  animation: flashBtn 0.22s;
	}
	@keyframes flashBtn {
	  0% { box-shadow: 0 0 0px #67fa62, 0 0 0px #fff; background: #34c24c;}
	  55% { box-shadow: 0 0 11px #67fa62, 0 0 22px #fff9;}
	  100% { box-shadow: 0 0 0px #67fa62, 0 0 0px #fff; }
	}
  
/* Hide clutter while in main menu */
body.menu-hide-ui #fpsCounter,
  body.menu-hide-ui #shopBtn,
  body.menu-hide-ui #buildBar,
  body.menu-hide-ui #hudStats,
  body.menu-hide-ui .mobile-build { display: none !important; }

  /* Patch: Keep only the "Zombination.io" panel visible in the main menu
     and place the lobby background above all other UI elements without deleting them. */
  #lobbyScreen {
    z-index: 20050 !important; /* above shop, build bar, mobile UI, joysticks */
    pointer-events: auto !important; /* block clicks to underlying UI */
    background: #181c; /* keep existing lobby feel while covering elements beneath */
  }

/* === Ensure build buttons always receive input on mobile === */
#buildBar, #buildTiles, #buildBar *, #mobile-build, #mobile-build * {
  pointer-events: auto !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  touch-action: manipulation;
}

</style>
<style id="form-focus-typing-fix">
/* Ensure text inputs can be focused/edited/selected everywhere (auth modal, lobby, chat) */
input, textarea, select, button, label, [contenteditable]{
  -webkit-user-select: text !important;
  user-select: text !important;
}
</style>


<style>
/* === CHAT WIDGET (World + Lobby) === */
#chatPanel {
  position: fixed;
  left: 12px;
  bottom: 12px;
  width: min(420px, 94vw);
  max-height: 46vh;
  display: flex;
  flex-direction: column;
  background: rgba(18,18,18,0.86);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  box-shadow: 0 6px 26px #000c;
  z-index: 2147483647 !important;
  overflow: hidden;
  backdrop-filter: blur(6px);
  color: #fff;

  pointer-events: auto !important;
}
#chatHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 8px 10px;
  background: rgba(255,255,255,0.06);
  user-select: none;
}
#chatTitle { font-weight: 700; letter-spacing: .3px; }
#chatToggle {
  border: none;
  background: transparent;
  color: #fff;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  padding: 4px 8px;
  border-radius: 8px;
}
#chatToggle:hover { background: rgba(255,255,255,0.08); }
#chatTabs { display: flex; gap: 6px; padding: 6px 10px 0 10px; }
.chatTab { position: relative; font-size: 12px; padding: 4px 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.06); cursor: pointer; }
.chatTab.active { background: rgba(46,160,67,0.35); }
.chatTab.notify::after {
  content: '';
  position: absolute;
  right: -4px;
  top: -4px;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #e33;
  border: 2px solid rgba(18,18,18,0.86);
  box-shadow: 0 0 8px rgba(227,51,51,.8);
}
#chatMessages {
  flex: 1 1 auto;
  overflow-y: auto;
  padding: 8px 10px;
  font-size: 14px;
  color: #fff;
}
.chatLine { margin: 3px 0; word-break: break-word; color:#fff; }
.chatName { color: #9fd; font-weight: 600; margin-right: 6px; }
  .chatTime{font-size:12px;color:#9ab;opacity:.9;margin-right:6px;}
#chatInputRow {
  display: flex;
  gap: 6px;
  padding: 8px 10px 10px 10px;
  border-top: 1px solid rgba(255,255,255,0.08);
}
#chatInput {
  flex: 1 1 auto;
  min-width: 0;
  border: 1px solid #444;
  background: #111;
  color: #fff;
  border-radius: 8px;
  padding: 8px 10px;
  outline: none;
  font-size: 14px;
}
#chatSend {
  border: none;
  background: #2a5;
  color: #fff;
  border-radius: 8px;
  padding: 8px 12px;
  font-weight: 700;
  cursor: pointer;
}
#chatSend:disabled { opacity: .6; cursor: not-allowed; }
#chatCollapsedBtn {
  position: fixed;
  left: 12px;
  bottom: 12px;
  width: 42px;
  height: 42px;
  border-radius: 12px;
  background: rgba(18,18,18,0.86);
  border: 1px solid rgba(255,255,255,0.1);
  color: #fff;
  display: none;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 2147483647 !important;
  box-shadow: 0 6px 26px #000c;

  pointer-events: auto !important;
}
#chatCollapsedBtn.notify::after {
  content: '';
  position: absolute;
  right: -2px;
  top: -2px;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #e33;
  border: 2px solid rgba(18,18,18,0.86);
  box-shadow: 0 0 8px rgba(227,51,51,.8);
}
@media (max-width: 768px) {
  #chatPanel { max-height: 38vh; width: min(92vw, 420px); }
}
</style>
<style>
/* ensure chat is always clickable above any overlays */
#chatPanel, #chatPanel * { pointer-events: auto !important; }
#chatCollapsedBtn { pointer-events: auto !important; }
  .chatTime{font-size:12px;color:#9ab;opacity:.9;margin-right:6px;}
</style>

<!-- MOBILE LOBBY RESIZE PATCH (ULTRA ROBUST) -->
<style id="mobile-lobby-resize-patch">
/* Use dynamic viewport units and safe scrolling for the lobby on mobile only */
@media (max-width: 768px) {
  /* Full-screen overlay must match dynamic viewport height even with browser UI/keyboard */
  #lobbyScreen {
    height: calc(var(--vh, 1vh) * 100) !important;
    width: 100vw;
    padding: clamp(6px, 2dvh, 16px) 12px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    overflow: hidden !important; /* internal scroll lives on the box */
  }
  /* Main panel: clamp width, allow internal scroll, respect safe area */
  #lobbyBox {
    width: min(96vw, 520px) !important;
    max-width: 96vw !important;
    max-height: calc(var(--vh, 1vh) * 100 - 24px) !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;
    padding: clamp(16px, 3.6vw, 28px) clamp(14px, 3.2vw, 24px) !important;
    border-radius: 16px !important;
    box-sizing: border-box;
    overscroll-behavior: contain;
  }
  /* Input & buttons sizing tweaks for small screens */
  #pseudoInput { width: 100% !important; max-width: 100% !important; box-sizing: border-box !important; display: block; }
  #lobbyBtnRow button { font-size: 16px !important; padding: 8px 18px !important; }
  #lobbyTitle { font-size: clamp(20px, 5.8vw, 26px) !important; }
  /* Nested lists should also size to remaining space to avoid being cut */
  #lobbiesList {
    max-height: calc(var(--vh, 1vh) * 100 - 260px) !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;
  }
  #manualLobbyPanel { max-height: calc(var(--vh, 1vh) * 100 - 220px); overflow: auto; }
}

/* Tiny phones portrait */
@media (max-width: 380px) and (orientation: portrait) {
  #lobbyBox { border-radius: 14px !important; }
  #lobbyBtnRow { gap: 6px !important; }
}
  .chatTime{font-size:12px;color:#9ab;opacity:.9;margin-right:6px;}
</style>

<!-- MOBILE CENTERING PATCH: lobbyBox width & centering -->
<style>
@media (max-width: 768px) {
  /* Ensure the main lobby window fits and centers on small screens */
  html, body { overflow-x: hidden; }
  #lobbyBox {
    min-width: 0 !important;
    /* Fallback: keep 12px gutters on each side even on browsers without env() */
    width: calc(100vw - 24px) !important;
    /* Preferred: also cap to 520px and account for safe areas when supported */
    width: min(520px, calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right) - 24px)) !important;
    margin-left: auto !important;
    margin-right: auto !important;
    box-sizing: border-box !important;
    max-width: min(520px, calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right) - 24px)) !important;
  }
  /* Add small horizontal padding on the overlay to avoid touching edges */
  #lobbyScreen {
    box-sizing: border-box;
    padding-left: max(12px, env(safe-area-inset-left));
    padding-right: max(12px, env(safe-area-inset-right));
  }
}  .chatTime{font-size:12px;color:#9ab;opacity:.9;margin-right:6px;}
</style>

<style id="build-tile-selected-style">
/* Selected build tile (PC & Mobile) */
#buildTiles .build-tile.mb-selected{
  /* Contour fin et visible, sans double carré */
  outline: 2px solid #34e05a !important;
  outline-offset: 2px;
  box-shadow: 0 0 8px rgba(52,224,90,0.55);
  border-radius: 10px !important;
  transition: box-shadow .12s ease-out;
}


  .chatTime{font-size:12px;color:#9ab;opacity:.9;margin-right:6px;}
</style>


<style>
/* Customize button: same structure as Buy but blue */
#btnOpenSkin, .skinOpenBtn {
  background: #4aa3ff;
  color: #fff;
  border: none;
  border-radius: 8px;
  padding: 10px 14px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 16px rgba(0,0,0,0.35);
  transition: transform .08s ease, filter .16s ease, box-shadow .16s ease;
}
#btnOpenSkin:hover, .skinOpenBtn:hover {
  filter: brightness(1.08);
  transform: translateY(-1px);
  box-shadow: 0 6px 22px rgba(0,0,0,0.4);
}
#btnOpenSkin:active, .skinOpenBtn:active {
  filter: brightness(.98);
  transform: translateY(0);
}
/* Small apply buttons beside color inputs */
.skin-apply {
  margin-left: 8px;
  background: #2a5;
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 6px 10px;
  font-weight: 700;
  cursor: pointer;
}
.skin-apply:hover { filter: brightness(1.08); }
  .chatTime{font-size:12px;color:#9ab;opacity:.9;margin-right:6px;}
</style>

<script>
// Early global stub to avoid ReferenceError if called before the late skin patch loads
if (!window.ensureMySkinLoaded) {
  window.ensureMySkinLoaded = async function(timeoutMs){
    try {
      // Already loaded?
      if (window.__mySkin && __mySkin.hair && __mySkin.skin && __mySkin.clothes) return true;
      // Try to fetch profile if available
      try { if (typeof window.fetchMe==='function') await fetchMe(); } catch(_){}
      if (window.__mySkin && __mySkin.hair && __mySkin.skin && __mySkin.clothes) return true;
      // Small grace delay
      await new Promise(function(r){ setTimeout(r, 200); });
      return !!(window.__mySkin && __mySkin.hair && __mySkin.skin && __mySkin.clothes);
    } catch(_){ return false; }
  };
}
</script>
<style id="igLegacyHide">
/* Hide legacy in-game UI, keep #hudStats for Stats bubble */
#shopBtn, #buildBar, #autoFireBtn { display: none !important; }
/* Hide chat collapsed bubble ONLY in-game (i.e., when main menu UI is not shown) */
body:not(.menu-hide-ui) #chatCollapsedBtn { display: none !important; }
</style>
</head>
<body>
<!-- top-message helper -->
<script>
(function(){
  try {
    if (window.showTopMessage) return;
    window.showTopMessage = function(msg, duration){
      try {
        var DUR = (typeof duration === 'number' && duration >= 0) ? duration : 2000;
        var id = 'topMsgBanner';
        var el = document.getElementById(id);
        if (!el) {
          el = document.createElement('div');
          el.id = id;
          el.setAttribute('role', 'alert');
          el.setAttribute('aria-live', 'assertive');
          el.style.position = 'fixed';
          el.style.top = '10px';
          el.style.left = '50%';
          el.style.transform = 'translateX(-50%)';
          el.style.zIndex = '99999';
          el.style.background = 'rgba(20,20,20,0.92)';
          el.style.color = '#fff';
          el.style.padding = '10px 14px';
          el.style.borderRadius = '10px';
          el.style.boxShadow = '0 8px 22px rgba(0,0,0,0.35)';
          el.style.fontFamily = 'inherit';
          el.style.fontSize = '14px';
          el.style.pointerEvents = 'none';
          el.style.display = 'none';
          document.body.appendChild(el);
        }
        el.textContent = (msg == null ? '' : String(msg));
        el.style.display = 'block';
        clearTimeout(el.__hideTimer);
        el.__hideTimer = setTimeout(function(){
          try { el.style.display = 'none'; } catch(_){}
        }, DUR);
      } catch(_){}
    };
  } catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
  // Default UI scale: mobile x4, desktop x1 (can be overridden by setting window.__uiScale before)
  (function(){
    try {
      if (typeof window.__uiScale === 'undefined' || window.__uiScale == null) {
        var isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent || '');
        window.__uiScale = isMobile ? 4 : 1;
      }
      try { if (window.debugLog) debugLog('🔭 uiScale default =', window.__uiScale); } catch(_){}
    } catch(e){}
  
  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<div id="fpsCounter" style="position:fixed;left:8px;top:8px;background:#0008;color:#0f0;padding:4px 8px;border-radius:6px;font:12px monospace;z-index:9999">FPS: --</div>
<div id="devPerfPanel" style="position:fixed;left:8px;top:30px;background:#000c;color:#fff;padding:6px 10px;border-radius:6px;font:12px monospace;z-index:10000;display:none;max-width:44vw;pointer-events:none;white-space:pre;line-height:1.2"></div>
<canvas id="gameCanvas"></canvas>
<div id="hudStats">
<div id="hudAlive"></div>
<div id="hudGold"></div>
<div id="hudMoney"></div>
<div id="hudZombies"></div>
<div id="hudKills"></div>
<div id="hudRound"></div>
<div id="hudHP"></div>
</div>
<div id="deathScreen">
<div id="deathScreenInner">
<h2 id="deathTitle"></h2>
<p id="deathStats"></p><div style="display: flex; justify-content: center; gap: 10px; margin-top: 16px;"><button id="btnReplay">Replay</button><button id="btnSpectate">Spectate</button></div></div>
</div>
<div id="lobbyScreen">
<div id="lobbyBox">
<div id="lobbyTitle" style="font-size: 28px; margin-bottom: 18px;"><b>Zombination.io</b></div>
<div id="lobbyPlayers"></div>
        <!-- Manual lobby panel (hidden by default) -->
        <div id="manualLobbyPanel" style="display:none; margin-top:12px; text-align:center;">
          <div id="manualLobbyTitle" style="font-weight:600; margin-bottom:6px;">Lobby</div>
          <div id="manualLobbyPlayers" style="font-size:14px; margin-bottom:8px;"></div>
          <div style="display:flex; gap:8px; justify-content:center;">
            <button id="btnStartManual" style="padding: 10px 20px; background: #3fa33f; color: white; border: none; border-radius: 6px; cursor: pointer;">Start</button>
            <button id="btnBackFromManual" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 6px; cursor: pointer;">Back</button>
          </div>
          <div id="manualLobbyNote" style="margin-top:6px; color:#ccc; font-size:12px;">Only the creator can start.</div>
        </div>

        <!-- Join lobby list panel (hidden by default) -->
        <div id="joinLobbyPanel" style="display:none; margin-top:12px;">
          <div style="text-align:center; font-weight:600; margin-bottom:6px;"><span id="joinLobbyTitle">Available lobbies</span></div>
          <div id="lobbiesList" style="display:flex; flex-direction:column; gap:6px;overflow-y: auto;-webkit-overflow-scrolling: touch;max-height: calc(60vh - 120px);padding-right: 6px;"></div>
          <div style="display:flex; gap:8px; justify-content:center; margin-top:8px;">
            
            <button id="btnBackFromList" style="padding: 8px 14px; background: #666; color: white; border:none; border-radius:6px; cursor:pointer;">Back</button>
          </div>
        </div>

        <!-- Ladder panel (hidden by default) -->
        <div id="ladderPanel" style="display:none; margin-top:12px;">
          <div style="text-align:center; font-weight:600; margin-bottom:6px;">
            <span id="ladderTitle">Ladder</span>
          </div>
          <div id="ladderList" style="display:block; overflow-y:auto; -webkit-overflow-scrolling:touch; max-height: calc(60vh - 120px); padding-right:6px; border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
            <!-- Table injected by JS -->
          </div>
          <div style="display:flex; gap:8px; justify-content:center; margin-top:8px;">
            <button id="btnBackFromLadder" style="padding: 8px 14px; background: #666; color: white; border:none; border-radius:6px; cursor:pointer;">Back</button>
          </div>
        </div>

        
<div id="lobbyTimer"></div>
<div id="lobbyStatus"></div>
<input id="pseudoInput" maxlength="10" placeholder="" type="text"/>
<br/>
<div id="lobbyBtnRow" style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:10px;">
<button id="btnJoinLobbyList" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#49c749; color:#fff; cursor:pointer; margin-top:7px;">Join lobby</button>
<button id="btnCreateLobby" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#49c749; color:#fff; cursor:pointer; margin-top:7px;">Create lobby</button>
</div>

        <!-- Shop panel (hidden by default) -->
        <div id="shopPanel" style="display:none; margin-top:12px;">
          <div style="text-align:center; font-weight:600; margin-bottom:6px;">
            <span id="shopPanelTitle">Shop</span>
          </div>
          <div id="shopPanelContent" style="display:block; overflow-y:auto; max-height: calc(60vh - 120px); padding-right: 6px;"></div>
          <div style="display:flex; gap:8px; justify-content:center; margin-top:8px;">
            <button id="btnBackFromShop" style="padding: 8px 14px; border:none; border-radius:6px; cursor:pointer; background: #666; color: white;">Back</button>
          </div>
          <div id="shopLobbyBtnRow" style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
            <button id="shopJoinLobbyListBtn" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#49c749; color:#fff; cursor:pointer; margin-top:7px;"></button>
            <button id="shopCreateLobbyBtn" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#49c749; color:#fff; cursor:pointer; margin-top:7px;"></button>
</div>

        </div>

        <!--
        <!-- Ladder button (same size as main buttons, violet) -->
<div id="ladderBtnRow" style="display:flex; justify-content:center; gap:10px; margin-top:8px;">
  <button id="btnLadder" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#8a70f0; color:#fff; cursor:pointer; margin-top:7px; pointer-events:auto; position:relative; z-index:10">Ladder</button>
  <button id="btnAccountShop" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#ff8800; color:#fff; cursor:pointer; margin-top:7px; pointer-events:auto; position:relative; z-index:10">Shop</button>
</div>
<!-- [PATCH] choose server button -->
<div id="chooseServerRow" style="display:flex; justify-content:center; margin-top:6px;">
  <button id="btnChooseServer" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#6e6e6e; color:#fff; cursor:pointer; margin-top:7px; pointer-events:auto; position:relative; z-index:10;">Choose a server</button>
</div>
<script>
(function(){
  function goToOrigin(){
    try {
      var base = location.origin + location.pathname;
      // strip trailing '?' or '#' if any
      if (base.endsWith('?') || base.endsWith('#')) base = base.slice(0, -1);
      location.assign(base);
    } catch(e){
      try { location.href = location.origin || '/'; } catch(_) { location.reload(); }
    }
  }
  var btn = document.getElementById('btnChooseServer');
  if (btn && !btn.__boundChooseServer) {
    btn.__boundChooseServer = true;
    btn.addEventListener('click', goToOrigin, { passive: true });
  }
})();
</script>
<br/>
<div id="authBtnRow" style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
  <button id="btnLogin" style="padding:8px 16px; border:none; border-radius:8px; background:#2a6aff; color:#fff; cursor:pointer;">Log in</button>
  <button id="btnSignup" style="padding:8px 16px; border:none; border-radius:8px; background:#4f4; color:#000; cursor:pointer;">Sign up</button>
  <button id="btnLogout" style="display:none; padding:8px 16px; border:none; border-radius:8px; background:#b00020; color:#fff; cursor:pointer;">Sign out</button>
  <button id="btnSettings" style="display:none; padding:8px 16px; border:none; border-radius:8px; background:#666; color:#fff; cursor:pointer;">Settings</button>
</div>

<!-- Auth Modals -->
<div id="authModalOverlay" style="display:none; position:fixed; inset:0; background:#000a; z-index:9998; align-items:center; justify-content:center;"></div>
<div id="authModal" style="display:none; position:fixed; inset:0; z-index:9999; align-items:center; justify-content:center;">
  <div id="authModalBox" style="background:#1b1b20; border-radius:14px; padding:18px 20px; width:min(92vw, 420px); margin:auto; box-shadow:0 10px 40px #000a;">
    <div id="authModalTitle" style="font-weight:700; font-size:20px; margin-bottom:10px;">Auth</div>
    <div id="authModalBody"></div>
    <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:14px;">
      <button id="authCancel" style="padding:8px 14px; border:0; border-radius:8px; background:#555; color:#fff; cursor:pointer;">Cancel</button>
      <button id="authSubmit" style="padding:8px 14px; border:0; border-radius:8px; background:#2a6aff; color:#fff; cursor:pointer;">Submit</button>
    </div>
  </div>
</div>

<div id="langSelectRow"></div>
</div>
</div>
<button id="shopBtn" style="display: flex; align-items: center; position: fixed; right: 20px; bottom: 52px; z-index: 21; background: #232; color: #fff; border-radius: 13px; border: none; font-size: 22px; padding: 10px 26px 10px 19px; box-shadow: 0 2px 14px #0006; cursor: pointer; gap: 13px; transition: background 0.17s;" title="Upgrades">
<img alt="Upgrades" src="/icons/cart.svg" style="width: 27px; height: 27px; margin-right: 8px; filter: brightness(1.25) drop-shadow(0 2px 5px #0006);"/>
	  SHOP
	</button>
<!-- ==== BARRE D'ACHATS STRUCTURES (au-dessus du SHOP) ==== -->
<div id="buildBar" style="position:fixed; right:20px; bottom:122px; z-index:10006; display:flex; gap:10px; flex-direction:column; align-items:flex-end;">
<!-- Réduction/affichage de la barre de construction + Auto-fire -->
<button id="toggleBuildUI" style="align-self:flex-end; margin-bottom:8px; padding:6px 10px;
           border-radius:10px; border:1px solid #444; background:#1c1c1f;
           color:#ddd; font-weight:700; cursor:pointer; box-shadow:0 2px 8px #0007;" title="Réduire/Afficher les boutons">
    –
  </button>
<!-- === AUTO-FIRE TOGGLE BUTTON (au-dessus des 4 blocs) === -->
<button id="autoFireBtn" style="display:flex; align-items:center; gap:10px;
           padding:8px 14px; border-radius:12px; border:2px solid #4a1111;
           background:#5a2226; color:#f1d6d6; font-weight:700; letter-spacing:0.3px;
           box-shadow:0 2px 10px #0007; cursor:pointer; user-select:none;">
<span style="width:10px;height:10px;border-radius:50%;background:#742f36;box-shadow:0 0 8px #000 inset;"></span>
<span id="autoFireLabel">Auto fire OFF</span>
</button>
<!-- /AUTO-FIRE TOGGLE -->
<!-- Conteneur horizontal des 4 tuiles -->
<div id="buildTiles" style="display:flex; gap:10px; flex-wrap:wrap;">
<!-- Grande tourelle -->
<button class="build-tile" data-tip="Tourelle (HP: 500, Dégâts: 10, Cadence: 1/s)" data-type="T" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#d33;border:2px solid #3a0b0b;box-shadow:0 2px 8px #0007; position:relative;">
<div style="position:absolute; left:50%; top:50%; width:16px; height:16px; background:#000; transform:translate(-50%,-50%); border-radius:2px;"></div>
</div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$1000 • 1/s • 10 dmg</div>
</button>
<!-- Big-tourelle -->
<button class="build-tile" data-tip="Big-tourelle (HP: 2500, Dégâts: 25, Cadence: 2/s)" data-type="G" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#b48cff;border:2px solid #2b1b3a;box-shadow:0 2px 8px #0007; position:relative;">
<div style="position:absolute; left:50%; top:50%; width:16px; height:16px; background:#000; transform:translate(-50%,-50%); border-radius:2px;"></div>
</div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$5000</div>
</button>
<!-- Mini-tourelle -->
<button class="build-tile" data-tip="Mini-tourelle (HP: 200, Dégâts: 5, Cadence: 1 tir / 2s)" data-type="t" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#3aa6ff;border:2px solid #0b1b2a;box-shadow:0 2px 8px #0007; position:relative;">
<div style="position:absolute; left:50%; top:50%; width:16px; height:16px; background:#000; transform:translate(-50%,-50%); border-radius:2px;"></div>
</div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$250</div>
</button>
<!-- Mur (barricade) -->
<button class="build-tile" data-tip="Mur (HP: 500)" data-type="B" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#7b4b2a;border:2px solid #000;box-shadow:0 2px 8px #0007;"></div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$100</div>
</button>
<!-- Porte -->
<button class="build-tile" data-tip="Porte (HP: 500)" data-type="D" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#a57b4a;border:2px solid #000;box-shadow:0 2px 8px #0007;"></div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$200</div>
</button>
</div>
<!-- Tooltip hover -->
<div id="buildTooltip" style="display:none; position:absolute; right:0; bottom:70px; max-width:260px; background:#111c; color:#fff; font-size:13px; padding:8px 10px; border-radius:8px; box-shadow:0 4px 18px #000a; pointer-events:none; white-space:nowrap;"></div>
</div>
<div id="shopModal" style="display:none; position:fixed; right:34px; bottom:90px; background:#181e19ee; border-radius:18px; box-shadow:0 8px 28px #000c; padding:18px 16px 16px 16px; width:360px; max-height:calc(100dvh - 120px); overflow:hidden;">
<button id="shopClose" style="position:absolute; right:17px; top:10px; background:none; border:none; color:#fff; font-size:26px; cursor:pointer; filter:drop-shadow(0 2px 6px #0009);">✕</button>
<div style="font-size:26px; margin-bottom:15px; display:flex; align-items:center; gap:10px;">
<img alt="Upgrades" src="/icons/cart.svg" style="width:30px; filter:brightness(1.2); vertical-align:middle;"/>
<span id="shopTitleText">UPGRADES</span>
</div>
<div id="shopUpgrades">
<!-- Ici viendront les lignes d’améliorations à l’étape suivante -->
<div style="color:#fff6; font-size:17px; margin-top:18px;">Boutique à venir : <i>Affichage des améliorations ici à l’étape 3</i></div>
</div>
</div>
<div id=\"versionBox\"></div>
<div id=\"workerBox\" title=\"Server\"></div>
<!-- workerBox inserted -->
<script>window.GAME_VERSION = "1.0.0";</script>
<div id="waveMessage"></div>
<script src="/socket.io/socket.io.js"></script>
<!-- Server selection overlay -->
<style>
  #serverOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.75);z-index:999999;}
  #serverBox{background:#14161a;border:1px solid #2a2f39;border-radius:14px;box-shadow:0 10px 40px #000a;padding:14px 16px;width:min(92vw,380px);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif;color:#fff;}
  #serverBox h3{margin:4px 4px 10px 4px;font-size:18px;font-weight:800;color:#fff;}
  .srv{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:9px 12px;margin:8px 6px;border-radius:10px;background:#0f1216;border:1px solid #29303a;}
  .srv .name{font-weight:700;}
  .srv .count{font-size:12px;color:#9ab;margin-top:2px;}
  .srv .btn{min-width:64px;border:0;border-radius:8px;padding:6px 10px;cursor:pointer;background:#20b36a;color:#fff;font-weight:700}
  .srv .btn[disabled]{opacity:.55;cursor:not-allowed;background:#444;}
  .srv .full{background:#7a1d1d}
  #srvFoot{font-size:12px;color:#8aa; text-align:right; padding: 0 8px;}
  .chatTime{font-size:12px;color:#9ab;opacity:.9;margin-right:6px;}
</style>
/* [PATCH] push chat behind when server overlay is open */
<style id="chatOverlayMaskStyle">
  .overlay-server #chatPanel,
  .overlay-server #chatCollapsedBtn {
    z-index: -1 !important;
    pointer-events: none !important;
    opacity: 0 !important;
    visibility: hidden !important;
  }
  .chatTime{font-size:12px;color:#9ab;opacity:.9;margin-right:6px;}
</style>

<div id="serverOverlay">
  <div id="serverBox" role="dialog" aria-label="Select a server">
    <h3>Select a server</h3>
    <div id="srvList"></div>
    <div id="srvFoot"></div>
  </div>
</div>
<script>
(function(){
  if (window.__serverOverlayInstalled) return;
  window.__serverOverlayInstalled = true;

  function getCookie(name){
    try{ var m = document.cookie.match(new RegExp('(?:^|; )'+name+'=([^;]*)')); return m ? decodeURIComponent(m[1]) : ''; }catch(_){ return ''; }
  }
  function showOverlay(){ var o = document.getElementById('serverOverlay'); if (o) o.style.display='flex'; try{ (document.documentElement||document.body).classList.add('overlay-server'); }catch(_){} }
  function hideOverlay(){ var o = document.getElementById('serverOverlay'); if (o) o.style.display='none'; try{ (document.documentElement||document.body).classList.remove('overlay-server'); }catch(_){} }

  const params = new URLSearchParams(location.search||'');
  const hasWParam = params.has('w');
  const hasWCookie = !!getCookie('w');

  // Show overlay only if no worker has been chosen yet
  if (!hasWParam && !hasWCookie) showOverlay();

  async function refreshServers(){
    try {
      const r = await fetch('/api/servers', { cache: 'no-store' });
      const j = await r.json();
      if (!j || !j.ok) throw new Error('bad');
      var list = document.getElementById('srvList');
      if (!list) return;
      list.innerHTML = '';
      for (var i=0;i<j.total;i++){
        var count = (j.workers && j.workers[i] ? (j.workers[i].count|0) : 0);
        var full = count >= (j.capacity|0);
        var row = document.createElement('div'); row.className='srv';
        var left = document.createElement('div'); left.innerHTML = '<div class="name">Server '+(i+1)+'</div><div class="count">'+count+'/'+j.capacity+' players</div>';
        var btn = document.createElement('button'); btn.className='btn'; btn.textContent = full ? 'Full' : 'Join'; if (full) { btn.setAttribute('disabled',''); btn.classList.add('full'); }
        (function(idx, disabled){
          btn.addEventListener('click', function(ev){
            ev.preventDefault();
            if (disabled) return;
            // Selecting a server navigates with ?w=N
            try { location.href = '/?w=' + idx; } catch(_){}
          });
        })(i+1, full);
        row.appendChild(left); row.appendChild(btn); list.appendChild(row);
      }
    } catch(e){ /* ignore */ }
  }
  setInterval(refreshServers, 1500);
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', refreshServers, {passive:true}); else refreshServers();

  // If a server gets full after we join, redirect back to chooser
  try {
    if (window.socket && typeof socket.on==='function') {
      socket.on('serverFull', function(){ try{ alert('Server full'); }catch(_){ } try{ location.href='/'; }catch(_){} });
    }
  } catch(_){}
})();
</script>

<script>
// === Global orientation caches ===
window.prevPlayerPos = {};
window.lastPlayerAngle = {};
window.prevZombiePos = {};
window.lastZombieAngle = {};



const __params = new URLSearchParams(window.location.search || '');
const __wParam = __params.get('w');
const ioOpts = { transports: ['polling','websocket'] };
if (__wParam) {
  const _wk = parseInt(__wParam, 10);
  if (Number.isFinite(_wk)) ioOpts.query = { w: String(_wk) };
}
// Important: until the user explicitly joins, no 'w' cookie is written by the server.
const socket = io(ioOpts);
console.log("📡 Tentative de connexion au serveur Socket.IO");
socket.on("connect", () => {
console.log("✅ Connecté au serveur Socket.IO. ID:", socket.id);
  try {
    socket.emit("clientHello", {
      v: (window.GAME_VERSION || "1.0.0"),
      tz: (Intl.DateTimeFormat().resolvedOptions().timeZone || "?")
    });
  } catch (e) {}

  try {
    let __gid = 0, __tok = '';
    try { __gid = Number(localStorage.getItem('zombi_host_game') || '0'); } catch(_) {}
    try { __tok = String(localStorage.getItem('zombi_host_token') || ''); } catch(_) {}
    if (__gid && __tok) {
      socket.emit('reclaimHost', { gameId: __gid, token: __tok }, function(res){
        try { console.log('[reclaimHost]', res); } catch(_) {}
      });
    }
  } catch(_) {}

  // Try to reclaim previous lobby seat (non-host) if we have a saved lobby id + pseudo
  try {
    var __last_gid = 0, __last_pseudo = '';
    try { __last_gid = Number(localStorage.getItem('zombi_last_gid') || '0'); } catch(_){}
    try { __last_pseudo = String(localStorage.getItem('zombi_pseudo') || '').trim(); } catch(_){ }
    if (__last_gid && __last_pseudo) {
      socket.emit('reclaimPlayer', { gameId: __last_gid, pseudo: __last_pseudo }, function(res){
        try { console.log('[reclaimPlayer]', res); } catch(_){}
      });
    }
  } catch(_) {}
});

// Global guards to prevent any crash from bubbling up and blanking the page
window.addEventListener('error', function(e){ try { console.error('Global error:', e && e.message, e); } catch(_){} });
window.addEventListener('unhandledrejection', function(e){ try { console.error('Unhandled rejection:', e && e.reason); } catch(_){} });



// LOBBY STATE LOGS

socket.on("lobbyUpdate", (data) => {
  try {
    console.log("📥 [SOCKET] Reçu lobbyUpdate:", data);
    window.lobbyData = data;

      try {
        var pseudoEl = document.getElementById('pseudoInput');
        var mePseudo = pseudoEl ? String(pseudoEl.value || '') : '';
        if (mePseudo && data && data.players) {
          for (var sid in data.players) {
            var p = data.players[sid];
            if (p && String(p.pseudo||'') === mePseudo) {
              window.__candidateSid = sid;
              try { localStorage.setItem('zombi_candidate_sid', sid); } catch(_){}
              break;
            }
          }
        }
      } catch(_){}

    // Persist last known lobby id (only while lobby not yet started)
    if (data && !data.started && typeof data.id !== "undefined") {
      try { localStorage.setItem('zombi_last_gid', String(data.id)); } catch(_){}
    }
  } catch (e) { try { console.error(e); } catch(_){} }
});

socket.emit("requestLobbyState");
console.log("📤 [SOCKET] Emit requestLobbyState");

/* Inline Kick handler — ultra robust, no dependency on re-renders */
(function(){
  try {
    if (window.__kickBtn) return;
    window.__kickBtn = function(btn, ev){
      try {
        if (!btn) return;
        try{ if(ev){ if(ev.preventDefault) ev.preventDefault(); if(ev.stopPropagation) ev.stopPropagation(); } }catch(_){ }
        var targetId = btn.getAttribute('data-target');
        console.log('[KICK] Click inline → targetId=', targetId);
        if (!targetId || targetId === 'host') return;
        var ld = (window.lobbyData || {});
        var amHost = !!(ld && ld.manual && !ld.started && ld.hostId && window.socket && window.socket.id && ld.hostId === socket.id);
        if (!amHost) { return; }
        if (targetId === socket.id) return;
        if (btn.__kicking) return;
        btn.__kicking = true;
        btn.disabled = true;
        try {
          socket.emit('kickPlayer', { targetId: targetId }, function(res){
            try {
              if (!res || !res.ok) {
                btn.__kicking = false;
                btn.disabled = false;
                try {
                  var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
                  var msg = tr.actionImpossible || 'Action impossible.';
                  console.warn('[KICK] Refusé:', res && res.reason);
                  showTopMessage(msg + (res && res.reason ? (' [' + res.reason + ']') : ''));
                } catch(_){}
              } else {
                console.log('[KICK] Émis et accepté, mise à jour via lobbyUpdate.');
              }
            } catch(_){}
          });
        } catch(_){
          btn.__kicking = false;
          btn.disabled = false;
        }
      } catch(_){}
    };
  } catch(_){}
})();

// JOIN BUTTON
if (lobbyJoin) {
  if (lobbyJoin) lobbyJoin.addEventListener("click", () => {
    const pseudo = pseudoInput.value;
    console.log("👤 Bouton JOIN cliqué. Pseudo saisi:", pseudo);
    try{ var now=Date.now(); if (typeof window.__joinLockTs==='number' && (now-window.__joinLockTs)<1200){ debugWarn('⛔ join re-entry blocked (A)', (now-window.__joinLockTs),'ms'); return; } window.__joinLockTs=now; var btn=document.getElementById('lobbyJoin'); if(btn){ btn.disabled=true; btn.dataset.clicked='1'; setTimeout(function(){ try{btn.disabled=false;}catch(_){}} , 900);} }catch(_){}
if (!pseudo) return;
  });
}

// TIMER & UI DEBUG
setInterval(() => {
  if (typeof lobbyData !== "undefined") {
    console.log("⏳ Lobby Timer:", lobbyData.timeLeft, " | Players:", lobbyData.count);
  }
}, 5000);

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script src="/translations.js">
window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script>
// Safe translation accessor and singleton helper.
// Avoids "Identifier 'trLoc' has already been declared" if scripts reload.
(function(){
  if (!window.trLoc) {
    window.trLoc = function(key, fallback){
      try {
        var lang = (typeof window.currentLang === 'string' && window.currentLang) || (navigator.language||'en').slice(0,2);
        var pack = (window.TRANSLATIONS && window.TRANSLATIONS[lang]) || (window.TRANSLATIONS && window.TRANSLATIONS['en']) || {};
        return (pack && pack[key]) || (fallback || key);
      } catch(e){ return fallback || key; }
    };
  }

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
  if (typeof TRANSLATIONS === "undefined") { window.TRANSLATIONS = { fr: {}, en: {} }; }

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<!-- === Mobile Build Buttons === -->
<div class="mobile-build" id="mobile-build">
<button aria-label="Construire Mur (B)" class="mb-btn" data-type="B">Mur</button>
<button aria-label="Construire Porte (D)" class="mb-btn" data-type="D">Porte</button>
<button aria-label="Construire Mini-Tourelle (t)" class="mb-btn" data-type="t">Mini-T</button>
<button aria-label="Construire Grande Tourelle (T)" class="mb-btn" data-type="T">Tourelle</button>
</div>
<style>
  /* Mobile only */
  
	 @media (max-width: 768px) and (orientation: portrait) {
	  .mobile-build { 
		display: none !important; 
	  }
	}
  @media (max-width: 768px) {
	.mobile-build {
	  position: fixed;
	  left: 50%;
	  bottom: calc(env(safe-area-inset-bottom, 0px) + 96px); /* marge iOS + au-dessus du Shop */
	  transform: translateX(-50%);
	  display: grid;
	  grid-template-columns: repeat(4, auto);
	  gap: 10px;
	  padding: 10px 12px;
	  background: rgba(0,0,0,0.35);
	  backdrop-filter: blur(6px);
	  border-radius: 14px;
	  z-index: 10007; /* supérieur au Shop */
	  user-select: none;
	}
 .mb-btn {
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      background: #222;
      color: #fff;
    }
    .mobile-build .mb-btn:active {
      transform: translateY(1px);
    }
  }

  /* Desktop: hide */
  @media (min-width: 769px) {
    .mobile-build { display: none; }
  }
</style>
<!-- === /Mobile Build Buttons === -->
<script>
// === Toggle (réduire/afficher) la barre Auto-Fire + 4 constructions ===
let BUILD_UI_COLLAPSED = (localStorage.getItem('buildUICollapsed') === '1');

function applyBuildUICollapse() {
  const autoBtn = document.getElementById('autoFireBtn');
  const tiles = document.getElementById('buildTiles');
  const tgl = document.getElementById('toggleBuildUI');
  if (!tgl) return;
  if (BUILD_UI_COLLAPSED) {
    if (autoBtn) autoBtn.style.display = 'none';
    if (tiles) tiles.style.display = 'none';
    tgl.textContent = '+';
    tgl.title = 'Afficher les boutons';
  } else {
    if (autoBtn) autoBtn.style.display = 'flex';
    if (tiles) tiles.style.display = 'flex';
    tgl.textContent = '–';
    tgl.title = 'Réduire les boutons';
  }
  // repositionne si besoin pour mobile
  if (typeof positionShopUI === 'function') {
    positionShopUI();
  }
}

(function initBuildUIToggle(){
  const tgl = document.getElementById('toggleBuildUI');
  if (!tgl) return;
  tgl.addEventListener('click', () => {
    BUILD_UI_COLLAPSED = !BUILD_UI_COLLAPSED;
    localStorage.setItem('buildUICollapsed', BUILD_UI_COLLAPSED ? '1' : '0');
    applyBuildUICollapse();
  }, {passive:true});
  tgl.addEventListener('touchstart', (e) => {
    e.preventDefault();
    BUILD_UI_COLLAPSED = !BUILD_UI_COLLAPSED;
    localStorage.setItem('buildUICollapsed', BUILD_UI_COLLAPSED ? '1' : '0');
    applyBuildUICollapse();
  }, {passive:false});
  applyBuildUICollapse();
})();
// === /Toggle build UI ===

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script>
/* SWAP_G_T_IN_BUILD */
document.addEventListener('DOMContentLoaded', function(){
  const cont = document.getElementById('buildTiles');
  if (!cont) return;
  const g = cont.querySelector('.build-tile[data-type="G"]');
  const t = cont.querySelector('.build-tile[data-type="T"]');
  if (g && t && g.nextElementSibling !== t) {
    cont.insertBefore(g, t);
  }
});

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script>
// Unified UI language getter: always honor menu selection (window.currentLang), fallback 'en'.
function __uiLang(){
  try {
    var raw = (typeof window.currentLang === 'string' && window.currentLang) || (navigator.language||'en');
    raw = String(raw).slice(0,2);
    var alias = { ja:'jp', zh:'cn', ko:'kr' };
    return alias[raw] || raw || 'en';
  } catch(_){ return 'en'; }
}

/* TURRET_UPGRADE_CLIENT */
let myTurretUp = { t:0, T:0, G:0 };
function turretUpgradeBaseAdd(type){ return type==='t'?5: (type==='T'?10:25); }
function turretBaseDamage(type){ return type==='t'?5: (type==='T'?10:25); }
function turretBonusFromLevels(type, lvl){
  const a = turretUpgradeBaseAdd(type);
  if (lvl<=0) return 0;
  return a * (Math.pow(1.1, lvl) - 1) / 0.1;
}
function computeTurretDamageDisplay(type){
  const base = turretBaseDamage(type);
  const bonus = turretBonusFromLevels(type, myTurretUp[type]||0);
  return Math.round(base + bonus);
}

// Cooldown display
const turretCooldownUntil = { t:0, T:0, G:0 };
socket.on('turretCooldown', (p)=>{
  if (!p || !p.type) return;
  turretCooldownUntil[p.type] = p.until || 0;
});
// Tooltip damage update
// --- Wall/Door place cooldown (shared) ---
let blockCooldownUntil = 0;
socket.on('blockCooldown', (p)=>{
  try { blockCooldownUntil = (p && p.until) ? p.until : 0; } catch(_) { blockCooldownUntil = 0; }
});
const buildTilesCont = document.getElementById('buildTiles');
if (buildTilesCont){
  buildTilesCont.querySelectorAll('.build-tile').forEach(btn=>{
    btn.addEventListener('mouseenter', ()=>{
      const type = btn.getAttribute('data-type');
      const tip0 = btn.getAttribute('data-tip') || '';
      if (['t','T','G','B','D'].includes(type)){
      const tr = (TRANSLATIONS[__uiLang()] || TRANSLATIONS['en']) || {};
      const names = (tr.turretType || {});
      const hpLabel = tr.hpShort || 'HP';
      const dmgLabel = tr.damage || 'Damage';
      const rateLabel = tr.fireRate || 'Fire rate';
      const baseHP = { T:500, t:200, G:2500, B:500, D:500 };
      let name = (type==='B') ? (tr.buildWall || 'Wall') : (type==='D') ? (tr.buildDoor || 'Door') : (names[type] || 'Turret'); name = upperFirstLocalized(name);
      let tip;
      if (type==='B' || type==='D') {
        tip = name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ')';
      } else {
        const rate = (type==='T') ? '1' : (type==='G') ? '2' : '0.5';
        const dmg = computeTurretDamageDisplay(type);
        tip = name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ', ' + dmgLabel + ': ' + dmg + ', ' + rateLabel + ': ' + rate + ((TRANSLATIONS[__uiLang()]||TRANSLATIONS['en']).perSec||'/s') + ')';
      }
      const tEl = document.getElementById('buildTooltip'); if (tEl){ tEl.textContent = tip; }
    }
    }, {passive:true});
  });
}
setInterval(()=>{
  document.querySelectorAll('#buildTiles .build-tile').forEach(btn=>{
    const type = btn.getAttribute('data-type');
    const priceLabel = btn.querySelector('div:nth-child(2)');
    let cd = btn.querySelector('.cd-label');
    if (!cd){
      cd = document.createElement('div');
      cd.className = 'cd-label';
      cd.style.fontSize = '11px';
      cd.style.color = '#ff9';
      cd.style.marginTop = '2px';
      btn.appendChild(cd);
    }
    
    if (['t','T','G'].includes(type)){
      const rem = Math.max(0, turretCooldownUntil[type] - Date.now());
      cd.textContent = rem > 0 ? (Math.ceil(rem/1000)+'s') : '';
    }
    else if (type === 'B' || type === 'D') {
      const rem = Math.max(0, blockCooldownUntil - Date.now());
      cd.textContent = rem > 0 ? (Math.ceil(rem/1000)+'s') : '';
    } else {
      cd.textContent = (window.trLoc ? trLoc('rotateToPortrait', 'Rotate your device to portrait.') : 'Rotate your device to portrait.');
    }
  });
}, 500);

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<!-- perf overlay patch: sort by consumption desc and 1s refresh -->
<script>
window.addEventListener('beforeunload', function(){
  try{
    if (window.socket && window.socket.connected && window.lobbyData && window.lobbyData.manual && !window.lobbyData.started && window.lobbyData.hostId === socket.id){
      socket.emit('hostBackManual', function(){});
    }
  }catch(_){}
});
</script>

<script>
(function(){
  if (!window || !window.__DEV_PERF) return;
  const wanted = [
    'CPU/Update',
    'Map','Structures','Bullets','Turrets','Zombies','Players','AimLine','MoneyTexts','BuildPreview','Light','HUD','Other'
  ];
  const DEV = window.__DEV_PERF;
  DEV.intervalMs = 1000;        // refresh every 1s
  DEV._lastRender = DEV._lastRender || 0;
  DEV._forceNext = DEV._forceNext || false;

  DEV.renderOverlay = function(extraCounts){
    const now = (performance && performance.now) ? performance.now() : Date.now();
    const box = document.getElementById('devPerfPanel');
    if (!box) return;
    if (!this.on) { box.style.display='none'; return; }
    if (!this._lastRender) this._lastRender = 0;
    if (!this._forceNext && (now - this._lastRender) < this.intervalMs) return;
    this._forceNext = false;
    this._lastRender = now;

    const total = Math.max(0.001, this.lastFrameMs);
    const lines = [];
    lines.push('— GPU/CPU profiler —');
    lines.push(`Frame ~ ${total.toFixed(1)} ms (${Math.round(1000/total)} FPS)`);
    if (extraCounts) {
      const cls = [
        `Zombies:${extraCounts.z||0}`,
        `Turrets:${extraCounts.t||0}`,
        `Players:${extraCounts.p||0}`,
        `Bots:${extraCounts.b||0}`,
        `Bullets:${extraCounts.bul||0}`,
        `Structures:${extraCounts.s||0}`,
        `Lasers:${extraCounts.l||0}`,
        `Map:${extraCounts.mapw||0}x${extraCounts.maph||0}`,
      ];
      lines.push(cls.join(' • '));
    }
    lines.push('');

    // build and sort entries by ms desc
    const entries = wanted.map(k => ({
      k,
      ms: (this.ema && this.ema[k]) ? this.ema[k] : 0,
      tag: (k === 'CPU/Update') ? 'CPU' : 'GPU'
    })).sort((a,b)=> b.ms - a.ms);

    for (const e of entries) {
      const pct = Math.min(999, (e.ms / total) * 100);
      lines.push(`${e.k}: ${e.tag} = ${pct.toFixed(1)}% (${e.ms.toFixed(2)}ms)`);
    }

    box.textContent = lines.join('\n');
    box.style.display='block';
  };
})();

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<!-- dev-perf-restore-patch -->
<script>
(function(){"use strict";
  if (!window.__DEV_PERF) window.__DEV_PERF = {
    on: false,
    ema: Object.create(null),
    lastFrameMs: 16.7,
    add(name, ms){ if(Number.isFinite(ms)) this.ema[name]=(this.ema[name]||0)+0.2*(ms-(this.ema[name]||0)); },
    setFrame(ms){ this.lastFrameMs = this.lastFrameMs + 0.2 * (ms - this.lastFrameMs); }
  };
  const DEV = window.__DEV_PERF;
  DEV.intervalMs = 1000;
  DEV._lastRender = DEV._lastRender || 0;
  DEV._forceNext = !!DEV._forceNext;
  const WANTED = ['CPU/Update','Map','Structures','Bullets','Turrets','Zombies','Players','AimLine','MoneyTexts','BuildPreview','Light','HUD','Other'];
  const orig = typeof DEV.renderOverlay === 'function' ? DEV.renderOverlay.bind(DEV) : null;
  DEV.renderOverlay = function(extraCounts) { 
    const now = (performance && performance.now) ? performance.now() : Date.now();
    const box = document.getElementById('devPerfPanel'); if (!box) return;
    if (!this.on) { box.style.display = 'none'; return; }
    if (!this._lastRender) this._lastRender = 0;
    if (!this._forceNext && (now - this._lastRender) < this.intervalMs) return;
    this._forceNext = false; this._lastRender = now;
    const total = Math.max(0.001, this.lastFrameMs);
    const lines = [];
    lines.push('— GPU/CPU profiler —');
    lines.push(`Frame ~ ${total.toFixed(1)} ms (${Math.round(1000/total)} FPS)`);
    if (extraCounts) {
      const cls = [
        `Zombies:${extraCounts?.z||0}`,
        `Turrets:${extraCounts?.t||0}`,
        `Players:${extraCounts?.p||0}`,
        `Bots:${extraCounts?.b||0}`,
        `Bullets:${extraCounts?.bul||0}`,
        `Structures:${extraCounts?.s||0}`,
        `Lasers:${extraCounts?.l||0}`,
        `Map:${extraCounts?.mapw||0}x${extraCounts?.maph||0}`,
      ];
      lines.push(cls.join(' • '));
    }
    lines.push('');
    const entries = WANTED.map(k=>({ k, ms: (this.ema && this.ema[k]) ? this.ema[k] : 0, tag: (k==='CPU/Update')?'CPU':'GPU' })).sort((a,b)=> b.ms - a.ms);
    for (const e of entries) {
      const pct = Math.min(999, (e.ms / total) * 100);
      lines.push(`${e.k}: ${e.tag} = ${pct.toFixed(1)}% (${e.ms.toFixed(2)}ms)`);
    }
    box.textContent = lines.join('\n');
    box.style.display = 'block';
    if (orig) try { orig(extraCounts); } catch(_){}
  };
  if (!window.__DEV_PERF__iBound) {
    window.__DEV_PERF__iBound = true;
    window.addEventListener('keydown', function(e){
      const k = e && (e.key||e.code);
      if ((k==='i' || k==='I') && (typeof myPseudo==='string') && myPseudo==='Myg') {
        DEV.on = !DEV.on;
        DEV._forceNext = true;
        try { DEV.renderOverlay(null); } catch(_){}
      }
    }, {passive:true});
  }
})();

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script>
  

  
  // === Early globals for sprites & orientation ===
  // Provide globals before any game loop starts to avoid TDZ issues
  window.recentShootDir = window.recentShootDir || new Map();
  // Default sprite base rotation: images face DOWN; we need RIGHT at angle 0 => -90deg
  const SHOOT_DIR_TTL_MS = 650; // keep facing target between bullets (<=500ms gap)
  window.SPRITE_BASE_ROT = (typeof window.SPRITE_BASE_ROT === 'number') ? window.SPRITE_BASE_ROT : -Math.PI/2;
  const recentShootDir = window.recentShootDir;

  if (typeof window.playerImg === 'undefined') {
    window.playerImg = new Image();
    window.playerImg.src = '/sprites/player.png';
  }
  if (typeof window.zombieImg === 'undefined') {
    window.zombieImg = new Image();
    window.zombieImg.src = '/sprites/zombies.png';
  }
window.addEventListener('contextmenu', e => e.preventDefault(), { passive: false });
    // --- LANG/LOBBY ---
    const LANGS = [
      { code: 'en', flag: 'gb.png', label: 'English' },
      { code: 'cn', flag: 'cn.png', label: '中文' },
      { code: 'ru', flag: 'ru.png', label: 'Русский' },
      { code: 'es', flag: 'es.png', label: 'Español' },
      { code: 'pt', flag: 'pt.png', label: 'Português' },
      { code: 'de', flag: 'de.png', label: 'Deutsch' },
      { code: 'jp', flag: 'jp.png', label: '日本語' },
      { code: 'fr', flag: 'fr.png', label: 'Français' },
      { code: 'pl', flag: 'pl.png', label: 'Polski' },
      { code: 'kr', flag: 'kr.png', label: '한국어' }
    ];
    function getDefaultLang() { return "en"; }
    let currentLang = getDefaultLang();
    window.currentLang = currentLang; let lobbyData = { started: false, count: 0, max: 6, timeLeft: 30, players: {} };
    let lobbyJoined = false, lobbyStarted = false;
    function initLobbyTexts() {
      updateLobbyTexts();
      pseudoInput.placeholder = TRANSLATIONS[currentLang].enterPseudo;
if (lobbyJoin)       lobbyJoin.textContent = TRANSLATIONS[currentLang].join;
    }
    function updateLobbyTexts() {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
            const _max = Number((lobbyData && lobbyData.max)) || 6;
      let _count = 0;
      try {
        if (lobbyData && typeof lobbyData.players === 'object' && lobbyData.players) {
          _count = Object.keys(lobbyData.players).length;
        } else if (lobbyData && Array.isArray(lobbyData.players)) {
          _count = lobbyData.players.length;
        } else if (typeof lobbyData.count !== 'undefined') {
          _count = Number(lobbyData.count) || 0;
        }
      } catch(_){ _count = Number(lobbyData && lobbyData.count) || 0; }
      lobbyPlayers.textContent = `${tr.playersInGame} : ${_count}/${_max}`;
      lobbyTimer.textContent = `${tr.timeLeft} : ${lobbyData.timeLeft}s`;
      const readyCount = Object.values(lobbyData.players).filter(p=>p.ready).length;
      lobbyStatus.textContent = `${tr.waitingStart} (${readyCount} ${tr.playersReady}${readyCount>1?'s':''})`;
    }
    function updateUITexts() {
  function applyJoinLabel(){
    const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
    const el = document.getElementById('lobbyJoin');
    if (!el) return;
    el.textContent = lobbyJoined ? (tr.waiting || 'Waiting') : (tr.join || 'Join');
  }

  const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];

  // Title and basics
  const lobbyTitleEl = document.getElementById('lobbyTitle');
  if (lobbyTitleEl) lobbyTitleEl.innerHTML = `<b>${tr.zombination}</b>`;
  if (pseudoInput) pseudoInput.placeholder = tr.enterPseudo || '';
  if (lobbyJoin) lobbyJoin.textContent = lobbyJoined ? (tr.waiting || 'Waiting') : (tr.join || 'Join'); applyJoinLabel();

  // Death screen
  const deathTitle = document.getElementById('deathTitle');
  if (deathTitle) deathTitle.textContent = tr.youDied || 'You died!';
  const btnReplay = document.getElementById('btnReplay');
  if (btnReplay) btnReplay.textContent = tr.replay || 'Replay';
  if (typeof updateLobbyTexts === 'function' && !lobbyStarted) { updateLobbyTexts(); }

  // Main menu & lobby buttons / headers
  const btnJoinLobbyList = document.getElementById('btnJoinLobbyList');
  if (btnJoinLobbyList) btnJoinLobbyList.textContent = tr.joinLobby || 'Join lobby';
  const btnCreateLobby = document.getElementById('btnCreateLobby');
  if (btnCreateLobby) btnCreateLobby.textContent = tr.createLobby || 'Create lobby';
  const btnStartManual = document.getElementById('btnStartManual');
  if (btnStartManual) btnStartManual.textContent = tr.start || 'Start';
  const btnBackFromManual = document.getElementById('btnBackFromManual');
  if (btnBackFromManual) btnBackFromManual.textContent = tr.back || 'Back';
  const btnBackFromList = document.getElementById('btnBackFromList');
  if (btnBackFromList) btnBackFromList.textContent = tr.back || 'Back';
  const manualLobbyTitle = document.getElementById('manualLobbyTitle');
  if (manualLobbyTitle) {
    // Keep number if already set "Lobby #X"
    const current = manualLobbyTitle.textContent || '';
    const num = (current.match(/\d+/) || [null])[0];
    manualLobbyTitle.textContent = (tr.lobby || 'Lobby') + (num ? (' #' + num) : '');
  }
  const manualLobbyNote = document.getElementById('manualLobbyNote');
  if (manualLobbyNote) manualLobbyNote.textContent = tr.onlyCreatorStart || 'Only the creator can start.';
  const joinLobbyTitle = document.getElementById('joinLobbyTitle');
  if (joinLobbyTitle) joinLobbyTitle.textContent = tr.availableLobbies || 'Available lobbies';

  // Shop button + modal header
  const shopBtn = document.getElementById('shopBtn');
  if (shopBtn) {
    shopBtn.title = tr.shop || 'Shop';
    // Recompose inner content with cart icon + label
    shopBtn.innerHTML = `<img alt="${tr.shop || 'Shop'}" src="/icons/cart.svg" style="width: 27px; height: 27px; margin-right: 8px; filter: brightness(1.25) drop-shadow(0 2px 5px #0006);"/>` + (tr.shop || 'Shop');
  }
  const shopTitleText = document.getElementById('shopTitleText');
  if (shopTitleText) shopTitleText.textContent = tr.shop || 'Shop';

  try { if (typeof updateAutoFireBtnUI === 'function') updateAutoFireBtnUI(); } catch(e){}

  // Mobile build buttons
  try {
    document.querySelectorAll('.mobile-build .mb-btn').forEach(btn => {
      const type = btn.getAttribute('data-type');
      if (!type) return;
      if (type === 'B') { btn.textContent = tr.buildWall || btn.textContent; btn.setAttribute('aria-label', (tr.buildWall || btn.textContent) + ' (B)'); }
      else if (type === 'D') { btn.textContent = tr.buildDoor || btn.textContent; btn.setAttribute('aria-label', (tr.buildDoor || btn.textContent) + ' (D)'); }
      else if (type === 't') { btn.textContent = tr.buildMiniTurret || btn.textContent; btn.setAttribute('aria-label', (tr.buildMiniTurret || btn.textContent) + ' (t)'); }
      else if (type === 'T') { btn.textContent = tr.buildTurret || btn.textContent; btn.setAttribute('aria-label', (tr.buildTurret || btn.textContent) + ' (T)'); }
    });
  } catch(e){}
    
  try { if (typeof renderManualPlayers === 'function') renderManualPlayers(); } catch(e){}
  try { if (typeof translateEmptySlotsInManualLobby === 'function') translateEmptySlotsInManualLobby(); } catch(e){}

// Ultra-robust: ensure empty placeholders in manual lobby reflect current language instantly
window.translateEmptySlotsInManualLobby = function(){
  try {
    var tr = (window.TRANSLATIONS && (window.TRANSLATIONS[window.currentLang] || window.TRANSLATIONS['en'])) || {};
    var label = tr.emptySlot || 'empty';
    var container = document.getElementById('manualLobbyPlayers');
    if (!container) return;
    // Build a set of all known "empty" labels from the translation packs (cached)
    if (!window.__knownEmptyLabels) {
      var known = new Set(['empty']);
      try {
        var T = window.TRANSLATIONS || {};
        Object.keys(T).forEach(function(k){
          var v = T[k] && T[k].emptySlot;
          if (v) known.add(String(v).trim());
        });
      } catch(_){}
      window.__knownEmptyLabels = known;
    }
    var knownSet = window.__knownEmptyLabels;
    // Replace any cell that currently shows an old empty label
    var cells = container.querySelectorAll('td, div, span, button');
    cells.forEach(function(el){
      var txt = (el.textContent || '').trim();
      if (!txt || knownSet.has(txt)) {
        el.textContent = label;
      }
    });
  } catch(_){}
};;
}
const langSelectRow = document.getElementById('langSelectRow');
    function renderLangFlags() {
      langSelectRow.innerHTML = '';
      LANGS.forEach(lang => {
        const img = document.createElement('img');
        img.src = `/flags/${lang.flag}`;
        img.alt = lang.label;
        img.title = lang.label;
        img.className = 'langFlag' + (lang.code === currentLang ? ' selected' : '');
        img.onclick = async () => {
          if (currentLang !== lang.code) {
            currentLang = lang.code;
            window.currentLang = currentLang; renderLangFlags(); updateUITexts(); try { if (typeof translateEmptySlotsInManualLobby === 'function') translateEmptySlotsInManualLobby(); } catch(e){} try { if (typeof renderManualPlayers === 'function') renderManualPlayers(); } catch(e) {}; drawHUD();
          }
        };
        langSelectRow.appendChild(img);
      });
    }
    const pseudoInput = document.getElementById('pseudoInput');
	pseudoInput.addEventListener('input', function() {
	  this.value = this.value.replace(/[^a-zA-Z0-9]/g, '');
	});

    
    // Ensure global access to inputs/buttons for all handlers
    try {
      if (typeof window !== 'undefined') {
        if (typeof pseudoInput !== 'undefined' && pseudoInput) window.pseudoInput = pseudoInput;
        var lobbyJoin = document.getElementById("lobbyJoin") || window.lobbyJoin;
        if (lobbyJoin) window.lobbyJoin = lobbyJoin;
      }
    } catch(_){}
renderLangFlags(); initLobbyTexts(); updateUITexts(); try { if (typeof translateEmptySlotsInManualLobby === 'function') translateEmptySlotsInManualLobby(); } catch(e){}

    // --- JEU ---
    

window.socket = socket;
window.__reloading = window.__reloading || false;
function hardReload(){
  if (window.__reloading) return;
  window.__reloading = true;
  try { if (socket && socket.connected) socket.disconnect(); } catch(e){}
  try { location.reload(); } catch(e){}
  setTimeout(function(){ try { location.replace(location.href); } catch(e){} }, 60);
}

window.__reloading = false;

// When a manual lobby is closed by its host, simulate Back for everyone
socket.on('lobbyClosed', function(){ try{ showMain(); window.lobbyJoined=false; if (pseudoInput){ pseudoInput.disabled=false; if(window.myPseudo) pseudoInput.value=window.myPseudo; } try{ updateButtonsDisabled(); }catch(_){}}catch(_){} });
socket.on('forceReload', function(){
  if (window.__reloading) return;
  window.__reloading = true;
  try { if (socket && socket.connected) socket.disconnect();
socket.on('playerDisconnected', function(sid){
  try {
    var ld = window.lobbyData || {};
    if (ld && ld.manual && !ld.started && ld.hostId && ld.hostId === sid) {
      try{ showMain(); window.lobbyJoined=false; if (pseudoInput){ pseudoInput.disabled=false; if(window.myPseudo) pseudoInput.value=window.myPseudo; } try{ updateButtonsDisabled(); }catch(_){}}catch(_){}
    }
  } catch(e){}
});
 } catch(e){}
  try { location.reload(); } catch(e){}
  setTimeout(function(){ try { location.replace(location.href); } catch(e){} }, 60);
});

// === Mouvement: envoi côté serveur avec limitation de fréquence ===
let __lastMoveEmit = 0;
/**
 * @param {{x:number, y:number}} move - vecteur de déplacement normalisé
 */
function emitMoveThrottled(move){
  try{
    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    if (!socket || !socket.connected) return;
    if (now - __lastMoveEmit < 40) return; // ~25/s max
    __lastMoveEmit = now;
    socket.emit('moveDir', { x: move.x||0, y: move.y||0 });
  }catch(e){
    // évite de casser la boucle de jeu si quelque chose cloche
  }
}

// Listen result from turret upgrade and refresh UI/HUD
socket.on('upgradeTurretResult', function(res){
  const msg = document.getElementById('turretUpgradesMsg');
  if (res && res.ok) {
    if (typeof myTurretUp === 'object' && res.type) { myTurretUp[res.type] = res.level || 0; }
    if (typeof res.newMoney === 'number') { myMoney = res.newMoney; }
    if (msg) {
      const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']);
      const types = (tr.turretType || {});
      const typeLabel = types[res.type] || res.type;
      const tpl = tr.turretUpgradeSuccess || 'Upgrade {type} lvl {level} succeeded. Money: ${money}';
      msg.textContent = tpl.replace('{type}', String(typeLabel)).replace('{level}', String(res.level||0)).replace('{money}', String(res.newMoney||0));
      msg.style.color = '#9f9';
    }
    if (typeof window !== 'undefined' && typeof window.refreshShop === 'function') window.refreshShop();
    if (typeof renderShopUpgrades === 'function') renderShopUpgrades();
    if (typeof drawHUD === 'function') drawHUD();
    try { if (typeof window.refreshBuildTooltip === 'function') window.refreshBuildTooltip(); } catch(_){ }

  } else {
    if (msg) {
      const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']);
      msg.textContent = (res && res.reason === 'not_enough_money') ? (tr.notEnoughMoney || "Not enough money.") : (tr.actionImpossible || "Action impossible.");
      msg.style.color = '#f99';
    }
  }
});
let currentRound = 1;
let currentGameId = null;

let playersHealth = {};
let zombies = {};
let bullets = {};
let turretLasers = [];
const turretAngleCache = new Map(); // key: "turret_c_r" -> { ang, t }

// ---- Perf caches (par frame) ----
let FRAME_ID = 0;
let ZOMBIES_FRAME = [];
let ZOMBIES_FRAME_ID = -1;

// portée max (monde) à laquelle une tourelle cherche une cible
const TURRET_TARGET_MAX_DIST = 500;
const TURRET_TARGET_MAX_DIST2 = TURRET_TARGET_MAX_DIST * TURRET_TARGET_MAX_DIST;

// Met à jour la liste plate des zombies une seule fois par frame
function refreshZombiesFrame() {
  if (ZOMBIES_FRAME_ID !== FRAME_ID) {
    // Array “plat” (évite Object.values() X fois)
    ZOMBIES_FRAME = [];
    for (const z of Object.values(zombies)) {
      // on peut ignorer les morts si jamais présents
      if (!z || z.hp <= 0) continue;
      ZOMBIES_FRAME.push(z);
    }
    ZOMBIES_FRAME_ID = FRAME_ID;
  }
}

const TURRET_ANGLE_TTL_MS = 350;    // (était 180) — moins d'oscillation des canons
const TURRET_RECALC_MIN_MS = 120;   // throttle: pas plus d'un recalcul/120 ms par tourelle
const turretAngleNextAt = new Map(); // key: "turret_c_r" -> timestamp autorisé pour prochain calcul
let zombiesRemaining = 0;
let waveTotalZombies = 0;
let waveKilledThisWave = 0;
let structures = null;
let structHPGrid = null;

socket.on('stateUpdate', (payload) => {
  if (!payload) return;

  if (payload.zombies)        zombies = payload.zombies;
  if (payload.bullets)        bullets = payload.bullets;
  if (payload.playersHealth)  playersHealth = Object.assign({}, playersHealth, payload.playersHealth);
  try {
    if (!__centeredOnPlayerOnce && myId && playersHealth && playersHealth[myId] && isNum(playersHealth[myId].x) && isNum(playersHealth[myId].y)) {
      __centeredOnPlayerOnce = true;
      __lastValidMyPos = {x: playersHealth[myId].x, y: playersHealth[myId].y};
      centerCameraOn(playersHealth[myId].x, playersHealth[myId].y);
      try { debugLog('🎯 centered on first valid myPos from stateUpdate'); } catch(_){}
    }
  } catch(_){}

  if (typeof payload.round === 'number') currentRound = payload.round;

  // Apply destroyed structures
  if (Array.isArray(payload.destroyedStructures)) {
    payload.destroyedStructures.forEach(({ tx, ty }) => {
      if (structures?.[ty]) structures[ty][tx] = null;
      if (structHPGrid?.[ty]) structHPGrid[ty][tx] = 0;
    });
  }

  // Update HP overlay grid
  if (payload.structuresHP) {
    structHPGrid = payload.structuresHP;
  }

  // Replace/merge structures grid
  if (payload.structures) {
    const grid = payload.structures;
    const rows = grid.length || 0;
    const cols = rows ? (grid[0]?.length || 0) : 0;

    structures = Array.from({ length: rows }, (_, y) =>
      Array.from({ length: cols }, (_, x) => {
        const cell = grid[y][x];
        if (!cell || cell === 0) return null;

        const hpFromGrid = structHPGrid?.[y]?.[x];
        const previousHP = structures?.[y]?.[x]?.hp;
        function __baseHP(type){ switch(type){ case 'T': return 500; case 't': return 200; case 'G': return 2500; case 'B': case 'D': return 500; default: return 200; } }

        if (typeof cell === 'object') {
          const type = cell.type;
          let hp = (typeof cell.hp === 'number') ? cell.hp : ((typeof hpFromGrid === 'number' && hpFromGrid > 0) ? hpFromGrid : ((typeof previousHP === 'number' && previousHP > 0) ? previousHP : __baseHP(type)));
          if (hp <= 0) return null;
          return { type, hp, placedBy: cell.placedBy };
        }

        if (typeof cell === 'string') {
          const type = cell;
          let hp = (typeof hpFromGrid === 'number' && hpFromGrid > 0) ? hpFromGrid : ((typeof previousHP === 'number' && previousHP > 0) ? previousHP : __baseHP(type));
          if (hp <= 0) return null;
          return { type, hp };
        }

        return null;
      })
    );
  } else if (structHPGrid && structures) {
    // Apply HP overlay to existing structures
    const rows = Math.min(structHPGrid.length, structures.length);
    for (let y = 0; y < rows; y++) {
      const cols = Math.min(structHPGrid[y]?.length || 0, structures[y]?.length || 0);
      for (let x = 0; x < cols; x++) {
        const cell = structures[y][x];
        if (!cell) continue;
        const hp = structHPGrid[y][x];
        if (typeof hp === 'number') {
          if (hp <= 0) structures[y][x] = null; else cell.hp = hp;
        }
      }
    }
  }

  drawHUD();

  // Lightweight FPS meter
  try {
    if (!window.__fps_last) window.__fps_last = performance.now();
    const now = performance.now();
    const dt = now - window.__fps_last;
    window.__fps_last = now;
    if (!window.__fps_s) { window.__fps_s = 0; window.__fps_n = 0; }
    window.__fps_s += dt; window.__fps_n += 1;
    if (window.__fps_s >= 500) {
      const fps = Math.round(1000 / (window.__fps_s / window.__fps_n));
      const el = document.getElementById('fpsCounter'); if (el) el.textContent = 'FPS: ' + fps;
      window.__fps_s = 0; window.__fps_n = 0;
    }
  } catch(e) {}
});

	
	setInterval(() => {
	  if (socket && socket.connected) {
		socket.emit('clientPing');
	  }
	}, 10000); // Toutes les 8 secondes (tu peux mettre 10000 pour 10s)
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

// --- Pinch-to-zoom (mobile) ---
(function(){
  let pinchActive = false;
  let startDist = 0;
  let startPinchScale = 1;

  function touchInRect(t, rect){
    if (!rect) return false;
    const x = t.clientX, y = t.clientY;
    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
  }
  function touchInAnyJoystick(t){
    try{
      const r1 = (moveJoy && moveJoy.joyDiv) ? moveJoy.joyDiv.getBoundingClientRect() : null;
      const r2 = (aimJoy  && aimJoy.joyDiv)  ? aimJoy.joyDiv.getBoundingClientRect()  : null;
      return touchInRect(t, r1) || touchInRect(t, r2);
    }catch(_){ return false; }
  }
  function computeDistance(t0, t1){
    const dx = t0.clientX - t1.clientX;
    const dy = t0.clientY - t1.clientY;
    return Math.hypot(dx, dy);
  }

  function onTouchStart(e){
    if (!isMobileDevice) return;
    if (e.touches && e.touches.length === 2){
      const t0 = e.touches[0], t1 = e.touches[1];
      // Do not start pinch if any finger is on a joystick
      if (touchInAnyJoystick(t0) || touchInAnyJoystick(t1)) return;
      pinchActive = true;
      startDist = computeDistance(t0, t1);
      startPinchScale = pinchScale;
      e.preventDefault();
    }
  }
  function onTouchMove(e){
    if (!pinchActive) return;
    if (!(e.touches && e.touches.length >= 2)) { pinchActive = false; return; }
    const t0 = e.touches[0], t1 = e.touches[1];
    // Cancel pinch if user moves into joystick
    if (touchInAnyJoystick(t0) || touchInAnyJoystick(t1)) { pinchActive = false; return; }
    const d = computeDistance(t0, t1);
    if (d > 0 && startDist > 0){
      const raw = startPinchScale * (d / startDist);
      pinchScale = Math.max(MIN_PINCH, Math.min(MAX_PINCH, raw));
      // Apply new scale and recentre
      updateRenderScale();
      try { updateCamera && updateCamera(); } catch(_){}
      e.preventDefault();
    }
  }
  function onTouchEnd(e){
    if (!pinchActive) return;
    if (!(e.touches && e.touches.length >= 2)) {
      pinchActive = false;
    }
  }

  // Attach on the canvas to avoid global interference
  try{
    canvas.addEventListener('touchstart', onTouchStart, { passive: false });
    canvas.addEventListener('touchmove', onTouchMove, { passive: false });
    canvas.addEventListener('touchend', onTouchEnd, { passive: false });
    canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });
  }catch(_){}
})();


// --- Debug/robust helpers ---
let __centeredOnPlayerOnce = false;
let __lastValidMyPos = {x:0, y:0};
function isNum(v){ return typeof v === 'number' && isFinite(v); }
function centerCameraOn(x, y){
  try{
    const viewW = canvas.width / renderScale;
    const viewH = canvas.height / renderScale;
    cameraX = Math.max(0, Math.min(x - viewW/2, MAP_COLS*TILE_SIZE - viewW));
    cameraY = Math.max(0, Math.min(y - viewH/2, MAP_ROWS*TILE_SIZE - viewH));
  }catch(e){}
}

// Shots direction cache (owner -> recent aim)
// recentShootDir is provided globally earlier

	let mapBuffer = null, mapBufCtx = null, mapBufW = 0, mapBufH = 0;
    const hudAlive = document.getElementById('hudAlive');
    const hudZombies = document.getElementById('hudZombies');
    const hudKills = document.getElementById('hudKills');
    const hudRound = document.getElementById('hudRound');
    const hudHP = document.getElementById('hudHP');
	const hudGold = document.getElementById('hudGold');
	const hudMoney = document.getElementById('hudMoney');
	let myMoney = 0;
	

const UPGRADES = [
  {
    id: "maxHp",
    label: "+10% Vie max",
    desc: "Augmente les PV max.",
    icon: "/icons/heart.svg",
    getValue: (base, level) => {
      const acc = (window.accountShop || {});
      const baseWithShop = base + ((acc.hp|0) * 10);
      return Math.round(baseWithShop * (1 + 0.10 * level));
    },
    baseValue: 100,
    statLabel: "PV max",
    format: v => v + " PV"
  },
  {
    id: "speed",
    label: "+5% Vitesse",
    desc: "Déplace-toi plus vite.",
    icon: "/icons/speed.svg",
    getValue: (base, level) => +(base * (1 + 0.05 * level)).toFixed(1),
    baseValue: 40,
    statLabel: "Vitesse",
    format: v => v + " px/s"
  },
  {
    id: "regen",
    label: "Régénération PV",
    desc: "Regénère tes PV.",
    icon: "/icons/regen.svg",
    getValue: (base, level) => {
      if (level <= 10) return level;                 // 0..10 linéaire
      return +(10 * Math.pow(1.1, level - 10)).toFixed(2); // >10 : +10%/niv
    },
    baseValue: 0,
    statLabel: "Régén.",
    format: v => v + " PV/s"
  },
  {
    id: "damage",
    label: "+10% Dégâts",
    desc: "Tire plus fort.",
    icon: "/icons/bullet.svg",
    getValue: (base, level) => {
      const acc = (window.accountShop || {});
      const baseWithShop = base + ((acc.dmg|0) * 1);
      return Math.round(baseWithShop * (1 + 0.10 * level));
    },
    baseValue: 10,
    statLabel: "Dégâts",
    format: v => v
  },
  {
    id: "goldGain",
    label: "+10% d'argent gagné",
    desc: "Gagne plus d’or sur les zombies.",
    icon: "/icons/gold.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 10, // goldGain commence à 10 côté serveur
    statLabel: "$/zombie",
    format: (v) => {
      const min = Math.round(10 * (v / 10));
      const max = Math.round(20 * (v / 10));
      return `$${min}–${max}`;
    }
  }
];

// Ensure account-level shop bonuses are available client-side
window.accountShop = window.accountShop || { hp: 0, dmg: 0 };

	// Niveau des upgrades du joueur local (simulé pour l’instant)
	let myUpgrades = {
	  maxHp: 0,
	  speed: 0,
	  regen: 0,
	  damage: 0,
	  goldGain: 0
	};

const waveMessage = document.getElementById('waveMessage');

function resetWaveCounters(total = 0) {
  waveTotalZombies   = Number(total) || 0;
  waveKilledThisWave = 0;
  zombiesRemaining   = waveTotalZombies; // au départ, il reste tout le monde
  drawHUD();
}

    let myId = null, playerHealth = 100, isDead = false, myKills = 0, myPseudo = "";
  let isSpectator = false;
  let spectatorPos = { x: 0, y: 0 };
	let shootBlocked = false;
	let moneyFloatingTexts = []; // Pour stocker les "+$" à afficher
	let buildMode = null;         // 'T' | 't' | 'B' | 'D' | null
	let buildHover = { tx: -1, ty: -1 }; // tuile survolée pendant le placement

	function curve(v) {
	  // 0.55 = plus sensible au centre (augmente si tu trouves encore trop mou)
	  const e = 0.55;
	  const s = Math.sign(v);
	  return s * Math.pow(Math.abs(v), e);
	}

    // Détection mobile
    function isMobile() { return /android|iphone|ipad|ipod|opera mini|iemobile|mobile/i.test(navigator.userAgent); }
    const isMobileDevice = isMobile();
	const HAS_POINTER = ('PointerEvent' in window);

	// === [ZOOM MOBILE PAYSAGE] ===
	let renderScale = 1;
// === Helper: convert client (CSS) coordinates to world coordinates ===
function clientToWorld(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  // CSS pixels -> canvas pixels
  const cssX = clientX - rect.left;
  const cssY = clientY - rect.top;
  const ratioX = (canvas.width  / (rect.width  || 1)) || 1;
  const ratioY = (canvas.height / (rect.height || 1)) || 1;
  const px = cssX * ratioX;
  const py = cssY * ratioY;
  // canvas pixels -> world (remove renderScale, add camera offset)
  return { x: cameraX + (px / (renderScale || 1)), y: cameraY + (py / (renderScale || 1)) };
}

// --- Mobile zoom management ---
let baseRenderScale = 1;   // auto-computed scale so halo touches screen edges
let pinchScale = 1;        // user pinch multiplier
const MIN_PINCH = 0.6;
const MAX_PINCH = 1.8;

	function updateRenderScale() {
  try {
    // Compute the 'base' scale that fits the visibility halo to screen edges
    if (!isMobileDevice) {
      baseRenderScale = 1;
      renderScale = baseRenderScale * pinchScale;
      return;
    }
    const VR = (typeof CLIENT_VIEW_RADIUS === 'number' && CLIENT_VIEW_RADIUS > 0) ? CLIENT_VIEW_RADIUS : 420;
    const cw = (canvas && canvas.width) || window.innerWidth || 0;
    const ch = (canvas && canvas.height) || window.innerHeight || 0;
    const minDim = Math.min(cw, ch);
    if (minDim > 0 && VR > 0) {
      baseRenderScale = minDim / (2 * VR);
    } else {
      baseRenderScale = 1;
    }
    renderScale = baseRenderScale * pinchScale;
  } catch(e) {
    try { console.warn('[updateRenderScale] error', e && (e.message||e)); } catch(_){}
  }
}

// Keep mobile zoom correct when the screen size/orientation changes
try {
  window.addEventListener('resize', function(){
    try { updateRenderScale(); updateCamera && updateCamera(); } catch(_){}
  }, { passive: true });
  window.addEventListener('orientationchange', function(){
    try { setTimeout(function(){ updateRenderScale(); updateCamera && updateCamera(); }, 0); } catch(_){}
  }, { passive: true });
} catch(_){}

updateRenderScale();
    const TILE_SIZE = 40;
    const PLAYER_RADIUS = 10;
    const ZOMBIE_RADIUS = 10;
	const CLIENT_VIEW_RADIUS = 420;
    let map = [], MAP_ROWS = 0, MAP_COLS = 0;

// === Helpers map/structures (client) ===
function worldToTile(x, y) {
  return { tx: Math.floor(x / TILE_SIZE), ty: Math.floor(y / TILE_SIZE) };
}
function isWallAt(tx, ty) {
  if (!map || ty < 0 || ty >= MAP_ROWS || tx < 0 || tx >= MAP_COLS) return true;
  return map[ty][tx] === 1;
}

function losBlockedForPlayer(x0, y0, x1, y1) {
  const dx = x1 - x0, dy = y1 - y0;
  const dist = Math.hypot(dx, dy);
  if (dist < 1) return false;
  const steps = Math.ceil(dist / 8);
  for (let s = 1; s < steps; s++) {
    const ix = x0 + (dx * s / steps);
    const iy = y0 + (dy * s / steps);
    const { tx, ty } = worldToTile(ix, iy);
    if (isWallAt(tx, ty)) return true;
  }
  return false;
}
function structAtWorld(x, y) {
  if (!structures) return null;
  const { tx, ty } = worldToTile(x, y);
  if (ty < 0 || ty >= MAP_ROWS || tx < 0 || tx >= MAP_COLS) return null;
  return structures[ty]?.[tx] || null;
}
function isSolidForZombieClient(struct) {
  // pour la ligne de vue côté client : tout ce qui a des PV bloque
  return struct && struct.hp > 0; // B, D, T...
}
function losBlockedForZombieClient(x0, y0, x1, y1) {
  // Échantillonnage plus grossier (≈ 1 pas par tuile) : bien plus léger en rafale
  const dx = x1 - x0, dy = y1 - y0;
  const dist = Math.hypot(dx, dy);
  if (dist < 1) return false;

  // Un pas ≈ taille de tuile (évite ~5–8x plus d'itérations qu'avant)
  const STEP = TILE_SIZE; // 40px chez toi
  const steps = Math.max(1, Math.ceil(dist / STEP));

  for (let s = 1; s < steps; s++) {
    const ix = x0 + (dx * s / steps);
    const iy = y0 + (dy * s / steps);
    const { tx, ty } = worldToTile(ix, iy);

    if (isWallAt(tx, ty)) return true;

    const st = structures?.[ty]?.[tx];
    if (st && st.hp > 0) return true; // toute structure avec PV bloque
  }
  return false;
}

function findTurretTargetAngle(turretKey, cxWorld, cyWorld) {
  const now = performance.now();

  // 1  Si on a un angle récent, on le réutilise (cache TTL)
  const cached = turretAngleCache.get(turretKey);
  if (cached && (now - cached.t) <= TURRET_ANGLE_TTL_MS) {
    return cached.ang;
  }

  // 2  Throttle: on n'autorise un recalcul complet qu'à partir d'un certain moment
  const nextAt = turretAngleNextAt.get(turretKey) || 0;
  if (now < nextAt && cached) {
    // encore trop tôt → on garde l'angle précédent
    return cached.ang;
  }

  // 3  Cherche la cible la plus proche dans la portée, LOS avec pas par tuile
  let bestDist2 = Infinity;
  let bdx = 1, bdy = 0;

  // ZOMBIES_FRAME est rafraîchi une fois par frame (cf. étape 4 plus bas)
  for (let i = 0; i < ZOMBIES_FRAME.length; i++) {
    const z = ZOMBIES_FRAME[i];
    const dx = z.x - cxWorld;
    const dy = z.y - cyWorld;
    const d2 = dx*dx + dy*dy;

    if (d2 > TURRET_TARGET_MAX_DIST2) continue;

    if (d2 < bestDist2) {
      if (!losBlockedForZombieClient(cxWorld, cyWorld, z.x, z.y)) {
        bestDist2 = d2;
        bdx = dx; bdy = dy;
      }
    }
  }

  const ang = Math.atan2(bdy, bdx);

  // 4  Mémos
  turretAngleCache.set(turretKey, { ang, t: now });
  turretAngleNextAt.set(turretKey, now + TURRET_RECALC_MIN_MS);

  return ang;
}

    let cameraX = 0, cameraY = 0;
    const keys = {};
    let mouseDown = false, mousePos = { x: 0, y: 0 };
    let aimDir = { x: 1, y: 0 }; // direction de visée par défaut (droite)
	let lastAimDir = { x: 1, y: 0 };
	
	
// Navigation keys map (WASD + arrows)
const __NAV_KEYS = { w:1, a:1, s:1, d:1, arrowup:1, arrowdown:1, arrowleft:1, arrowright:1 };

// Helper: are we typing in an input/textarea/contenteditable? (e.g., chat)
function __isTyping(){
  try{
    if (window.__typingInChat) return true;
    var el = document.activeElement;
    if (!el) return false;
    try{
      if (el instanceof HTMLElement) {
        var cs = window.getComputedStyle(el);
        if (cs && (cs.visibility === 'hidden' || cs.display === 'none')) return false;
      }
    }catch(_){}
    var tn = (el.tagName||'').toUpperCase();
    if (tn === 'INPUT' || tn === 'TEXTAREA') {
      if (el.readOnly || el.disabled) return false;
      return true;
    }
    if (el.isContentEditable) return true;
  }catch(_){}
  return false;
}

// Map physical keys to logical WASD irrespective of layout (QWERTY/AZERTY)
function __canonNavKey(e){
  try{
    var code = String(e && e.code || '');
    if (code === 'KeyW') return 'w';
    if (code === 'KeyA') return 'a';
    if (code === 'KeyS') return 's';
    if (code === 'KeyD') return 'd';
  }catch(_){}
  var k = String(e && (e.key||'')).toLowerCase();
  if (k === 'w' || k === 'a' || k === 's' || k === 'd') return k;
  if (k === 'arrowup' || k === 'arrowdown' || k === 'arrowleft' || k === 'arrowright') return k;
  return null;
}

window.addEventListener('keydown', function(e){
  var k = String(e && (e.key||'')).toLowerCase();
  var canon = __canonNavKey(e);
  if (canon && __NAV_KEYS[canon]){
    // If typing in a field (chat/login/etc.), DO NOT block native input.
    if (__isTyping()) return;
    try{ e.preventDefault(); }catch(_){ }
    keys[canon] = true;
    return;
  }
  keys[k] = true;
});

window.addEventListener('keyup', function(e){
  var k = String(e && (e.key||'')).toLowerCase();
  var canon = __canonNavKey(e);
  if (canon && __NAV_KEYS[canon]){
    // If typing, let the field manage the caret/selection, don't block.
    if (__isTyping()) { keys[canon] = false; return; }
    try{ e.preventDefault(); }catch(_){ }
    keys[canon] = false;
    return;
  }
  keys[k] = false;
});

window.addEventListener('mousedown', e => {
  // Prevent firing when interacting with UI panels/buttons,
  // BUT allow native focus/clicks for form controls so typing works.
  try {
    var t = e.target;
    var inUI = !!(t && t.closest && t.closest('#inGameMenu, #chatPanel, #chatCollapsedBtn, #igBuildPanel, #hudStats, #shopModal, #shopBtn, #buildBar, #buildTiles, .mobile-build, #authModal, #lobbyScreen'));
    if (inUI) {
      // If the click is on a real form control, don't preventDefault to keep focus & typing.
      var ctrl = t && (t.closest('input, textarea, select, button, label, [contenteditable=""], [contenteditable="true"], [contenteditable="plaintext-only"]'));
      if (ctrl) {
        try { if (e.stopPropagation) e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation(); } catch(_){}
        mouseDown = false;
        return;
      }
      // Otherwise block the game action while letting the UI consume the click
      try { e.preventDefault(); if (e.stopPropagation) e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation(); } catch(_){}
      mouseDown = false;
      return;
    }
  } catch(_){}
  if (buildMode) { try{ e.preventDefault(); }catch(_){ } return; }
  var sm = document.getElementById('shopModal');
  if (sm && sm.style.display === 'block') return;
  mouseDown = (e.button === 0);});window.addEventListener('mouseup', e => { if (e.button === 0) mouseDown = false; });
    window.addEventListener('mousemove', e => {
      mousePos = { x: e.clientX, y: e.clientY };
      if (!isMobileDevice && myId && playersHealth[myId]) {
        const player = playersHealth[myId];
        const w = clientToWorld(e.clientX, e.clientY);
        aimDir = { x: w.x - player.x, y: w.y - player.y };
        const len = Math.hypot(aimDir.x, aimDir.y) || 1;
        aimDir.x /= len; aimDir.y /= len;
      }
    });
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

function createMapBuffer() {
  if (!map || !map.length) return;

  mapBufW = MAP_COLS * TILE_SIZE;
  mapBufH = MAP_ROWS * TILE_SIZE;

  // (Re)crée le canvas offscreen
  mapBuffer = document.createElement('canvas');
  mapBuffer.width  = mapBufW;
  mapBuffer.height = mapBufH;
  mapBufCtx = mapBuffer.getContext('2d');

  // Pour un rendu pixel-art net si les assets sont pixelisés
  try { mapBufCtx.imageSmoothingEnabled = false; } catch(_){}

  // === SPRITES sol/mur (chargés une seule fois, global) ===
  if (!window.__TILE_SPRITES__) {
    const stones = [];
    const grass  = [];
    for (let i = 1; i <= 5; i++) { const im = new Image(); im.src = '/sprites/stone_' + i + '.png'; stones.push(im); }
    for (let i = 1; i <= 5; i++) { const im = new Image(); im.src = '/sprites/grass_' + i + '.png'; grass.push(im); }
    window.__TILE_SPRITES__ = { stones, grass, ready: false };
    // Quand tout est chargé, on re-dessine le buffer pour poser les textures
    const all = stones.concat(grass);
    let remain = all.length;
    const done = () => { if (--remain <= 0) { window.__TILE_SPRITES__.ready = true; try { createMapBuffer(); } catch(_) {} } };
    for (const im of all) { im.onload = done; im.onerror = done; }
  }

  // Index pseudo-aléatoire mais déterministe par tuile (évite un "clignotement")
  function vIndex(r, c, n) {
    const n1 = (r + 1) * 73856093;
    const n2 = (c + 1) * 19349663;
    const h  = (n1 ^ n2) >>> 0;
    return (h % n) | 0;
  }

  const spr = window.__TILE_SPRITES__;
  const stones = spr && spr.stones || [];
  const grass  = spr && spr.grass  || [];
  const ready  = spr && spr.ready;

  // --- D'abord le SOL partout (herbe 1..5) ---
  for (let r = 0; r < MAP_ROWS; r++) {
    for (let c = 0; c < MAP_COLS; c++) {
      const x = c * TILE_SIZE, y = r * TILE_SIZE;
      if (ready && grass.length) {
        const gi = vIndex(r, c, grass.length);
        const g  = grass[gi];
        if (g && g.complete && g.naturalWidth > 0) {
          mapBufCtx.drawImage(g, x, y, TILE_SIZE, TILE_SIZE);
          continue;
        }
      }
      // fallback couleur si sprites pas prêts
      mapBufCtx.fillStyle = '#2e5a2e';
      mapBufCtx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    }
  }

  // --- Puis les MURS non destructibles (pierre 1..5) ---
  for (let r = 0; r < MAP_ROWS; r++) {
    for (let c = 0; c < MAP_COLS; c++) {
      if (map[r][c] === 1) {
        const x = c * TILE_SIZE, y = r * TILE_SIZE;
        if (ready && stones.length) {
          const si = vIndex(r, c, stones.length);
          const s  = stones[si];
          if (s && s.complete && s.naturalWidth > 0) {
            mapBufCtx.drawImage(s, x, y, TILE_SIZE, TILE_SIZE);
            continue;
          }
        }
        // fallback couleur si sprites pas prêts
        mapBufCtx.fillStyle = '#5a5a5a';
        mapBufCtx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
      }
    }
  }
}

// JOYSTICK PATCH MOBILE
    let moveJoy = null, aimJoy = null;
	let moveJoyVal = {x:0, y:0}, aimJoyVal = {x:0, y:0}; // valeurs normalisées [-1..1]
	
function createJoystick(container, baseX, baseY, id) {
  const size = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.23);
  const joyDiv = document.createElement('div');
  joyDiv.className = 'joystick-container';
  joyDiv.style.left = baseX + 'px';
  joyDiv.style.top = baseY + 'px';
  joyDiv.style.width = size + 'px';
  joyDiv.style.height = size + 'px';
  joyDiv.id = id;
  joyDiv.style.pointerEvents = 'auto';
  document.body.appendChild(joyDiv);

  const base = document.createElement('div');
  base.className = 'joystick-base';
  base.style.width = size + 'px';
  base.style.height = size + 'px';
  base.style.background = 'rgba(255,255,255,0.12)';
  base.style.borderRadius = '50%';
  base.style.position = 'absolute';
  base.style.left = '0px';
  base.style.top = '0px';
  base.style.pointerEvents = 'auto';
  joyDiv.appendChild(base);

  const stick = document.createElement('div');
  stick.className = 'joystick-stick';
  stick.style.width = (size * 0.52) + 'px';
  stick.style.height = (size * 0.52) + 'px';
  stick.style.background = 'rgba(160,255,240,0.45)';
  stick.style.borderRadius = '50%';
  stick.style.position = 'absolute';
  stick.style.left = (size * 0.24) + 'px';
  stick.style.top = (size * 0.24) + 'px';
  stick.style.pointerEvents = 'auto';
  joyDiv.appendChild(stick);

  return { joyDiv, base, stick, size };
}

function addJoystickHandlers(joy, which) {
  const size = joy.size;
  const radius = size / 2;
  const stickRadius = (size * 0.52) / 2;
  const center = { x: radius, y: radius };

  let activeId = null;

  function setVec(dx, dy) {
    const max = radius - stickRadius;
    const len = Math.hypot(dx, dy);

    // clamp visuel
    let nx = dx, ny = dy;
    if (len > max && len > 0) {
      nx = dx * (max / len);
      ny = dy * (max / len);
    }

    // position visuelle
    joy.stick.style.left = (center.x - stickRadius + nx) + "px";
    joy.stick.style.top  = (center.y - stickRadius + ny) + "px";

    // vecteur normalisé [-1..1]
    const out = (max > 0) ? { x: nx / max, y: ny / max } : { x: 0, y: 0 };
    if (which === "move") moveJoyVal = out;
    else aimJoyVal = out;
  }

  function reset() {
    activeId = null;
    setVec(0, 0);
  }

  function localCoords(clientX, clientY) {
    const r = joy.joyDiv.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }

  function onDown(e) {
    if (activeId !== null) return;
    activeId = e.pointerId;
    joy.joyDiv.setPointerCapture(activeId);
    const p = localCoords(e.clientX, e.clientY);
    setVec(p.x - center.x, p.y - center.y);
    e.preventDefault();
  }

  function onMove(e) {
    if (e.pointerId !== activeId) return;
    const p = localCoords(e.clientX, e.clientY);
    setVec(p.x - center.x, p.y - center.y);
    e.preventDefault();
  }

  function onUp(e) {
    if (e.pointerId !== activeId) return;
    try { joy.joyDiv.releasePointerCapture(activeId); } catch {}
    reset();
    e.preventDefault();
  }

  // down sur toute la zone
  joy.joyDiv.addEventListener('pointerdown', onDown, { passive: false });
  joy.base.addEventListener('pointerdown', onDown, { passive: false });
  joy.stick.addEventListener('pointerdown', onDown, { passive: false });

  // move/up globaux
  window.addEventListener('pointermove', onMove, { passive: false });
  window.addEventListener('pointerup', onUp, { passive: false });
  window.addEventListener('pointercancel', onUp, { passive: false });

  reset();
}

	function addJoystickTouchHandlers(joy, which) {
	  const size = joy.size;
	  const radius = size / 2;
	  const stickRadius = (size * 0.52) / 2;
	  const center = { x: radius, y: radius };

	  let active = false;
	  let lastId = null;

	  function setVec(dx, dy) {
		const max = radius - stickRadius;
		const len = Math.hypot(dx, dy);
		let nx = dx, ny = dy;
		if (len > max && len > 0) {
		  nx = dx * (max / len);
		  ny = dy * (max / len);
		}
		joy.stick.style.left = (center.x - stickRadius + nx) + "px";
		joy.stick.style.top  = (center.y - stickRadius + ny) + "px";
		const out = (max > 0) ? { x: nx / max, y: ny / max } : { x: 0, y: 0 };
		if (which === "move") moveJoyVal = out;
		else aimJoyVal = out;
	  }

	  function reset() {
		active = false;
		lastId = null;
		setVec(0, 0);
	  }

	  function localCoords(clientX, clientY) {
		const r = joy.joyDiv.getBoundingClientRect();
		return { x: clientX - r.left, y: clientY - r.top };
	  }

	  function onStart(e) {
		if (active) return;
		const t = e.changedTouches ? e.changedTouches[0] : null;
		if (!t) return;
		active = true;
		lastId = t.identifier;
		const p = localCoords(t.clientX, t.clientY);
		setVec(p.x - center.x, p.y - center.y);
		e.preventDefault();
	  }

	  function onMove(e) {
		if (!active) return;
		const touches = e.changedTouches;
		for (let i = 0; i < touches.length; i++) {
		  const t = touches[i];
		  if (t.identifier !== lastId) continue;
		  const p = localCoords(t.clientX, t.clientY);
		  setVec(p.x - center.x, p.y - center.y);
		  e.preventDefault();
		  break;
		}
	  }

	  function onEnd(e) {
		if (!active) return;
		const touches = e.changedTouches;
		for (let i = 0; i < touches.length; i++) {
		  const t = touches[i];
		  if (t.identifier !== lastId) continue;
		  reset();
		  e.preventDefault();
		  break;
		}
	  }

	  // down sur toute la zone
	  joy.joyDiv.addEventListener('touchstart', onStart, { passive: false });
	  joy.base.addEventListener('touchstart', onStart, { passive: false });
	  joy.stick.addEventListener('touchstart', onStart, { passive: false });

	  // move/up globaux
	  window.addEventListener('touchmove', onMove, { passive: false });
	  window.addEventListener('touchend', onEnd, { passive: false });
	  window.addEventListener('touchcancel', onEnd, { passive: false });

	  reset();
	}

function setupJoysticks() {
  if (!isMobileDevice) return;

  // Nettoyage
  if (moveJoy && moveJoy.joyDiv) moveJoy.joyDiv.remove();
  if (aimJoy && aimJoy.joyDiv) aimJoy.joyDiv.remove();

  const padding = 36;
  const joySize = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.23);
  let joyY = window.innerHeight - joySize - padding;
  if (joyY < padding) joyY = padding;

  // Crée les deux joysticks
  moveJoy = createJoystick(document.body, padding, joyY, "moveJoy");
  aimJoy  = createJoystick(document.body, window.innerWidth - joySize - padding, joyY, "aimJoy");

  // 👉 branchement selon le support
  if (HAS_POINTER) {
    addJoystickHandlers(moveJoy, "move");
    addJoystickHandlers(aimJoy,  "aim");
  } else {
    addJoystickTouchHandlers(moveJoy, "move");
    addJoystickTouchHandlers(aimJoy,  "aim");
  }

  // Repositionne l’UI shop
  positionShopUI();
}

// ===== remplace entièrement cette fonction =====
function positionShopUI() {
  if (!isMobileDevice) return;
  const shopBtnEl   = document.getElementById('shopBtn');
  const shopModalEl = document.getElementById('shopModal');
  const buildBarEl  = document.getElementById('buildBar');
  if (!aimJoy || !aimJoy.joyDiv || !shopBtnEl) return;

  const isPortrait = window.matchMedia("(orientation: portrait)").matches;
  const joyRect = aimJoy.joyDiv.getBoundingClientRect();

  // --- Bouton SHOP au-dessus du joystick droit ---
  const btnGap = 20; // espace entre bouton et joystick
  shopBtnEl.style.position = "fixed";
  shopBtnEl.style.zIndex   = "10005";
  shopBtnEl.style.right    = (window.innerWidth - joyRect.right) + "px";
  shopBtnEl.style.bottom   = (window.innerHeight - joyRect.top) + btnGap + "px";

  // --- Panneau SHOP : aligné à droite du joystick, et assez haut pour ne pas chevaucher ---
  if (shopModalEl) {
    const gap = isPortrait ? 28 : 12;
    const availableHeightAboveJoystick = Math.max(0, joyRect.top - gap);
    const margin = 10;

    const maxH = Math.max(180, Math.min(availableHeightAboveJoystick - margin, window.innerHeight - 2*margin));
    shopModalEl.style.maxHeight = maxH + "px";
    shopModalEl.style.overflowY = "auto";

    if (!isPortrait) {
      shopModalEl.style.minWidth = "300px";
      shopModalEl.style.maxWidth = Math.min(360, window.innerWidth - 20) + "px";
    }

    // ancrage horizontal à droite du joystick
    shopModalEl.style.right = (window.innerWidth - joyRect.right + 14) + "px";

    // recalage vertical au-dessus du joystick
    let computedBottom = (window.innerHeight - joyRect.top) + gap;
    const minBottom = 8;
    const maxBottom = window.innerHeight - 120;
    if (computedBottom < minBottom) computedBottom = minBottom;
    if (computedBottom > maxBottom) computedBottom = maxBottom;
    shopModalEl.style.bottom = computedBottom + "px";
  }

  // --- ❶ NOUVEAU : positionner la barre de construction juste au-dessus du bouton SHOP ---
  if (buildBarEl) {
    // aligne horizontalement avec le bouton SHOP
    buildBarEl.style.position = "fixed";
    buildBarEl.style.right = shopBtnEl.style.right;

    // place la barre juste au-dessus du bouton SHOP (écart 12px)
    const btnBottomPx = parseFloat(shopBtnEl.style.bottom) || 0;
    const btnHeight   = shopBtnEl.offsetHeight || 56; // fallback si non rendu
    const gapAboveBtn = 12;
    buildBarEl.style.bottom = (btnBottomPx + btnHeight + gapAboveBtn) + "px";

    // priorité d’affichage au-dessus du SHOP
    buildBarEl.style.zIndex = "10006";
  }
}

function drawMap() {
  if (!map || !map.length) return;
  // Génère le buffer si nécessaire (ou si tailles non prêtes)
  if (!mapBuffer || mapBufW !== MAP_COLS * TILE_SIZE || mapBufH !== MAP_ROWS * TILE_SIZE) {
    createMapBuffer();
  }
  if (!mapBuffer) return;

  // Calcule la portion visible (en coordonnées monde)
  const viewW = Math.ceil(canvas.width  / renderScale);
  const viewH = Math.ceil(canvas.height / renderScale);
  const sx = Math.floor(cameraX);
  const sy = Math.floor(cameraY);
  const sW = Math.min(viewW, mapBufW - sx);
  const sH = Math.min(viewH, mapBufH - sy);
  if (sW <= 0 || sH <= 0) return;

  // Dessine le morceau nécessaire du buffer à la bonne position
  ctx.drawImage(
    mapBuffer,
    sx, sy, sW, sH,              // source rect (dans le buffer)
    sx - cameraX, sy - cameraY,  // destination (coord. monde → après setTransform)
    sW, sH
  );
}

function drawStructures() {
  if (!structures) return;

  // Parcours des structures
  for (let row = 0; row < structures.length; row++) {
    for (let col = 0; col < structures[row].length; col++) {
      const cell = structures[row][col];
      if (!cell) continue; // Si pas de structure, on passe à la suivante

      const x = col * TILE_SIZE - cameraX; // Calcul de la position en X
      const y = row * TILE_SIZE - cameraY; // Calcul de la position en Y

      // Dessiner la structure de base
      if (cell.type === 'B') {
        ctx.fillStyle = '#7b4b2a'; // Couleur du mur
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
      } else if (cell.type === 'D') {
        ctx.fillStyle = '#a57b4a'; // Couleur de la porte
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
      } else if (cell.type === 'T' || cell.type === 't') {
        const isBig = (cell.type === 'T');
        ctx.fillStyle = isBig ? '#d33' : '#3aa6ff'; // Couleur des tourelles
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = isBig ? '#3a0b0b' : '#0b1b2a';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
        
        // Dessiner le carré noir au centre de la tourelle
        const centerX = x + TILE_SIZE / 2;
        const centerY = y + TILE_SIZE / 2;
        ctx.fillStyle = '#000'; // Noir
        ctx.fillRect(centerX - 8, centerY - 8, 16, 16); // Dessiner un carré de 16px au centre
      }
      else if (cell.type === 'G') {
        ctx.fillStyle = '#b48cff';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#2b1b3a';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
        const centerX = x + TILE_SIZE / 2;
        const centerY = y + TILE_SIZE / 2;
        ctx.fillStyle = '#000';
        ctx.fillRect(centerX - 8, centerY - 8, 16, 16);
      }

    
      // --- Health bar for structures (walls/doors/turrets) ---
      let hp = 0, maxHp = 0;
      // Prefer object hp if >0, else grid hp >0, else previousHP >0, else default by type
      let rowArr = (typeof structHPGrid !== 'undefined' && Array.isArray(structHPGrid) && Array.isArray(structHPGrid[row])) ? structHPGrid[row] : null;
let hpFromGrid = (rowArr && typeof rowArr[col] === 'number') ? rowArr[col] : undefined;
let prevRowArr = (typeof structPrevHPGrid !== 'undefined' && Array.isArray(structPrevHPGrid) && Array.isArray(structPrevHPGrid[row])) ? structPrevHPGrid[row] : null;
let previousHP = (prevRowArr && typeof prevRowArr[col] === 'number') ? prevRowArr[col] : undefined;
      const defaultByType = (cell && cell.type)
        ? ((cell.type === 'B' || cell.type === 'D') ? 500 : (cell.type === 'T' ? 500 : (cell.type === 't' ? 200 : (cell.type === 'G' ? 2500 : 200))))
        : 0;
      if (cell && typeof cell.hp === 'number' && cell.hp > 0) hp = cell.hp;
      else if (typeof hpFromGrid === 'number' && hpFromGrid > 0) hp = hpFromGrid;
      else if (typeof previousHP === 'number' && previousHP > 0) hp = previousHP;
      else hp = defaultByType;
      // If no explicit cell.hp and no previous positive HP and grid HP < default, assume brand new => full default
      if (!(cell && typeof cell.hp === 'number' && cell.hp > 0) &&
          !(typeof previousHP === 'number' && previousHP > 0) &&
          (typeof hpFromGrid !== 'number' || hpFromGrid < defaultByType)) {
        hp = defaultByType;
      }
      maxHp = (cell && cell.type)
        ? ((cell.type === 'B' || cell.type === 'D') ? 500 : (cell.type === 'T' ? 500 : (cell.type === 't' ? 200 : (cell.type === 'G' ? 2500 : 0))))
        : 0;
      // Clamp: if hp non-positive (first frame after placement), show full bar
      if (hp <= 0 && maxHp > 0) hp = maxHp;
      if (maxHp > 0) {
        const ratio = Math.max(0, Math.min(1, hp / maxHp));
        const bw = TILE_SIZE - 8, bh = 5;
        const __allowOverflow = Math.round(0.18 * TILE_SIZE);
        const __extraLift = 6 + Math.max(2, Math.round(0.03 * TILE_SIZE));
        const yBar = (cell && (cell.type === 'T' || cell.type === 't' || cell.type === 'G')) ? (y - __allowOverflow - __extraLift) : (y - 8);

        ctx.fillStyle = '#000a';
        ctx.fillRect(x + 4, yBar, bw, bh);
        ctx.fillStyle = ratio > 0.6 ? '#3f3' : (ratio > 0.3 ? '#fc3' : '#f33');
        ctx.fillRect(x + 4, yBar, bw * ratio, bh);
      }
}
  }
}

	
function drawPlayers() {
  const me = (myId && playersHealth[myId]) ? playersHealth[myId] : null;
  const vx = me ? me.x : 0;
  const vy = me ? me.y : 0;
  const VIEW_MARGIN = 8;
  const R2 = (CLIENT_VIEW_RADIUS - VIEW_MARGIN) * (CLIENT_VIEW_RADIUS - VIEW_MARGIN);

  for (const id in playersHealth) {
    const p = playersHealth[id];
    if (!p || !p.alive) continue;

    // Culling autour du joueur local
    if (!isSpectator && id !== myId) {
      const dxv = p.x - vx, dyv = p.y - vy;
      if (dxv*dxv + dyv*dyv > R2) continue;
    }

    const screenX = p.x - cameraX;
    const screenY = p.y - cameraY;

    // --- Angle de visée prioritaire si le joueur vient de tirer
    let angle = 0;
    const nowPerf = (typeof performance!=='undefined' && performance.now)?performance.now():Date.now();
    /* keep facing while holding fire */
    if (myId && playersHealth[myId] && mouseDown) {
      const angHold = Math.atan2(aimDir.y, aimDir.x);
      recentShootDir.set(myId, { ang: angHold, t: nowPerf });
    }

    const recent = recentShootDir.get(id);
    if (recent && (nowPerf - recent.t) < (window.SHOOT_DIR_TTL_MS || SHOOT_DIR_TTL_MS)) {
      angle = recent.ang;
    } else {
      // Sinon, angle de déplacement (avec mémoire si à l'arrêt)
      const prev = prevPlayerPos[id];
      if (prev) {
        const dx = p.x - prev.x, dy = p.y - prev.y;
        const sp2 = dx*dx + dy*dy;
        if (sp2 > 0.01) {
          angle = Math.atan2(dy, dx);
          lastPlayerAngle[id] = angle;
        } else {
          angle = (lastPlayerAngle[id] !== undefined) ? lastPlayerAngle[id] : 0;
        }
      } else {
        angle = (lastPlayerAngle[id] !== undefined) ? lastPlayerAngle[id] : 0;
      }
    }
    prevPlayerPos[id] = { x: p.x, y: p.y };

    // Dessin sprite joueur
    const size = PLAYER_RADIUS * 2 * 2; // un peu plus grand que le cercle
    const half = size / 2;
    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.rotate(angle + (window.SPRITE_BASE_ROT||0));
    var __img = (typeof getPlayerSpriteFor==='function') ? getPlayerSpriteFor(p && p.pseudo, p && p.skin) : playerImg;
    ctx.drawImage(__img || playerImg, -half, -half, size, size);
    ctx.restore();

    // Pseudo + barre de vie (inchangé)
    ctx.font = "bold 17px Arial";
    ctx.textAlign = "center";
    ctx.fillStyle = "#aad8ff";
    ctx.fillText(p.pseudo || "Joueur", screenX, screenY - PLAYER_RADIUS - 22);
    drawHealthBar(
      screenX,
      screenY - PLAYER_RADIUS - 13,
      p.health,
      p.maxHealth || 100,
      30
    );
  }
}
	
	

function drawZombies() {
  if (!myId || !playersHealth[myId]) return;
  const me = playersHealth[myId];
  const vx = me.x, vy = me.y;

  const VIEW_MARGIN = 8;
  const R2 = (CLIENT_VIEW_RADIUS - VIEW_MARGIN) * (CLIENT_VIEW_RADIUS - VIEW_MARGIN);

  for (const id in zombies) {
    const z = zombies[id];
    if (!z || z.hp <= 0) continue;

    const dxv = z.x - vx, dyv = z.y - vy;
    if (!isSpectator && (dxv*dxv + dyv*dyv) > R2) continue;

    const screenX = z.x - cameraX;
    const screenY = z.y - cameraY;

    // Angle basé sur déplacement avec mémoire
    let angle = 0;
    const prev = prevZombiePos[id];
    if (prev) {
      const dx = z.x - prev.x, dy = z.y - prev.y;
      const sp2 = dx*dx + dy*dy;
      if (sp2 > 0.01) {
        angle = Math.atan2(dy, dx);
        lastZombieAngle[id] = angle;
      } else {
        angle = (lastZombieAngle[id] !== undefined) ? lastZombieAngle[id] : 0;
      }
    } else {
      angle = (lastZombieAngle[id] !== undefined) ? lastZombieAngle[id] : 0;
    }
    prevZombiePos[id] = { x: z.x, y: z.y };

    const size = ZOMBIE_RADIUS * 2 * 2;
    const half = size / 2;
    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.rotate(angle + (window.SPRITE_BASE_ROT||0));
    ctx.drawImage(zombieImg, -half, -half, size, size);
    ctx.restore();

    // Barre de vie
    drawHealthBar(screenX, screenY - ZOMBIE_RADIUS - 10, z.hp, z.maxHp, 30);
  }
}

function drawBullets() {
  const nowPerf = (typeof performance!=='undefined' && performance.now)?performance.now():Date.now();
  const viewW = canvas.width / renderScale;
  const viewH = canvas.height / renderScale;

  // marge pour éviter pop-in/out
  const M = 40;
  const minX = cameraX - M, maxX = cameraX + viewW + M;
  const minY = cameraY - M, maxY = cameraY + viewH + M;

  for (const id in bullets) {
    const b = bullets[id];
    // culling rapide
    if (b.x < minX || b.x > maxX || b.y < minY || b.y > maxY) continue;

    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = (b.owner === myId) ? 'yellow' : '#ff0';
    ctx.lineWidth = 3;
    ctx.moveTo(b.x - cameraX, b.y - cameraY);
    ctx.lineTo(
      b.x - cameraX - b.dx * 8,
      b.y - cameraY - b.dy * 8
    );
    ctx.stroke();
    ctx.restore();

    // Memorize last shooting direction per owner (used to orient sprites while shooting)
    if (b && typeof b.dx === 'number' && typeof b.dy === 'number' && b.owner) {
      const ang = Math.atan2(b.dy, b.dx);
      recentShootDir.set(b.owner, { ang, t: nowPerf });
    }
  }
}

function drawTurretLasers() {
  if (!turretLasers.length) return;

  const now = performance.now();
  const LIFE_MS = 60;                // (était 80) — persistance plus courte
  const MAX_LASERS_PER_FRAME = 60;   // (était 150) — cap plus strict pour éviter les spikes

  // Trim à l’avant si trop d’entrées (on garde les plus récentes)
  if (turretLasers.length > MAX_LASERS_PER_FRAME) {
    turretLasers = turretLasers.slice(turretLasers.length - MAX_LASERS_PER_FRAME);
  }

  ctx.save();
  ctx.lineWidth = 2;

  let w = 0; // compteur de traits vraiment dessinés
  for (let i = turretLasers.length - 1; i >= 0; i--) {
    const b = turretLasers[i];
    const age = now - b.t;
    if (age > LIFE_MS) {
      turretLasers.splice(i, 1);
      continue;
    }

    // Alpha simple, pas d'effets coûteux
    const alpha = 1 - (age / LIFE_MS);
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = b.color || '#fff';

    ctx.beginPath();
    ctx.moveTo(b.x0 - cameraX, b.y0 - cameraY);
    ctx.lineTo(b.x1 - cameraX, b.y1 - cameraY);
    ctx.stroke();

    if (++w >= MAX_LASERS_PER_FRAME) break; // sécurité
  }

  ctx.restore();
}

	function drawMoneyFloatingTexts() {
	  const now = Date.now();
	  for (let i = moneyFloatingTexts.length - 1; i >= 0; i--) {
		const f = moneyFloatingTexts[i];
		const t = (now - f.time);
		if (t > f.duration) {
		  moneyFloatingTexts.splice(i, 1); // On le retire
		  continue;
		}
		// Position écran
		const screenX = f.x - cameraX;
		const screenY = f.y - cameraY + f.vy * t;

		ctx.save();
		ctx.globalAlpha = 1 - (t / f.duration); // Fade out progressif
		ctx.font = "bold 28px Arial";
		ctx.textAlign = "center";
		ctx.lineWidth = 3;
		ctx.strokeStyle = "#222";
		ctx.strokeText(`+${f.amount}$`, screenX, screenY);
		ctx.fillStyle = "#32ff72";
		ctx.fillText(`+${f.amount}$`, screenX, screenY);
		ctx.restore();
	  }
	}

	function drawHealthBar(x, y, current, max, width = null, height = 5) {
	  let w;
	  if (width !== null) {
		w = width;  // largeur fixée explicitement
	  } else {
		// largeur variable pour zombies, par exemple
		w = Math.max(30, Math.min(70, 30 + (max - 10) * 0.7));
	  }
	  const ratio = Math.max(0, Math.min(1, current / max));
	  ctx.fillStyle = '#111';
	  ctx.fillRect(x - w / 2, y, w, height);
	  ctx.fillStyle = (ratio < 0.4) ? "#e66" : "#8f8";
	  ctx.fillRect(x - w / 2, y, w * ratio, height);
	  ctx.strokeStyle = '#fff';
	  ctx.strokeRect(x - w / 2, y, w, height);
	}

function drawAimLine() {
  if (isSpectator) return;
  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  const player = playersHealth[myId];
  let dir = { x: 1, y: 0 };
  let show = false;

  if (isMobileDevice) {
    // 👉 même logique que le tir mobile (avec curve)
    let len = Math.hypot(aimJoyVal.x, aimJoyVal.y);
    if (len > 0.06) {
      let ax = aimJoyVal.x / (len || 1);
      let ay = aimJoyVal.y / (len || 1);
      ax = curve(ax);
      ay = curve(ay);
      const n = Math.hypot(ax, ay);
      if (n > 0.0001) dir = { x: ax / n, y: ay / n }; // on renormalise pour tracer une ligne propre
      show = true;
    }
  } else {
    if (mouseDown) {
      const w = clientToWorld(mousePos.x, mousePos.y); let dx = w.x - player.x;
      let dy = w.y - player.y;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 3) {
        dir = { x: dx / dist, y: dy / dist };
        show = true;
      }
    }
  }

  if (!show) return;

  const length = 440;
  const screenX = player.x - cameraX;
  const screenY = player.y - cameraY;

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(screenX, screenY);
  ctx.lineTo(screenX + dir.x * length, screenY + dir.y * length);
  ctx.strokeStyle = 'rgba(255,255,0,0.66)';
  ctx.lineWidth = 2;
  ctx.shadowColor = 'yellow';
  ctx.shadowBlur = 7;
  ctx.stroke();
  ctx.restore();
}

// — Détection de support 'evenodd' (une fois) —
let CANVAS_EVENODD_OK = null;
function testEvenOddSupport() {
  try {
    const c = document.createElement('canvas');
    c.width = c.height = 8;
    const g = c.getContext('2d');

    // fond blanc
    g.fillStyle = '#fff';
    g.fillRect(0, 0, 8, 8);

    // on dessine un masque noir avec un trou "evenodd"
    g.fillStyle = '#000';
    g.beginPath();
    g.rect(0, 0, 8, 8);
    g.moveTo(4 + 2, 4); // évite artefacts
    g.arc(4, 4, 2, 0, Math.PI * 2, true);
    g.fill('evenodd');

    // si le trou a bien été créé, le pixel central n’est PAS noir
    const [r, gch, b, a] = g.getImageData(4, 4, 1, 1).data;
    return !(r === 0 && gch === 0 && b === 0 && a !== 0);
  } catch {
    return false;
  }
}

function drawLightMask() {
  if (isSpectator) return;
  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;

  // centre du joueur en coordonnées écran (identique PC)
  const p = playersHealth[myId];
  const screenX = (p.x - cameraX) * renderScale;
  const screenY = (p.y - cameraY) * renderScale;

  // ★ rayon du halo en pixels ÉCRAN (monde 420 * zoom écran)
  const r = CLIENT_VIEW_RADIUS * renderScale; // ★ AJOUT

  // on passe en coordonnées écran pour l’overlay (identique PC)
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  // — init du test 'evenodd' une fois —
  if (CANVAS_EVENODD_OK === null) {
    CANVAS_EVENODD_OK = testEvenOddSupport();
  }

  if (CANVAS_EVENODD_OK) {
    // ✅ chemin standard (exactement comme PC)
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.beginPath();
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.moveTo(screenX + r, screenY);                 // ★ remplace CLIENT_VIEW_RADIUS par r
    ctx.arc(screenX, screenY, r, 0, Math.PI * 2, true); // ★ idem
    ctx.fill('evenodd');
    ctx.restore();
  } else {
    // 🔁 fallback mobile (visuellement identique) : on “perfore” le trou
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const prevOp = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(screenX, screenY, r, 0, Math.PI * 2);      // ★ idem
    ctx.fill();
    ctx.globalCompositeOperation = prevOp;
    ctx.restore();
  }

  // on remet l’espace monde
  ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);
}

function update(deltaTime) {
  
    // Spectator: send movement intent to server so it can filter updates around our view
    try {
      if (window.socket) {
        const dir = { x: 0, y: 0 };
        if (keys['arrowup'] || keys['w']) dir.y -= 1;
        if (keys['arrowdown'] || keys['s']) dir.y += 1;
        if (keys['arrowleft'] || keys['a']) dir.x -= 1;
        if (keys['arrowright'] || keys['d']) dir.x += 1;
        socket.emit('spectatorMove', dir);
      }
    } catch(e) {}
if (isSpectator) {
    // Déplacement libre du spectateur (500 px/s)
    let mx = 0, my = 0;
    if (keys['arrowup'] || keys['w']) my -= 1;
    if (keys['arrowdown'] || keys['s']) my += 1;
    if (keys['arrowleft'] || keys['a']) mx -= 1;
    if (keys['arrowright'] || keys['d']) mx += 1;
    const len = Math.hypot(mx, my) || 1;
    const speed = 500; // px/sec
    spectatorPos.x += (mx/len) * speed * deltaTime;
    spectatorPos.y += (my/len) * speed * deltaTime;
    // Clamp aux limites de la carte
    const maxX = MAP_COLS * TILE_SIZE;
    const maxY = MAP_ROWS * TILE_SIZE;
    spectatorPos.x = Math.max(0, Math.min(spectatorPos.x, maxX));
    spectatorPos.y = Math.max(0, Math.min(spectatorPos.y, maxY));
    return;
  }
  if (isDead || !myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  let player = playersHealth[myId];
  let move = { x: 0, y: 0 };

  // ---- MOUVEMENT ----
  if (!isMobileDevice) {
    if (keys['arrowup'] || keys['w']) move.y -= 1;
    if (keys['arrowdown'] || keys['s']) move.y += 1;
    if (keys['arrowleft'] || keys['a']) move.x -= 1;
    if (keys['arrowright'] || keys['d']) move.x += 1;
  } else {
    const len = Math.hypot(moveJoyVal.x, moveJoyVal.y);
    if (len > 0.06) {
      let mx = moveJoyVal.x / (len || 1);
      let my = moveJoyVal.y / (len || 1);
      move.x = curve(mx);
      move.y = curve(my);
    }
  }

  // ⚠️ Remplacement de l'ancien "socket.emit('moveDir', move);" par :
  emitMoveThrottled(move);

  // ---- TIR ----
  let shooting = false;
  let shootDir = { x: 1, y: 0 };

  if (!isMobileDevice) {
    // ✅ corrige avec / renderScale
      const w = clientToWorld(mousePos.x, mousePos.y); let dx = w.x - player.x;
      let dy = w.y - player.y;
    let len = Math.hypot(dx, dy);
    if (len > 3) shootDir = { x: dx / len, y: dy / len };
    shooting = mouseDown;
  } else {
    const len = Math.hypot(aimJoyVal.x, aimJoyVal.y);
    if (len > 0.06) {
      let ax = aimJoyVal.x / (len || 1);
      let ay = aimJoyVal.y / (len || 1);
      ax = curve(ax);
      ay = curve(ay);
      shootDir = { x: ax, y: ay };
      shooting = true;
    }
  }

  if (shooting) {
    const n = Math.hypot(shootDir.x, shootDir.y);
    if (n > 0.0001) lastAimDir = { x: shootDir.x, y: shootDir.y };
  }

  // --- AUTO-FIRE: cible visible la plus proche (dans le halo) ---
  if (AUTO_FIRE_ENABLED && !buildMode) {
    const sm = document.getElementById('shopModal');
    const shopOpen = sm && sm.style.display === 'block';
    if (myId && playersHealth[myId] && playersHealth[myId].alive) {
      const p = playersHealth[myId];
      let best = null, bestD2 = Infinity;
      const ZSRC = (typeof ZOMBIES_FRAME !== 'undefined' && Array.isArray(ZOMBIES_FRAME) && ZOMBIES_FRAME.length)
        ? ZOMBIES_FRAME
        : Object.values(zombies || {});
      const r2 = CLIENT_VIEW_RADIUS * CLIENT_VIEW_RADIUS;
      for (const z of ZSRC) {
        if (!z || z.hp <= 0) continue;
        const dx = z.x - p.x, dy = z.y - p.y;
        const d2 = dx*dx + dy*dy;
        if (d2 > r2) continue;
        if (losBlockedForPlayer(p.x, p.y, z.x, z.y)) continue;
        if (d2 < bestD2) { bestD2 = d2; best = z; }
      }
      if (best) {
        const d = Math.sqrt(bestD2) || 1;
        shooting = true;
        shootDir = { x: (best.x - p.x) / d, y: (best.y - p.y) / d };
        lastAimDir = shootDir;
      }
    }
  }

  if (shooting && !shootBlocked) {
    shootBlocked = true;
    socket.emit('shoot', {
      targetX: player.x + shootDir.x * 120,
      targetY: player.y + shootDir.y * 120
    });
    setTimeout(() => { shootBlocked = false; }, 300);
  }
}

if (isMobileDevice) {
  canvas.addEventListener('pointerdown', (e) => {
    if (buildMode) return;
    if (e.clientX <= window.innerWidth * 0.5) return;
    if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;

    const p = playersHealth[myId];
    const dx = (cameraX + e.clientX / renderScale) - p.x;
    const dy = (cameraY + e.clientY / renderScale) - p.y;
    const d  = Math.hypot(dx, dy);
    const dir = d > 4 ? { x: dx / d, y: dy / d } : lastAimDir;

    if (!shootBlocked) {
      shootBlocked = true;
      socket.emit('shoot', {
        targetX: p.x + dir.x * 120,
        targetY: p.y + dir.y * 120
      });
      setTimeout(() => { shootBlocked = false; }, 300);
    }
  }, { passive: true });
}

// ---- Aide : écran -> monde -> tuile ----
function screenToWorldTile(clientX, clientY) {
  const w = clientToWorld(clientX, clientY);
  return {
    tx: Math.floor(w.x / TILE_SIZE),
    ty: Math.floor(w.y / TILE_SIZE)
  };
}

// Test d'intersection cercle-rectangle (client)
function circleIntersectsTileClient(cx, cy, cr, tx, ty) {
  const rx = tx * TILE_SIZE, ry = ty * TILE_SIZE;
  const closestX = Math.max(rx, Math.min(cx, rx + TILE_SIZE));
  const closestY = Math.max(ry, Math.min(cy, ry + TILE_SIZE));
  const dx = cx - closestX, dy = cy - closestY;
  return (dx*dx + dy*dy) <= cr*cr;
}
// Survol pour l'aperçu de placement
canvas.addEventListener('mousemove', (e) => {
  if (!buildMode) return;
  const { tx, ty } = screenToWorldTile(e.clientX, e.clientY);
  buildHover.tx = tx; buildHover.ty = ty;
}, { passive: true });

canvas.addEventListener('pointermove', (e) => {
  if (!buildMode) return;
  const { tx, ty } = screenToWorldTile(e.clientX, e.clientY);
  buildHover.tx = tx; buildHover.ty = ty;
}, { passive: true });

// Survol mobile pour l’aperçu de placement
canvas.addEventListener('touchmove', (e) => {
  if (!buildMode) return;
  const t = e.changedTouches && e.changedTouches[0];
  if (!t) return;
  const { tx, ty } = screenToWorldTile(t.clientX, t.clientY);
  buildHover.tx = tx; 
  buildHover.ty = ty;
}, { passive: true });

// ---- Placement sur mobile (touch) ----
// [patched] mobile touchstart immediate placement removed (replaced by drag-to-drop setup)


canvas.addEventListener('pointerdown', (e) => {
  if (!buildMode) return;
  if (e.pointerType && e.pointerType !== 'mouse') return; // ignore touch/pen to let mobile drag handle
e.preventDefault();
  e.stopPropagation();
  tryPlaceStructureAtCursor(e.clientX, e.clientY);
  mouseDown = false;
});


function drawBuildPreview() {
  if (!buildMode || buildHover.tx < 0 || buildHover.ty < 0) return;

  const tx = buildHover.tx, ty = buildHover.ty;
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) return;

  // rouge si bloqué, vert si OK
  const me = (myId && playersHealth[myId]) ? playersHealth[myId] : null;
  let blocked = isWallAt(tx, ty) || (structures?.[ty]?.[tx]);
  // Hors halo de visibilité (désactivé en spectateur)
  if (me && !isSpectator) {
    const cx = (tx + 0.5) * TILE_SIZE;
    const cy = (ty + 0.5) * TILE_SIZE;
    const dx = me.x - cx, dy = me.y - cy;
    const R2 = (CLIENT_VIEW_RADIUS - 8) * (CLIENT_VIEW_RADIUS - 8);
    if ((dx*dx + dy*dy) > R2) blocked = true;
  }

  // collision avec entités (joueurs/bots/zombies)
  if (!blocked) {
    for (const id in playersHealth) {
      const p = playersHealth[id]; if (!p || !p.alive) continue;
      if (circleIntersectsTileClient(p.x, p.y, PLAYER_RADIUS, tx, ty)) { blocked = true; break; }
    }
  }
  if (!blocked) {
    for (const zid in zombies) {
      const z = zombies[zid]; if (!z) continue;
      if (circleIntersectsTileClient(z.x, z.y, ZOMBIE_RADIUS, tx, ty)) { blocked = true; break; }
    }
  }

  const x = tx * TILE_SIZE - cameraX;
  const y = ty * TILE_SIZE - cameraY;

  ctx.save();
  ctx.globalAlpha = 0.5;
  // couleur selon le type
  if (buildMode === 'T') ctx.fillStyle = '#d33';
  else if (buildMode === 't') ctx.fillStyle = '#3aa6ff';
  else if (buildMode === 'B') ctx.fillStyle = '#7b4b2a';
  else if (buildMode === 'D') ctx.fillStyle = '#a57b4a';
  else if (buildMode === 'G') ctx.fillStyle = '#b48cff';
  else ctx.fillStyle = '#888';

  // prévisualisation
  ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
  ctx.strokeStyle = blocked ? '#ff3b3b' : '#34e05a';
  ctx.lineWidth = 2;
  ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
  ctx.restore();
}

function drawBuildPreview() {
  if (!buildMode || buildHover.tx < 0 || buildHover.ty < 0) return;

  const tx = buildHover.tx, ty = buildHover.ty;
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) return;

  // rouge si bloqué, vert si OK
  const me = (myId && playersHealth[myId]) ? playersHealth[myId] : null;
  let blocked = isWallAt(tx, ty) || (structures?.[ty]?.[tx]);

  // Hors halo de visibilité (désactivé en spectateur)
  if (me && !isSpectator) {
    const cx = (tx + 0.5) * TILE_SIZE;
    const cy = (ty + 0.5) * TILE_SIZE;
    const dx = me.x - cx, dy = me.y - cy;
    const R2 = (CLIENT_VIEW_RADIUS - 8) * (CLIENT_VIEW_RADIUS - 8);
    if ((dx*dx + dy*dy) > R2) blocked = true;
  }

  // collision avec entités (joueurs/bots/zombies)
  if (!blocked) {
    for (const id in playersHealth) {
      const p = playersHealth[id]; if (!p || !p.alive) continue;
      if (circleIntersectsTileClient(p.x, p.y, PLAYER_RADIUS, tx, ty)) { blocked = true; break; }
    }
  }
  if (!blocked) {
    for (const zid in zombies) {
      const z = zombies[zid]; if (!z) continue;
      if (circleIntersectsTileClient(z.x, z.y, ZOMBIE_RADIUS, tx, ty)) { blocked = true; break; }
    }
  }

  const x = tx * TILE_SIZE - cameraX;
  const y = ty * TILE_SIZE - cameraY;

  ctx.save();
  ctx.globalAlpha = 0.5;
  // couleur selon le type
  if (buildMode === 'T') ctx.fillStyle = '#d33';
  else if (buildMode === 't') ctx.fillStyle = '#3aa6ff';
  else if (buildMode === 'B') ctx.fillStyle = '#7b4b2a';
  else if (buildMode === 'D') ctx.fillStyle = '#a57b4a';
  else if (buildMode === 'G') ctx.fillStyle = '#b48cff';
  else ctx.fillStyle = '#888';

  // prévisualisation du bloc
  ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
  ctx.strokeStyle = blocked ? '#ff3b3b' : '#34e05a';
  ctx.lineWidth = 2;
  ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
  ctx.restore();
}

function tryPlaceStructureAtCursor(clientX, clientY) {
  const { tx, ty } = screenToWorldTile(clientX, clientY);

  // bornes / murs
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) {
    console.debug('[build] Hors carte', { tx, ty });
    return;
  }
  if (isWallAt(tx, ty)) {
    console.debug('[build] Case murale', { tx, ty });
    return;
  }

  // bloc déjà occupé par une structure ?

  // halo de visibilité
  const me = (myId && playersHealth[myId]) ? playersHealth[myId] : null;
  if (me && !isSpectator) {
    const cx = (tx + 0.5) * TILE_SIZE;
    const cy = (ty + 0.5) * TILE_SIZE;
    const dx = me.x - cx, dy = me.y - cy;
    const R2 = (CLIENT_VIEW_RADIUS - 8) * (CLIENT_VIEW_RADIUS - 8);
    if ((dx*dx + dy*dy) > R2) {
      console.debug('[build] Hors halo', { tx, ty });
      return;
    }
  }

  // collision avec entités (joueurs/bots/zombies)
  for (const id in playersHealth) {
    const p = playersHealth[id]; if (!p || !p.alive) continue;
    if (circleIntersectsTileClient(p.x, p.y, PLAYER_RADIUS, tx, ty)) {
      console.debug('[build] Collision avec joueur/bot', { tx, ty });
      return;
    }
  }
  for (const zid in zombies) {
    const z = zombies[zid]; if (!z) continue;
    if (circleIntersectsTileClient(z.x, z.y, ZOMBIE_RADIUS, tx, ty)) {
      console.debug('[build] Collision avec zombie', { tx, ty });
      return;
    }
  }

  if (structures?.[ty]?.[tx]) {
    console.debug('[build] Case déjà occupée par une structure', { tx, ty, existing: structures[ty][tx] });
    return;
  }

  // payload (on envoie aussi centre monde pour aider le serveur s'il en a besoin)
  const payload = {
    type: buildMode,
    tx,
    ty,
    x: tx * TILE_SIZE + TILE_SIZE / 2,
    y: ty * TILE_SIZE + TILE_SIZE / 2
  };

  console.debug('[emit] buyStructure', payload);

  // ↘️ on attend l’ACK du serveur pour savoir si on sort du mode placement
  try {
    socket.emit('buyStructure', payload, (ack) => {
      if (ack && ack.type && ack.type === 'T_big') { if (structures) { let t = structures.find(s=>s && s.type==='T_big'); if (t) t.hp = t.maxHP||t.hp; } }
      console.debug('[ack] buyStructure', ack);
      if (ack && ack.ok) {
        // succès confirmé → sortir du mode placement
        buildMode = null;
        buildHover = { tx: -1, ty: -1 };
      } else {
        // refus: on reste en mode placement pour réessayer ailleurs
        const reason = ack && ack.reason ? ack.reason : 'unknown';
        console.warn('[build] Refusé par le serveur:', reason);
      }
    });
  } catch (err) {
    console.error('[emit] buyStructure error:', err);
  }
}

	function updateCamera() {
      const viewW = canvas.width / renderScale;
      const viewH = canvas.height / renderScale;
      if (isSpectator) {
        cameraX = spectatorPos.x - viewW / 2;
        cameraY = spectatorPos.y - viewH / 2;
        cameraX = Math.max(0, Math.min(cameraX, MAP_COLS * TILE_SIZE - viewW));
        cameraY = Math.max(0, Math.min(cameraY, MAP_ROWS * TILE_SIZE - viewH));
        return;
      }
	  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
	  let player = playersHealth[myId];

	  cameraX = player.x - viewW / 2;
	  cameraY = player.y - viewH / 2;

	  cameraX = Math.max(0, Math.min(cameraX, MAP_COLS * TILE_SIZE - viewW));
	  cameraY = Math.max(0, Math.min(cameraY, MAP_ROWS * TILE_SIZE - viewH));
	}

function drawHUD() {
  const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
  const aliveCount = Object.values(playersHealth).filter(p => p.alive).length;

  hudAlive.textContent = `${tr.alive} : ${aliveCount}`;
  hudMoney.textContent = `${tr.money || 'Money'} : $${myMoney}`;

  // ⚠️ Libellé imposé : "Zombies left" (pas de fallback "Active zombies")
  const labelZ = (TRANSLATIONS[currentLang] && TRANSLATIONS[currentLang].zombiesLeft) || 'Zombies left';

  // Compteur : priorise zombiesRemaining, sinon on compte les zombies actifs
  const countZ = (Number.isFinite(zombiesRemaining) && zombiesRemaining >= 0)
    ? zombiesRemaining
    : (zombies && typeof zombies === 'object' ? Object.keys(zombies).length : 0);

  hudZombies.textContent = `${labelZ}: ${countZ}`;

  hudKills.textContent = `${tr.kills}: ${myKills}`;
  hudRound.textContent = `${tr.round}: ${currentRound}`;

  const me = playersHealth[myId];
  hudHP.textContent = me && me.maxHealth
    ? `${tr.health}: ${Math.round(me.health)} / ${me.maxHealth}`
    : `${tr.health}: ${Math.round(me ? me.health : 0)}`;

  // Gold line (account-level), only when logged in
  try {
    if (window.__meOk === true && hudGold) {
      const pack = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      hudGold.style.display = '';
      hudGold.textContent = `${pack.gold || 'Gold'} : ${String((window.accountGold|0))}`;
    } else if (hudGold) {
      hudGold.style.display = 'none';
    }
  } catch(_){}
}

  // Gold line (account-level), only when logged in
  try {
    if (window.__meOk === true && hudGold) {
      const pack = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      hudGold.style.display = '';
      hudGold.textContent = `${pack.gold || 'Gold'} : ${String((window.accountGold|0))}`;
    } else if (hudGold) {
      hudGold.style.display = 'none';
    }
  } catch(_){}


    function showDeathScreen(kills = myKills, round = currentRound) {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      const deathStats = document.getElementById('deathStats');
      if (deathStats) {
        deathStats.innerHTML = `${tr.zombiesKilled}: <b>${kills}</b><br>${tr.roundReached}: <b>${round}</b>`;
      }
      // --- Submit score to ladder (robust, non-blocking) ---
      try {
        if (!window.__ladderSubmitted) {
          window.__ladderSubmitted = true;
          var player = (window.myPseudo && String(window.myPseudo)) || (window.pseudoInput && String(window.pseudoInput.value)) || '';
          player = (player || '').replace(/[^a-zA-Z0-9]/g,'').slice(0,10) || 'Anonymous';
          /* Ladder is now recorded server-side on death; client no longer posts. */
            if (!window.__ladderSubmitted) { window.__ladderSubmitted = true; }
        }
      } catch(_){}

      // Met à jour les libellés
      const deathTitle = document.getElementById('deathTitle');
      if (deathTitle) deathTitle.textContent = tr.youDied || 'You died!';
      const btnReplay = document.getElementById('btnReplay');
      if (btnReplay) btnReplay.textContent = tr.replay || 'Replay';
      if (btnSpectate) {
        btnSpectate.textContent = (tr.spectate || 'Spectate');
        // Affiche Spectate seulement s'il reste au moins un autre joueur vivant
        try {
          const hasOtherAlive = Object.keys(playersHealth || {}).some(id => {
            if (id === myId) return false;
            const p = playersHealth[id];
            return p && p.alive;
          });
          btnSpectate.style.display = hasOtherAlive ? 'inline-block' : 'none';
        } catch(e) { btnSpectate.style.display = 'none'; }
      }
      deathScreen.style.display = 'flex';
    }

const spectateReplayBtn = document.getElementById('spectateReplayBtn');
if (btnSpectate) {
  const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
  btnSpectate.textContent = (tr.spectate || 'Spectate');
}
if (spectateReplayBtn) {
  spectateReplayBtn.onclick = async () => { location.reload(); };
}
function enterSpectatorMode() {
  try { if (window.socket) { socket.emit('enterSpectator'); } } catch(e){}
  // init position au centre de la caméra actuelle (dernière position connue)
  try {
    if (playersHealth[myId]) {
      spectatorPos.x = playersHealth[myId].x || (cameraX + canvas.width / (2*renderScale));
      spectatorPos.y = playersHealth[myId].y || (cameraY + canvas.height / (2*renderScale));
    } else {
      spectatorPos.x = cameraX + canvas.width / (2*renderScale);
      spectatorPos.y = cameraY + canvas.height / (2*renderScale);
    }
  } catch(e) {
    spectatorPos.x = cameraX + canvas.width / (2*renderScale);
    spectatorPos.y = cameraY + canvas.height / (2*renderScale);
  }
  isSpectator = true;
  deathScreen.style.display = 'none';
        if (spectateReplayBtn) spectateReplayBtn.style.display = 'block';
}
// Config bouton Spectate (seulement si la partie est encore en cours)
if (btnSpectate) {
  btnSpectate.onclick = async () => {
    if (btnSpectate.style.display !== 'none') enterSpectatorMode();
  };
}

let lastTime = 0;
function gameLoop(timestamp = 0) {
  FRAME_ID++; // <- important : identifie le frame courant pour nos caches
	refreshZombiesFrame();
  const deltaTime = Math.max(0.008, Math.min(0.05, (timestamp - lastTime) / 1000));
  lastTime = timestamp;

  update(deltaTime);
  updateCamera();

  // Remet la transform, clear, puis applique le scale (zoom)
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);

  drawMap();
  drawBuildPreview();
  drawStructures();        // utilise refreshZombiesFrame() (1x/frame)
  drawBullets();           // culling
  drawTurretLasers();
  drawZombies();
  drawMoneyFloatingTexts();
  drawPlayers();
  drawAimLine();
  drawLightMask();

  drawHUD();

  requestAnimationFrame(gameLoop);
}

    socket.on('connect', () => { myId = socket.id; });
    socket.on('lobbyUpdate', (data) => {
      lobbyData = {
        started: !!data.started,
        count: Number(data.count)||0,
        max: Number(data.max)||0,
        timeLeft: Number(data.timeLeft)||0,
        players: data.players || {},
        hostId: (data && data.hostId) || null
      };
      try { window.lobbyData = lobbyData; } catch(_){}

      try { lobbyData.id = data && data.id; lobbyData.manual = !!(data && data.manual); } catch(e){}
      try { const t = document.getElementById('manualLobbyTitle'); if (t && data && data.manual) { t.textContent = ( (TRANSLATIONS[currentLang]&&TRANSLATIONS[currentLang].lobby) ? (TRANSLATIONS[currentLang].lobby+' #') : 'Lobby #') + (data.id || '?'); } } catch(e){}
      try { const p = document.getElementById('manualLobbyPanel'); if (p && p.style.display !== 'none') { renderManualPlayers(); } } catch(e){}
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      if (data.started) {
        lobbyScreen.style.display = 'none';
        lobbyStarted = true;
        return;
      }
      lobbyScreen.style.display = 'flex';
      updateLobbyTexts();
      if (lobbyJoin) lobbyJoin.disabled = (!!window.lobbyJoined) || !pseudoInput.value.trim();
      pseudoInput.readOnly = lobbyJoined;
if (lobbyJoin)       lobbyJoin.textContent = tr.join;
    });

    if (lobbyJoin) lobbyJoin.onclick = async () => {
      if (!pseudoInput.value.trim()) {
        pseudoInput.focus();
        pseudoInput.style.background = "#fdd";
        setTimeout(() => pseudoInput.style.background = "", 600);
        return;
      }
      ensureMySkinLoaded().then(() => socket.emit('setPseudoAndReady', pseudoInput.value.trim())); try { localStorage.setItem('zombi_last_pseudo', String(pseudoInput.value.trim())); } catch(_) {}lobbyJoined = true;
      window.lobbyJoined = true;
      if (lobbyJoin) lobbyJoin.disabled = true;
      pseudoInput.readOnly = true;
      
if (lobbyJoin)           try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }lobbyJoin.textContent = TRANSLATIONS[currentLang].waiting;
      try { updateButtonsDisabled(); } catch(_) {}
    };

    pseudoInput.onkeydown = (e) => {
      if (e.key === "Enter") if (lobbyJoin) lobbyJoin.click();
    };

    socket.on('gameStarted', (data) => { currentGameId = (data && (data.gameId || data.gid || data.id)) || null; try { const ds = document.getElementById('deathScreen'); if (ds) ds.style.display = 'none'; } catch(e) {} myId = socket.id; isSpectator = false;
      map = data.map;
	  createMapBuffer();
      MAP_ROWS = map.length;
      MAP_COLS = map[0].length;
      playersHealth = data.players;
      try {
        var me = (playersHealth && myId) ? playersHealth[myId] : null;
        var ok = me && isNum(me.x) && isNum(me.y);
        if (ok) { __lastValidMyPos = {x: me.x, y: me.y}; centerCameraOn(me.x, me.y); __centeredOnPlayerOnce = true; }
        try { debugLog('🎯 gameStarted mePos=', ok ? (me.x+','+me.y) : 'n/a', 'centered=', !!ok); } catch(_){}
      } catch(_){}

      
      // Guard: if my player exists, center camera immediately; else keep default until first update
      try {
        if (playersHealth && myId && playersHealth[myId]) {
          const viewW = canvas.width / renderScale;
          const viewH = canvas.height / renderScale;
          cameraX = Math.max(0, Math.min(playersHealth[myId].x - viewW/2, MAP_COLS*TILE_SIZE - viewW));
          cameraY = Math.max(0, Math.min(playersHealth[myId].y - viewH/2, MAP_ROWS*TILE_SIZE - viewH));
        }
      } catch(e) {}
    currentRound = data.round;
      lobbyScreen.style.display = 'none';
      isDead = false; playerHealth = 100; myKills = 0;
      if (isMobileDevice) setTimeout(setupJoysticks, 300);
      setTimeout(()=>{ gameLoop(); }, 400);
	  structures = data.structures || null;
	if (data.structurePrices) {
	  STRUCTURE_PRICES = data.structurePrices;
	}
	updateBuildTilesState(); // rafraîchir les étiquettes + disabled
    });

socket.on('waveStarted', ({ totalZombies }) => {
  resetWaveCounters(totalZombies);
});

// --- MISE À JOUR DES STRUCTURES PAR LE SERVEUR ---
// Reçoit une grille 2D (chaque case = null ou { type, hp } ou juste "type")
socket.on('structuresUpdate', (grid) => {
  // Normalise la grille reçue pour garantir des HP corrects
  if (!grid || !grid.length) { structures = grid; return; }
  const rows = grid.length;
  const cols = grid[0]?.length || 0;
  const newGrid = Array.from({ length: rows }, (_, y) =>
    Array.from({ length: cols }, (_, x) => {
      const cell = grid[y][x];
      if (!cell || cell === 0) return null;

      // HP depuis structHPGrid (si dispo) sinon HP précédent sinon valeur par défaut selon type
      const hpFromGrid = structHPGrid?.[y]?.[x];
      const previousHP = structures?.[y]?.[x]?.hp;

      if (typeof cell === 'object') {
          const type = cell.type;
let hp = (typeof cell.hp === 'number') ? cell.hp
          : ((typeof hpFromGrid === 'number' && hpFromGrid > 0) ? hpFromGrid
            : ((typeof previousHP === 'number' && previousHP > 0) ? previousHP
              : (type === 'T' ? 500 : (type === 't' ? 200 : (type === 'G' ? 2500 : ((type === 'B' || type === 'D') ? 500 : 200))))));
        if (hp <= 0) return null;
          return { type, hp, placedBy: cell.placedBy };
        }

      if (typeof cell === 'string') {
        const type = cell;
        let hp = ((typeof hpFromGrid === 'number' && hpFromGrid > 0) ? hpFromGrid
          : ((typeof previousHP === 'number' && previousHP > 0) ? previousHP
            : (type === 'T' ? 500 : (type === 't' ? 200 : (type === 'G' ? 2500 : ((type === 'B' || type === 'D') ? 500 : 200))))));
        if (hp <= 0) return null;
        return { type, hp };
      }

      return null;
    })
  );
  structures = newGrid;

  // seed/rafraîchir structHPGrid si la grille contient des hp
  if (!structHPGrid) structHPGrid = [];
  for (let ty = 0; ty < grid.length; ty++) {
    const row = grid[ty];
    if (!structHPGrid[ty]) structHPGrid[ty] = [];
    for (let tx = 0; tx < row.length; tx++) {
      const cell = row[tx];
      if (cell && typeof cell === 'object' && typeof cell.hp === 'number') {
        structHPGrid[ty][tx] = cell.hp;
      } else if (cell == null) {
        structHPGrid[ty][tx] = 0; // détruit
      }
    }
  }
});

   
   
   socket.on('laserBeam', ({ x0, y0, x1, y1, color }) => {
  // On stocke pour le prochain rendu; l’effet disparaît très vite
  turretLasers.push({
    x0, y0, x1, y1, color,
    t: performance.now()
  });
});

   
   socket.on('laserBeams', (arr) => {
  const t = performance.now();
  // On push dans le même buffer que d’habitude
  for (let i = 0; i < arr.length; i++) {
    const b = arr[i];
    turretLasers.push({ x0: b.x0, y0: b.y0, x1: b.x1, y1: b.y1, color: b.color, t });
  }
});

   
   
	socket.on('zombiesRemaining', (n) => {
	  zombiesRemaining = Number(n) || 0;
	  drawHUD();
	});

    socket.on('killsUpdate', (kills) => { myKills = kills; drawHUD(); });
	
socket.on('zombieDied', () => {
  if (zombiesRemaining > 0) zombiesRemaining--;
  waveKilledThisWave++;
  drawHUD();
});
	

    socket.on('youDied', (data) => {
      try { if (currentGameId && data && data.gameId && data.gameId !== currentGameId) return; } catch(e) {}
      isDead = true;
      playerHealth = 0;
      showDeathScreen(data.kills, data.round);
    });

	socket.on('moneyEarned', ({ amount, x, y }) => {
	  // Position sur la map, converti en coordonnées écran pour affichage temporaire
	  moneyFloatingTexts.push({
		amount,
		x,
		y,
		time: Date.now(),
		duration: 1200, // ms
		vy: -0.14 // pixels/ms (vitesse vers le haut)
	  });
	  myMoney += amount;          // <--- ajoute
	  drawHUD();                  // <--- ajoute
	  updateBuildTilesState();    // <--- ajoute
	  try { if (typeof renderShopUpgrades === 'function') renderShopUpgrades(); } catch(e){}  // <--- ajoute
	});

socket.on('upgradeUpdate', ({ myUpgrades: u, myMoney: m }) => {
  if (u) myUpgrades = u;
  if (typeof m === 'number') myMoney = m;
   try { window.myMoney = m; } catch(_){ } renderShopUpgrades();
  drawHUD();
  updateBuildTilesState();
try { if (typeof renderShopUpgrades === 'function') renderShopUpgrades(); } catch(e){}
	});

    socket.on('waveMessage', (msg) => {
  try {
    const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']);
    const m = String(msg || '').match(/\d+/);
    const n = m ? parseInt(m[0], 10) : NaN;
    const label = tr.round || 'Wave';
    waveMessage.textContent = Number.isFinite(n) ? (label + ' ' + n) : label;
  } catch(e) {
    waveMessage.textContent = 'Wave';
  }
  waveMessage.style.opacity = '1';
  setTimeout(() => { waveMessage.style.opacity = '0'; }, 2500);
});

	socket.on('upgradeBought', ({ upgId, newLevel, newMoney }) => {
	  if (!upgId) return;
	  myUpgrades[upgId] = newLevel;
	  myMoney = newMoney;
	  renderShopUpgrades();
	  drawHUD();
	  updateBuildTilesState();

	  // Trouve le bouton correspondant et applique l'animation
	  setTimeout(() => {
		const btn = document.querySelector(`#shopUpgrades button[data-upgid="${upgId}"]`);
		if (btn) {
		  btn.classList.remove('bought-flash'); // Si jamais déjà présente
		  // Force reflow pour relancer l'anim même si le bouton venait d'être upgradé
		  void btn.offsetWidth;
		  btn.classList.add('bought-flash');
		  setTimeout(() => btn.classList.remove('bought-flash'), 280);
		}
	  }, 60); // petit délai pour que le bouton existe après le render
	});

    setInterval(drawHUD, 150);

	// --- SHOP BTN LOGIC ---
	const shopBtn = document.getElementById('shopBtn');
	const shopModal = document.getElementById('shopModal');
	const shopClose = document.getElementById('shopClose');

// ====== UI Achat Structures \(au-dessus du SHOP\) ======

// === Auto-fire state & UI ===
let AUTO_FIRE_ENABLED = false;
const autoBtn = document.getElementById('autoFireBtn');
const autoLbl = document.getElementById('autoFireLabel');

function updateAutoFireBtnUI() {
  if (!autoBtn || !autoLbl) return;
  if (AUTO_FIRE_ENABLED) {
    autoBtn.style.background = '#d1292f';
    autoBtn.style.borderColor = '#7b0e13';
    autoBtn.style.color = '#fff';
    autoLbl.textContent = ((TRANSLATIONS[currentLang]||TRANSLATIONS['en']).autoFireOn || 'Auto fire ON');
    autoBtn.querySelector('span').style.background = '#ff6066';
  } else {
    autoBtn.style.background = '#5a2226';
    autoBtn.style.borderColor = '#4a1111';
    autoBtn.style.color = '#f1d6d6';
    autoLbl.textContent = ((TRANSLATIONS[currentLang]||TRANSLATIONS['en']).autoFireOff || 'Auto fire OFF');
    autoBtn.querySelector('span').style.background = '#742f36';
  }
}
if (autoBtn) {
  autoBtn.addEventListener('click', () => {
    AUTO_FIRE_ENABLED = !AUTO_FIRE_ENABLED;
    updateAutoFireBtnUI();
  });
  updateAutoFireBtnUI();
}

function upperFirstLocalized(s){
  if (!s) return s;
  try{
    var i = s.search(/[A-Za-zÀ-ÖØ-öø-ÿĀ-žА-Яа-яЁё]/u);
    if (i < 0) return s;
    return s.slice(0, i) + s.charAt(i).toUpperCase() + s.slice(i + 1);
  } catch(e){
    try { return s.charAt(0).toUpperCase() + s.slice(1); } catch(_) { return s; }
  }
}
const buildBar = document.getElementById('buildBar');
const buildTiles = document.querySelectorAll('#buildTiles .build-tile');
const buildTooltip = document.getElementById('buildTooltip');
let STRUCTURE_PRICES = { T: 2000, t:  500, G:  10000, B:  250, D:  500 };

// Hover → tooltip (localized, hard method)
buildTiles.forEach(btn => {
  function computeTip(type) {
    const tr = (TRANSLATIONS[(typeof window!=='undefined' && typeof window.currentLang==='string' && window.currentLang) || 'en'] || TRANSLATIONS['en']) || {};
    const names = (tr.turretType || {});
    const hpLabel = tr.hpShort || 'HP';
    const dmgLabel = tr.damage || 'Damage';
    const rateLabel = tr.fireRate || 'Fire rate';
    const baseHP = { T:500, t:200, G:2500, B:500, D:500 };
    let name =  (type==='B') ? (tr.buildWall || 'Wall')
                : (type==='D') ? (tr.buildDoor || 'Door')
                : (names[type] || 'Turret');
    name = upperFirstLocalized(name);
    if (type==='B' || type==='D') {
      return name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ')';
    } else {
      const rate = (type==='T') ? '1' : (type==='G') ? '2' : '0.5';
      const dmg = (typeof computeTurretDamageDisplay==='function') ? computeTurretDamageDisplay(type) : 0;
      return name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ', ' + dmgLabel + ': ' + dmg + ', ' + rateLabel + ': ' + rate + ((TRANSLATIONS[(typeof window!=='undefined' && typeof window.currentLang==='string' && window.currentLang) || 'en']||TRANSLATIONS['en']).perSec||'/s') + ')';
    }
  }
  btn.addEventListener('mouseenter', () => {
    if (buildTooltip && buildTooltip.dataset && buildTooltip.dataset.disabled==='1') return;
    const type = btn.getAttribute('data-type');
    const tip = computeTip(type);
    buildTooltip.textContent = tip;
    buildTooltip.style.display = 'block';
  }, { passive: true });
  btn.addEventListener('mouseleave', () => {
    if (buildTooltip && buildTooltip.dataset && buildTooltip.dataset.disabled==='1') return;
    buildTooltip.style.display = 'none';
  }, { passive: true });
});
// Click → entrer/sortir du mode placement (toggle)
let buildClickCooldown = false;
buildTiles.forEach(btn => {
  btn.addEventListener('click', () => {
    if (buildClickCooldown) return;
    buildClickCooldown = true;
    setTimeout(() => (buildClickCooldown = false), 250);

    const type = btn.getAttribute('data-type');

    // Si on reclique sur le même type → on annule le placement
    if (buildMode === type) {
      buildMode = null;
      buildHover = { tx: -1, ty: -1 };
      try { updateBuildTilesState(); } catch(_) {}
      
      try { if (document && document.body && document.body.dataset) document.body.dataset.buildMode = ''; } catch(_){}
try { if (window.__applyBuildTileHighlight) window.__applyBuildTileHighlight(); } catch(_){}
return;
    }

    // Sinon, on entre en mode placement pour ce type
    buildMode = type;
    
    
    
    try { document.body.dataset.buildMode = String(type||''); } catch(_) {};
try { document.body.dataset.buildMode = String(type||''); } catch(_) {};
    try { updateBuildTilesState(); } catch(_) {};
try { updateBuildTilesState(); } catch(_) {};
try { updateBuildTilesState(); } catch(_) {}
    
  });
});

updateBuildTilesState();

// Ajuster la position quand on bouge le shop (mobile)
function positionBuildBar() {
  // Sur mobile, on se base sur la position recalculée du SHOP (déjà gérée par positionShopUI)
  // Ici, on laisse le buildBar accrochée en haut du shopBtn (style inline déjà ok).
  // Si besoin d’ajustements fins mobile, on les ferait ici sans toucher au reste.
}
window.addEventListener('resize', positionBuildBar);
window.addEventListener('orientationchange', positionBuildBar);

// Normalise les coordonnées reçues : supporte {tx,ty} ou {x,y} en pixels
function normalizeTileCoords(obj) {
  let tx = (typeof obj.tx === 'number') ? obj.tx
        : (typeof obj.x === 'number') ? Math.floor(obj.x / TILE_SIZE)
        : null;
  let ty = (typeof obj.ty === 'number') ? obj.ty
        : (typeof obj.y === 'number') ? Math.floor(obj.y / TILE_SIZE)
        : null;
  return { tx, ty };
}

// Tente d'appliquer sur [ty][tx], puis fallback sur [tx][ty] si nécessaire
function setStructureHP(tx, ty, hp) {
  if (!structures) return false;

  // bornes “normales”
  if (ty >= 0 && ty < MAP_ROWS && tx >= 0 && tx < MAP_COLS && structures?.[ty]) {
    const cell = structures[ty][tx];
    if (cell != null) {
      if (typeof cell === 'object') structures[ty][tx].hp = hp;
      else structures[ty][tx] = { type: cell, hp };
      if (!structHPGrid) structHPGrid = [];
      if (!structHPGrid[ty]) structHPGrid[ty] = [];
      structHPGrid[ty][tx] = hp;
      return true;
    }
  }

  // fallback si inversion tx/ty côté serveur
  if (tx >= 0 && tx < MAP_ROWS && ty >= 0 && ty < MAP_COLS && structures?.[tx]) {
    const cell = structures[tx][ty];
    if (cell != null) {
      if (typeof cell === 'object') structures[tx][ty].hp = hp;
      else structures[tx][ty] = { type: cell, hp };
      if (!structHPGrid) structHPGrid = [];
      if (!structHPGrid[tx]) structHPGrid[tx] = [];
      structHPGrid[tx][ty] = hp;
      return true;
    }
  }

  return false;
}

socket.on('structureHP', (payload) => {
  // --- 1) Coords tuile fiables (accepte {tx,ty} OU {x,y} en pixels) ---
  const tx = (typeof payload.tx === 'number') ? payload.tx
            : (typeof payload.x  === 'number') ? Math.floor(payload.x / TILE_SIZE) : null;
  const ty = (typeof payload.ty === 'number') ? payload.ty
            : (typeof payload.y  === 'number') ? Math.floor(payload.y / TILE_SIZE) : null;
  const hp = Number(payload.hp);

  if (!Number.isFinite(tx) || !Number.isFinite(ty) || !Number.isFinite(hp)) return;

  // --- 2  Miroir HP (grille) : on met à jour la case "normale",
  // et si nécessaire on tente aussi l’inversion [tx][ty] (serveur inversé)
  if (!structHPGrid) structHPGrid = [];
  if (!structHPGrid[ty]) structHPGrid[ty] = [];
  structHPGrid[ty][tx] = hp;

  // Si la case "normale" n'existe pas côté structures mais l’inversée oui,
  // on maintien aussi le miroir inversé pour l’affichage
  if (!(structures?.[ty]?.[tx]) && (structures?.[tx]?.[ty])) {
    if (!structHPGrid[tx]) structHPGrid[tx] = [];
    structHPGrid[tx][ty] = hp;
  }

  // --- 3  Mise à jour de la grille visuelle (si elle existe déjà) ---
  const applyHP = (r, c) => {
    if (!structures || !structures[r]) return false;
    const cell = structures[r][c];
    if (cell == null) return false; // rien à mettre à jour

    if (typeof cell === 'object') {
      structures[r][c].hp = hp;
    } else {
      // Le serveur a peut-être envoyé juste le type (string) :
      // on le convertit en objet pour avoir un HP visible qui descend.
      structures[r][c] = { type: cell, hp };
    }

    // HP <= 0 → suppression visuelle immédiate
    if (hp <= 0) {
      structures[r][c] = null;
      if (structHPGrid?.[r]) structHPGrid[r][c] = 0;
    }
    return true;
  };

  // Essai en [ty][tx], puis fallback en [tx][ty] si besoin
  if (!applyHP(ty, tx)) applyHP(tx, ty);
});function clearStructureAt(tx, ty) {
  if (!structures) return false;

  // chemin “normal” [ty][tx]
  if (ty >= 0 && ty < MAP_ROWS && tx >= 0 && tx < MAP_COLS && structures?.[ty]) {
    if (structures[ty][tx] !== undefined) {
      structures[ty][tx] = null;
      if (structHPGrid?.[ty]) structHPGrid[ty][tx] = 0;
      return true;
    }
  }
  // fallback inversion [tx][ty]
  if (tx >= 0 && tx < MAP_ROWS && ty >= 0 && ty < MAP_COLS && structures?.[tx]) {
    if (structures[tx][ty] !== undefined) {
      structures[tx][ty] = null;
      if (structHPGrid?.[tx]) structHPGrid[tx][ty] = 0;
      return true;
    }
  }
  return false;
}

socket.on('structureDestroyed', (payload) => {
  const { tx, ty } = normalizeTileCoords(payload);
  
// Wall/Door cooldown update from server

if (!Number.isFinite(tx) || !Number.isFinite(ty)) return;

  const ok = clearStructureAt(tx, ty);
  if (!ok) console.warn('[structureDestroyed] cellule introuvable', { payload, tx, ty });
});

// Réception du résultat d’achat d’une structure
socket.on('buildResult', (payload) => {
  const {
    ok,
    reason,
    type,
    tx,
    ty,
    newMoney,
    structurePrices,
    hp: hpFromServer
  } = payload || {};

  console.debug('[on] buildResult', payload);

  // Maj argent et éventuellement la table des prix
  if (typeof newMoney === 'number') {
    myMoney = newMoney;
  }
  if (structurePrices) {
    STRUCTURE_PRICES = { STRUCTURE_PRICES, structurePrices };
  }

  // Rafraîchir l’UI
  drawHUD();
  updateBuildTilesState();

  if (!ok) {
    let msg = '';
    switch (reason) {
      case 'game_not_running': msg = "Impossible d’acheter : la partie n’est pas en cours."; break;
      case 'player_invalid':   msg = "Action impossible : joueur inactif."; break;
      case 'invalid_type':     msg = "Type d’objet invalide."; break;
      case 'not_enough_money': msg = "Pas assez d’argent."; break;
      case 'tile_blocked':     msg = "Case indisponible (mur, structure, autre joueur ou zombie)."; break;
      default:                 msg = "Achat impossible."; break;
    }
    console.warn('[buildResult] Refusé:', msg, { type, tx, ty });
    // on reste en mode placement pour réessayer ailleurs
    return;
  }

  // ✅ Succès : on pose localement la structure pour l'afficher tout de suite// S'assure que la grille existe
  if (!structures) {
    structures = Array.from({ length: MAP_ROWS }, () => Array(MAP_COLS).fill(null));
  } else if (!structures[ty]) {
    structures[ty] = [];
  }

  // HP par défaut si non fourni par le serveur
  const defaultHp = (type === 'T') ? 500 : (type === 't' ? 200 : (type === 'G' ? 2500 : ((type === 'B' || type === 'D') ? 500 : 200)));
  const hp = (typeof hpFromServer === 'number') ? hpFromServer : defaultHp;

  // Place localement
  structures[ty][tx] = { type, hp, placedBy: myId };
  
 // Maintenir aussi la grille HP si on l'utilise
if (structHPGrid) {
  if (!structHPGrid[ty]) structHPGrid[ty] = [];
  structHPGrid[ty][tx] = hp;
}

  // Sort du mode placement
  buildMode = null;
  buildHover = { tx: -1, ty: -1 };
  // Clear any visual selection highlight immediately
  try { if (document && document.body && document.body.dataset) document.body.dataset.buildMode = ''; } catch(_){}
  try { if (window.__applyBuildTileHighlight) window.__applyBuildTileHighlight(); } catch(_){}

});

	function closeShopIfOutside(evt) {
	  if (shopModal.style.display !== 'block') return;
	  const target = evt.target;
	  // Ne ferme pas si on clique sur le bouton ou dans le panneau
	  if (shopModal.contains(target) || shopBtn.contains(target)) return;
	  shopModal.style.display = 'none';
	}
	document.addEventListener('pointerdown', closeShopIfOutside, { passive: true });

function updateBuildTilesState() {
  document.querySelectorAll('#buildTiles .build-tile').forEach(btn => {
    const type = btn.getAttribute('data-type');
    const price = STRUCTURE_PRICES[type] ?? Infinity;

    // maj de l’étiquette sous la tuile (2e div)
    const priceLabel = btn.querySelector('div:nth-child(2)');
    if (priceLabel) {
      let label = `$${price}`;
      if (type==='t'||type==='T'||type==='G') {
        const limits = { t:2, T:2, G:1 };
        let count=0;
        if (structures) {
          for (let r=0;r<structures.length;r++) for (let c=0;c<structures[r].length;c++){
            const sc = structures[r][c];
            if (sc && sc.type===type && sc.hp>0 && sc.placedBy===myId) count++;
          }
        }
        label += ` • ${count}/${limits[type]}`;
      }
      priceLabel.textContent = label;
    }

    // état “achetable”
    const afford = myMoney >= price;
    btn.style.opacity = afford ? '1' : '0.55';
    btn.style.cursor  = afford ? 'pointer' : 'not-allowed';
    btn.disabled = !afford;
    // enforce per-type max counts per player
    if (type==='t' || type==='T' || type==='G') {
      const limits = { 't': 2, 'T': 2, 'G': 1 };
      let count=0;
      if (structures) {
        for (let r=0;r<structures.length;r++) for (let c=0;c<structures[r].length;c++) {
          const sc = structures[r][c];
          if (sc && sc.type===type && sc.hp>0 && sc.placedBy===myId) count++;
        }
      }
      if (count>=limits[type]) { btn.disabled=true; btn.style.opacity='0.5'; btn.style.cursor='not-allowed'; }
    }

  });
}

const PRICE_TIERS = [10, 25, 50, 75, 100];
const PRICE_STEP_AFTER_TIER = 75;
function getUpgradePrice(nextLevel) {
  if (nextLevel <= PRICE_TIERS.length) return PRICE_TIERS[nextLevel - 1];
  if (nextLevel <= 7) return PRICE_TIERS[PRICE_TIERS.length - 1] + (nextLevel - PRICE_TIERS.length) * PRICE_STEP_AFTER_TIER;
  const priceAt7 = PRICE_TIERS[PRICE_TIERS.length - 1] + (7 - PRICE_TIERS.length) * PRICE_STEP_AFTER_TIER;
  const k = nextLevel - 7;
  return Math.round(priceAt7 * Math.pow(1.2, k));
}

function getUpgText(upg, field){
  try {
    const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']);
    const pack = (tr.upgrades && tr.upgrades[upg.id]) || null;
    if (pack && pack[field]) return pack[field];
    return upg && upg[field] ? upg[field] : '';
  } catch(e){ return (upg && upg[field]) || ''; }
}
function renderShopUpgrades() {
  const _money = Number(
  (typeof myMoney === 'number') ? myMoney :
  ((typeof window !== 'undefined' && typeof window.myMoney === 'number') ? window.myMoney :
   ((typeof window !== 'undefined' && typeof window._money === 'number') ? window._money : 0))
);

  if (!window.myTurretUp || typeof myTurretUp !== 'object') { window.myTurretUp = {}; }
  const el = document.getElementById('shopUpgrades');
  el.innerHTML = "";

  // Event delegation for turret upgrade buttons (survives innerHTML changes)
  try {
    if (!el._turretDelegation) {
      el.addEventListener('click', (ev) => {
        const btn = ev.target.closest && ev.target.closest('.btn-turret-up');
        if (!btn) return;
        const type = btn.getAttribute('data-type');
        if (btn.hasAttribute('disabled')) {return;
        }
        
        socket.emit('upgradeTurret', { type });
      });
      el._turretDelegation = true;}
  } catch(e) { console.error('[UI] turret delegation error', e); }

  // --- Upgrades Tourelles (3 slots, même design) ---
  const turretDefs = [
      
    { type:'G', name:'Big-tourelle +Dégâts',  color:'#b48cff', border:'#2b1b3a', basePrice:10000, scale:1.2 },
    { type:'T', name:'Tourelle +Dégâts',      color:'#ff3b3b', border:'#2b0b0b', basePrice:2000, scale:1.3 },
    { type:'t', name:'Mini-tourelle +Dégâts', color:'#3aa6ff', border:'#0b2436', basePrice:500,  scale:1.3 }
  

  ];
  try { turretDefs.forEach(td => {
    const lvl = (myTurretUp && (myTurretUp[td.type]||0)) || 0;
    const next = lvl + 1;
    const price = Math.round(td.basePrice * Math.pow(td.scale, lvl));
    const dmgNow = computeTurretDamageDisplay(td.type);
    // simulate next damage (preview)
    const tmp = (myTurretUp && myTurretUp[td.type]) || 0;
    myTurretUp[td.type] = (myTurretUp[td.type]||0) + 1;
    const dmgNext = computeTurretDamageDisplay(td.type);
    myTurretUp[td.type] = tmp;

    const disabled = _money < price;
    

    el.innerHTML += `
      <div class="shop-upg-item" style="display:flex; align-items:center; gap:14px; margin:10px 0; background:#222a; border-radius:10px; padding:12px 14px 10px 7px;">
        <div style="width:44px; height:44px; border-radius:10px; display:flex; align-items:center; justify-content:center; border:2px solid ${td.border}; background:${td.color}22;">
          <div style="width:18px; height:18px; background:${td.color}; border:2px solid ${td.border}; border-radius:3px;"></div>
        </div>
        <div style="flex:1;">
          <div style="font-size:18px;"><b>${((TRANSLATIONS[currentLang]||TRANSLATIONS["en"]).turretUpg && (TRANSLATIONS[currentLang]||TRANSLATIONS["en"]).turretUpg[td.type]) || td.name}</b></div>
          <div style="color:#9ab; font-size:13px;">${(TRANSLATIONS[currentLang]||TRANSLATIONS['en'])[td.type==='t'?'turretDescMini':(td.type==='T'?'turretDescNormal':'turretDescBig')]}<\/div>
          <div style="margin-top:6px; color:#9f9; font-size:14px;">${(TRANSLATIONS[currentLang]||TRANSLATIONS['en']).damage || 'Damage'} : <b>${dmgNow}</b> → <b>${dmgNext}</b></div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center; gap:8px;">
          <div style="display:inline-flex;align-items:center;justify-content:center;width:36px;height:24px;background:#282;color:#fff;font-weight:bold;border-radius:7px;font-size:15px;box-shadow:0 1.5px 6px #0007;border:2px solid #232;">${lvl}</div>
          <button class="btn-turret-up" data-type="${td.type}" style="min-width:64px; padding:8px 10px; border-radius:10px; border:none; background:${disabled ? '#444' : '#393'}; color:#fff; cursor:${disabled?'not-allowed':'pointer'}; opacity:${disabled?'0.5':'1'};">
            +1<br>$${price}
          </button>
        </div>
      </div>`;
  });

  // Re-bind achat upgrades tourelles (après TOUT le contenu est inséré)
  try {
    const turretBtns = el.querySelectorAll('.btn-turret-up');turretBtns.forEach(btn => {
      const type = btn.getAttribute('data-type');
      btn.onclick = async () => {  socket.emit('upgradeTurret', { type }); };
    });
  } catch(e) { console.error('[UI] late-bind turret error', e); }

} catch(e) { console.error('[UI] renderShopUpgrades turret section error', e); }

  // --- Upgrades joueur (les 5 existants) ---
  UPGRADES.forEach(upg => {
    const lvl = myUpgrades[upg.id] || 0;
    const price = getUpgradePrice(lvl + 1);
    const value = upg.getValue(upg.baseValue, lvl);
    const nextValue = upg.getValue(upg.baseValue, lvl + 1);
    const disabled = _money < price;

    let __label = getUpgText(upg,'label');
    try {
      if (upg.id === 'speed') {
        try {
          const rest = (getUpgText(upg,'label') || '').replace(/^\s*\+?\d+\s*%?\s*/,'').trim();
          __label = '+5% ' + (rest || getUpgText(upg,'statLabel') || 'Speed');
        } catch(e2) { __label = '+5% ' + (getUpgText(upg,'label') || 'Speed'); }
      } else if (upg.id === 'regen') {
        const __lvl = myUpgrades[upg.id] || 0;
        const __cur = upg.getValue(upg.baseValue, __lvl);
        const __nxt = upg.getValue(upg.baseValue, __lvl + 1);
        let __delta = __nxt - __cur;
        let __str;
        if (Math.abs(__delta) < 10) { __str = __delta.toFixed(2); }
        else if (Math.abs(__delta) < 100) { __str = __delta.toFixed(1); }
        else { __str = Math.round(__delta).toString(); }
        __str = __str.replace(/\.0+$/,'').replace(/(\.\d*[1-9])0+$/,'$1');
        const __trUnits = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']) || {}; const __unit = (__trUnits.hpShort || 'HP') + (__trUnits.perSec || '/s');
        __label = '+' + __str + ' ' + __unit;
      }
    } catch(e) { /* keep default label */ }
    

    const __trUnits2 = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']) || {};
    const __hpU = __trUnits2.hpShort || 'HP';
    const __perSec = __trUnits2.perSec || '/s';
    const __pxPerSec = (__trUnits2.pxPerSec || ('px' + __perSec));
    function __fmt(upg, v){
      if (upg.id === 'maxHp') return v + ' ' + __hpU;
      if (upg.id === 'regen') return v + ' ' + __hpU + __perSec;
      if (upg.id === 'speed') return v + ' ' + __pxPerSec;
      return (upg.format ? upg.format(v) : v);
    }
    const fmtCur = __fmt(upg, value);
    const fmtNext = __fmt(upg, nextValue);
el.innerHTML += `
      <div style="display:flex; align-items:center; gap:14px; margin-bottom:19px; background:#222a; border-radius:10px; padding:12px 14px 10px 7px;">
        <div style="flex:1;">
          <div style="font-size:18px;"><b>${__label}</b></div>
          <div style="font-size:14px; color:#fffa; margin-bottom:3px;">${getUpgText(upg,'desc')}</div>
          <div style="font-size:15px; color:#bcffa8;">
            ${getUpgText(upg,'statLabel')} : <b>${fmtCur}</b>
            <span style="color:#8f8; font-size:14px; margin-left:7px;">→ ${fmtNext}</span>
          </div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center; gap:8px;"><div style="display:inline-flex;align-items:center;justify-content:center;width:36px;height:24px;background:#282;color:#fff;font-weight:bold;border-radius:7px;font-size:15px;box-shadow:0 1.5px 6px #0007;border:2px solid #232;">${lvl}</div>
        <button
          style="font-size:16px;background:${disabled ? '#444' : '#393'};color:#fff;border:none;border-radius:7px;padding:7px 18px;box-shadow:0 2px 8px #0004;cursor:${disabled ? 'not-allowed' : 'pointer'};opacity:${disabled ? '0.5' : '1'};margin-left:8px;transition: background 0.16s;"
          data-upgid="${upg.id}" ${disabled?'disabled':''} ${disabled ? "disabled" : ""}>
          +1<br>$${price}
        </button></div>
      </div>
    `;
  });

  // Bind achat upgrades joueur
  el.querySelectorAll('button[data-upgid]').forEach(btn => {
    const upgId = btn.getAttribute('data-upgid');
    btn.onclick = () => socket.emit('upgradeBuy', { upgId });
  });
}

	shopBtn.onclick = async () => {
	  renderShopUpgrades();
	  shopModal.style.display = 'block';
	  // Recalage à l’ouverture (tailles DOM connues)
	  positionShopUI();
	};

	shopClose.onclick = async () => {
	  shopModal.style.display = 'none';
	};

	// (optionnel, fermer si on clique dehors la fenêtre)
	shopModal.addEventListener('mousedown', function(e) {
	  if (e.target === shopModal) shopModal.style.display = 'none';
	});

    updateUITexts();
    drawHUD();

    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'p' && myPseudo === 'Myg') {
        socket.emit('killAllZombies');
      }
      if (e.key.toLowerCase() === 'o' && myPseudo === 'Myg') {
        socket.emit('giveMillion');
      }
      if (e.key.toLowerCase() === 'm' && myPseudo === 'Myg') {
        socket.emit('skipRound');
      }
    });
	
	// --- REAFFICHER LES JOYSTICKS + MAJ ZOOM SUR MOBILE APRÈS CHANGEMENT D'ORIENTATION ---
	if (isMobileDevice) {
	  window.addEventListener('resize', () => {
		updateRenderScale();
		setTimeout(() => { setupJoysticks(); positionShopUI(); }, 200);
	  });
	  window.addEventListener('orientationchange', () => {
		updateRenderScale();
		setTimeout(() => { setupJoysticks(); positionShopUI(); }, 200);
	  });
	}
(() => {
  const container = document.getElementById('mobile-build');
  if (!container) return;

  const buttons = container.querySelectorAll('.mb-btn');

  function setBuildMode(type) {
    // Toggle si on reclique le même type
    if (buildMode === type) {
      buildMode = null;
      buildHover = { tx: -1, ty: -1 };
      try { document.body.dataset.buildMode = ''; } catch(_) {};
      try { document.body.dataset.buildMode = ''; } catch(_) {};
      try { updateBuildTilesState(); } catch(_) {};
      try { updateBuildTilesState(); } catch(_) {};
      return;
    }

    // Vérif argent (évite de passer en mode si pas assez d'argent)
    const price = (STRUCTURE_PRICES && STRUCTURE_PRICES[type]) ?? Infinity;
    if (myMoney < price) {
      if (navigator.vibrate) try { navigator.vibrate(60); } catch {}
      return;
    }

    buildMode = type;
    // reset survol
    buildHover = { tx: -1, ty: -1 };
  }

  function handleTap(type, e) {
    if (e) { e.preventDefault(); e.stopPropagation(); }
    setBuildMode(type);
  }

  buttons.forEach(btn => {
    const type = btn.getAttribute('data-type');
    // Click / Pointer / Touch : on capte tous les cas
    btn.addEventListener('click',       e => handleTap(type, e));
    btn.addEventListener('pointerdown', e => handleTap(type, e), { passive: false });
    btn.addEventListener('touchstart',  e => handleTap(type, e), { passive: false });
  });
})();
	
  

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;

// ===== New lobby buttons & manual lobby logic =====
(function(){
  const btnJoinList = document.getElementById('btnJoinLobbyList');
  const btnCreate = document.getElementById('btnCreateLobby');
  const manualPanel = document.getElementById('manualLobbyPanel');
  const manualPlayers = document.getElementById('manualLobbyPlayers');
  const btnBackManual = document.getElementById('btnBackFromManual');
  const listPanel = document.getElementById('joinLobbyPanel');
  const lobbiesList = document.getElementById('lobbiesList');
  const btnBackList = document.getElementById('btnBackFromList');
  
  // Control Start button visibility based on hostId
  // Control Start button visibility based on hostId
  // Control Start button visibility based on hostId
  socket.on('lobbyUpdate', function(data){
    try {
      const isHost = !!(data && data.hostId && socket && socket.id && data.hostId === socket.id);
      const btn = document.getElementById('btnStartManual');
      if (btn) btn.style.display = isHost ? 'inline-block' : 'none';
    } catch(e){}
    try { const t = document.getElementById('manualLobbyTitle'); if (t && data && data.manual) { t.textContent = ( (TRANSLATIONS[currentLang]&&TRANSLATIONS[currentLang].lobby) ? (TRANSLATIONS[currentLang].lobby+' #') : 'Lobby #') + (data.id || '?'); } } catch(e){}
    try { if (manualPanel && manualPanel.style.display !== 'none') renderManualPlayers(); } catch(e){}
  
  try {
    window.lobbyData = data;
    if (data && data.manual && !data.started && data.hostId) {
      var players = (data.players||{});
      if (!players[data.hostId]) { try{ showMain(); window.lobbyJoined = false; if (pseudoInput){ pseudoInput.disabled=false; if(window.myPseudo) pseudoInput.value=window.myPseudo; } try{ updateButtonsDisabled(); }catch(_){}}catch(_){ } }
    }
  } catch(e){}});
const btnRefreshLobbies = document.getElementById('btnRefreshLobbies');

  let listInterval = null;
  function showMain() {
    try { clearInterval(listInterval); listInterval = null; } catch(_){}
    try { updateButtonsDisabled(); } catch(_){}
    try { manualPanel.style.display='none'; listPanel.style.display='none'; } catch(_){}
    manualPanel.style.display = 'none';
    listPanel.style.display = 'none';
    try{ if (pseudoInput) { pseudoInput.style.display = ''; if (window.myPseudo && !pseudoInput.value) pseudoInput.value = window.myPseudo; } }catch(_){}
  }
  function showManual(){
    manualPanel.style.display = 'block';
    listPanel.style.display = 'none';
    try{ if (pseudoInput) pseudoInput.style.display = 'none'; }catch(_){}
    try{ if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); }catch(_){}
  }
  function showList(){
    manualPanel.style.display = 'none';
    listPanel.style.display = 'block';
    try{ if (pseudoInput) pseudoInput.style.display = 'none'; }catch(_){}
  }

  function updateButtonsDisabled() {
    const hasPseudo = !!(pseudoInput && pseudoInput.value.trim());
    // Robust in-lobby check: either the global flag is set OR the manual lobby panel is visible
    const inLobby = !!(window.lobbyJoined || (manualPanel && manualPanel.style && manualPanel.style.display === 'block'));
    const shouldDisable = !hasPseudo || inLobby;

    if (btnJoinList) btnJoinList.disabled = shouldDisable;
    if (btnCreate) btnCreate.disabled = shouldDisable;
    if (lobbyJoin) if (lobbyJoin) lobbyJoin.disabled = shouldDisable;
    // Also gray out Ladder and auth buttons when in a lobby
try {
  var _ladder = document.getElementById('btnLadder');
  if (_ladder) _ladder.disabled = shouldDisable;
  var _login = document.getElementById('btnLogin');
  if (_login) _login.disabled = inLobby;
  var _signup = document.getElementById('btnSignup');
  if (_signup) _signup.disabled = inLobby;
  var _settings = document.getElementById('btnSettings');
  if (_settings) _settings.disabled = inLobby;
  var _logout = document.getElementById('btnLogout');
  if (_logout) _logout.disabled = inLobby;
  var _shop = document.getElementById('btnAccountShop');
  if (_shop) _shop.disabled = shouldDisable;
} catch(_){}

    // Disable chat 'Send' when no pseudo
try {
  var _chatSend = document.getElementById('chatSend');
  if (_chatSend) _chatSend.disabled = !hasPseudo;
} catch(_){}
  }
  if (pseudoInput) {
    pseudoInput.addEventListener('input', updateButtonsDisabled, { passive: true });
    setTimeout(updateButtonsDisabled, 0);
    // === Robust nickname sync & uniqueness enforcement (client-side wiring) ===
    (function(){
      var __lastAcceptedPseudo = (window.myPseudo || '');
      function applyAcceptedPseudo(p){
        __lastAcceptedPseudo = p || '';
        window.myPseudo = __lastAcceptedPseudo;
        try { localStorage.setItem('zombi_pseudo', __lastAcceptedPseudo); } catch(_){}
      }
      try {
        if (window.socket) {
          window.socket.on('lobbyUpdate', function(data){
            try {
              var meId = (window.socket && socket.id) || null;
              var me = data && data.lobby && data.lobby.players ? data.lobby.players[meId] : null;
              if (me && typeof me.pseudo === 'string') {
                applyAcceptedPseudo(me.pseudo);
                if (window.pseudoInput && document.activeElement !== window.pseudoInput) { try { window.pseudoInput.value = me.pseudo; } catch(_){ } }
              }
            } catch(_){}
          });
        }
      } catch(_){}
      function sendRename(){
        try {
          if (!window.pseudoInput) return;
          var p = (window.pseudoInput.value || '').trim();
          if (!p) return;
          if (!(window.socket && socket.connected)) return;
          try { socket.emit('renamePseudo', { pseudo: p }); } catch(_){}
        } catch(_){}
      }
      if (window.pseudoInput) {
        // Trigger rename ONLY when the user finished typing: on blur or Enter
        window.pseudoInput.addEventListener('blur', function(){ sendRename(); }, { passive: true });
        window.pseudoInput.addEventListener('keydown', function(e){
          try {
            if (e && (e.key === 'Enter' || e.keyCode === 13)) { e.preventDefault(); sendRename(); }
          } catch(_){}
        }, { passive: false });
      }
      try {
        if (window.socket) {
          if (window.socket.off) window.socket.off('renameResult');
          window.socket.on('renameResult', function(res){
            try {
              if (res && res.ok && res.pseudo) {
                applyAcceptedPseudo(res.pseudo);
                if (window.pseudoInput && document.activeElement !== window.pseudoInput) { try { window.pseudoInput.value = res.pseudo; } catch(_){ } }
              } else if (res && (res.reason === 'pseudo_taken' || res.reason === 'reserved')) {
  var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
  if (res.reason === 'reserved') { showTopMessage(tr.reservedName || 'This nickname is reserved by an account. Choose another one.'); } else { __alertPseudoTaken(); 
            if (window.pseudoInput) {
              try { window.pseudoInput.value = ''; } catch(_){ }
              try { window.pseudoInput.style.background = '#3b0000'; setTimeout(function(){ try { window.pseudoInput.style.background = ''; } catch(_){ } }, 450); } catch(_){ }
            }
}

                if (window.pseudoInput) {
                  if (res && res.reason === 'reserved') {
                    window.pseudoInput.value = '';
                  } else {
                    window.pseudoInput.value = __lastAcceptedPseudo || '';
                  }
                  window.pseudoInput.style.background = '#3b0000';
                  setTimeout(function(){ try { window.pseudoInput.style.background = ''; 
} catch(_){ } }, 450);
                }
                window.myPseudo = __lastAcceptedPseudo || '';
                try { localStorage.setItem('zombi_pseudo', window.myPseudo); } catch(_){}
              }
            } catch(_){}
          });
}
      } catch(_){}
    })();

  }
  if (window) window.updateButtonsDisabled = updateButtonsDisabled;
  // Load persisted pseudo from localStorage
  try {
    var savedP = localStorage.getItem('zombi_pseudo');
    if (savedP && pseudoInput && !pseudoInput.value) {
      pseudoInput.value = savedP;
      myPseudo = savedP; window.myPseudo = savedP;
      try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){}
    }
  } catch(_){}

  
if (btnCreate) {
    btnCreate.addEventListener('click', async function(){
      try {
        if (!window.pseudoInput) window.pseudoInput = document.getElementById('pseudoInput');
        const hasPseudo = !!(window.pseudoInput && window.pseudoInput.value && window.pseudoInput.value.trim());
        if (!hasPseudo || btnCreate.disabled) {
          try { if (window.pseudoInput && !window.pseudoInput.value) window.pseudoInput.focus(); } catch(_) {}
          return;
        }
        const p = window.pseudoInput.value.trim();
        myPseudo = p; window.myPseudo = p;
        // Optimistically switch to manual lobby UI to avoid any flicker or crash
        try {
          window.lobbyJoined = true;
          showManual();
          try { renderManualPlayers(); } catch(_) {}
          try { updateButtonsDisabled(); } catch(_) {}
        } catch(_){}
        if (!window.socket || typeof socket.emit !== 'function') { console.error('Socket not ready on createLobby'); return; }
        btnCreate.disabled = true;
        socket.emit('createLobby', p, function(res){
          try {
            if (!res || !res.ok) {
              if (res && res.reason === 'pseudo_taken') {
                var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
                __alertPseudoTaken();
              }
              btnCreate.disabled = false; window.lobbyJoined = false; showMain(); return;
            }
                        try {
              if (res && res.ok && res.gameId && res.hostToken) {
                try { localStorage.setItem('zombi_host_game', String(res.gameId)); } catch(_){}
                try { localStorage.setItem('zombi_host_token', String(res.hostToken)); } catch(_){}
              }
            } catch(_){}
// Server will follow up with lobbyUpdate
          } catch(err) {
            console.error('createLobby callback error', err);
} finally {
            try { if (typeof updateButtonsDisabled==='function') updateButtonsDisabled(); } catch(_) {}
          }
        });
      } catch(err) {
        console.error('Create lobby click error', err);
      }
    }, { passive: true });
  }

  if (btnJoinList) {
    btnJoinList.addEventListener('click', async function(){
      
      if (!pseudoInput.value.trim() || btnJoinList.disabled) return;
      var p = String(pseudoInput.value || '').trim();
      // Server-side check identical to Create lobby semantics
      try {
        btnJoinList.disabled = true;
        if (window.socket && typeof socket.emit === 'function') {
          socket.emit('renamePseudo', p, function(res){
            try {
              if (!res || res.ok) {
                // proceed to open the list
                showList();
                requestLobbies();
                clearInterval(listInterval);
                listInterval = setInterval(requestLobbies, 2000);
              } else if (res.reason === 'pseudo_taken' || res.reason === 'reserved') {
                var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
                if (res.reason === 'reserved') {
                  showTopMessage(tr.reservedName || 'This nickname is reserved by an account. Choose another one.');
                } else {
                  if (typeof __alertPseudoTaken === 'function') __alertPseudoTaken();
                  else showTopMessage(tr.pseudoTaken || 'Nickname already in use.');
                }
              } else {
                // Unexpected error -> do nothing special, just open list
                showList();
                requestLobbies();
                clearInterval(listInterval);
                listInterval = setInterval(requestLobbies, 2000);
              }
            } finally {
              btnJoinList.disabled = false;
            }
          });
          return;
        }
      } catch(_){ btnJoinList.disabled = false; }
      // Fallback if socket not ready
      showList();
      requestLobbies();
      clearInterval(listInterval);
      listInterval = setInterval(requestLobbies, 2000);
}, { passive: true });
  }

  if (btnBackList) {
    btnBackList.addEventListener('click', async function(){
      showMain();
      try{
        if (pseudoInput){
          // Restore pseudo field state depending on login/join status
          var loggedIn = false;
          try {
            var btnLg = document.getElementById('btnLogout');
            loggedIn = !!(btnLg && btnLg.style.display !== 'none');
          } catch(_){ }
          pseudoInput.disabled = false;
          if (loggedIn || window.lobbyJoined) {
            pseudoInput.readOnly = true;
            try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }
          } else {
            pseudoInput.readOnly = false;
            try { pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }
          }
          if (window.myPseudo) pseudoInput.value = window.myPseudo;
        }
      }catch(_){ }
      clearInterval(listInterval);
      listInterval = null;
      try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){ }
      try{ if (window.enforcePseudoLock) window.enforcePseudoLock(); }catch(_){ }
    }, { passive: true });
  }

  if (btnBackManual) {
    btnBackManual.addEventListener('click', async function(){
      try {
        const isHost = !!(window.lobbyData && window.lobbyData.hostId && socket && socket.id && window.lobbyData.hostId === socket.id);
        if (isHost) {
          socket.emit('hostBackManual', function(res){});
        } else {
          socket.emit('leaveLobby');
        }
      } catch(e){}
      showMain();
      window.lobbyJoined = false;
      try{ if (pseudoInput){ pseudoInput.disabled = false; 
          try { pseudoInput.readOnly = false; pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }if (window.myPseudo) pseudoInput.value = window.myPseudo; } }catch(_){}
      try { updateButtonsDisabled(); } catch(_) {}
    }, { passive: true });
  }
if (btnStartManual) {
    btnStartManual.addEventListener('click', async function(){
      ensureMySkinLoaded().then(() => socket.emit('startManualLobby', function(res){
        // if not host, ignore; server will no-op
      }));
    }, { passive: true });
  }

  function requestLobbies() {
    socket.emit('requestLobbies');
  }
  

socket.on('lobbiesList', function(list){
    if (!Array.isArray(list)) list = [];
    lobbiesList.innerHTML = '';
    if (!list.length) {
      const empty = document.createElement('div');
      empty.textContent = (TRANSLATIONS[currentLang] && TRANSLATIONS[currentLang].noLobbyAvailable) || 'No lobby available.';
      empty.style.color = '#ccc';
      empty.style.textAlign = 'center';
      lobbiesList.appendChild(empty);
      return;
    }
    list.forEach(lob => {
      const item = document.createElement('div');
      item.style.background = 'rgba(0,0,0,0.3)';
      item.style.border = '1px solid rgba(255,255,255,0.1)';
      item.style.borderRadius = '8px';
      item.style.padding = '8px';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      const names = (lob.players || []).join(', ');
      item.innerHTML = '<div><b>Lobby #' + lob.id + '</b> • (' + lob.count + '/' + (lob.max||6) + ') — ' + names + '</div>';
      const btn = document.createElement('button');
      btn.textContent = (TRANSLATIONS[currentLang] && (TRANSLATIONS[currentLang].joinAction || TRANSLATIONS[currentLang].join)) || 'Join';
      btn.style.padding = '6px 12px';
      btn.style.background = '#3fa33f';
      btn.style.color = '#fff';
      btn.style.border = 'none';
      btn.style.borderRadius = '6px';
      btn.style.cursor = 'pointer';
      
      btn.onclick = function(){
        var raw = (pseudoInput && pseudoInput.value) ? pseudoInput.value : '';
        var p = (raw || '').trim().substring(0, 10).replace(/[^a-zA-Z0-9]/g, '');
        if (!p) {
          try { pseudoInput && pseudoInput.focus(); pseudoInput && (pseudoInput.style.background='#fdd'); setTimeout(function(){ try{ pseudoInput.style.background=''; }catch(_){ } }, 600); } catch(_){}
          return;
        }
        // Client-side pre-check against current lobby roster to prevent duplicates
        try {
          var list = Array.isArray(lob.players) ? lob.players : [];
          var taken = list.some(function(n){ return String(n||'').toLowerCase() === p.toLowerCase(); });
          if (taken) {
            try { var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            __alertPseudoTaken();
          } catch(_){}
          return;
          }
        } catch(_){}
        ensureMySkinLoaded().then(() => socket.emit('joinLobbyById', { gameId: lob.id, pseudo: p }, function(res){
          if (res && res.ok) {
            myPseudo = p; window.myPseudo = p;
            window.lobbyJoined = true;
            showManual();

            try {
              window.lobbyData = window.lobbyData || {};
              window.lobbyData.manual = true;
              window.lobbyData.started = false;
              if (typeof window.lobbyData.max !== 'number' || !window.lobbyData.max) window.lobbyData.max = 6;
              try {
                if (!window.lobbyData.players || typeof window.lobbyData.players !== 'object') window.lobbyData.players = {};
                if (window.socket && socket.id) window.lobbyData.players[socket.id] = { pseudo: window.myPseudo || p };
              } catch(_) {}
              if (!Number.isFinite(window.lobbyData.count) || window.lobbyData.count < 1) window.lobbyData.count = 1;
              if (typeof updateLobbyTexts === 'function') updateLobbyTexts();
            } catch(_){}

            renderManualPlayers();
            try { updateButtonsDisabled(); } catch(_) {}
          } else if (res && (res.reason === 'pseudo_taken' || res.reason === 'reserved')) {
  var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
  if (res.reason === 'reserved') { showTopMessage(tr.reservedName || 'This nickname is reserved by an account. Choose another one.'); } else { __alertPseudoTaken(); 
            if (window.pseudoInput) {
              try { window.pseudoInput.value = ''; } catch(_){ }
              try { window.pseudoInput.style.background = '#3b0000'; setTimeout(function(){ try { window.pseudoInput.style.background = ''; } catch(_){ } }, 450); } catch(_){ }
            }
}

            try { var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {
};
            __alertPseudoTaken(); } catch(_){}
          }
        }));
      };

      item.appendChild(btn);
      lobbiesList.appendChild(item);
    });
  });

function renderManualPlayers() {
  try {
    const playersObj = (typeof lobbyData === 'object' && lobbyData && lobbyData.players) ? lobbyData.players : {};
    const entries = Object.entries(playersObj); // [ [id, {pseudo, ready}],  ]
    const emptyLabel = (TRANSLATIONS[currentLang] && TRANSLATIONS[currentLang].emptySlot) || 'empty';
    const isHost = !!(window.lobbyData && window.lobbyData.hostId && window.socket && window.socket.id && window.lobbyData.hostId === socket.id);
    const tr = (window.TRANSLATIONS && (TRANSLATIONS[currentLang] || TRANSLATIONS['en'])) || {};
    const kickTxt = tr.kick || 'Kick';

    // Build up to 6 slots
    let cells = [];
    for (let i = 0; i < 6; i++) {
      if (i < entries.length) {
        const sid = entries[i][0];
        const p = entries[i][1] || {};
        const name = (p && p.pseudo) ? p.pseudo : '';
        const canKick = isHost && sid !== socket.id && sid !== "host"; // host cannot kick self
        let inner = '<div style="display:flex;align-items:center;gap:8px;">'
                    + '<span>' + (name || '') + '</span>' + (((window.lobbyData && window.lobbyData.hostId === sid) || (!window.lobbyData?.hostId && entries && entries.length === 1 && window.socket && sid === window.socket.id)) ? '<span class="host-crown" title="Host" aria-label="Host" style="margin-left:6px">👑</span>' : '' )+ (canKick ? '<button class="kick-btn" onclick="__kickBtn(this,event)" type="button" data-target="' + sid + '" style="padding:4px 8px;font-size:12px;cursor:pointer;background:#b00020;color:#fff;border:none;border-radius:4px;margin-left:auto;">'+kickTxt+'</button>' : '')
                    + '</div>';
        cells.push({ inner, empty:false });
      } else {
        cells.push({ inner: emptyLabel, empty:true });
      }
    }

    let html = '';
    html += '<table style="margin:8px auto;border-collapse:separate;border-spacing:6px;">';
    for (let r = 0; r < 2; r++) {
      html += '<tr>';
      for (let c = 0; c < 3; c++) {
        const idx = r * 3 + c;
        const cell = cells[idx];
        var bg = cell.empty ? 'rgba(255,255,255,0.06)' : 'rgba(72,199,73,0.18)';
        var border = '1px solid rgba(255,255,255,0.12)';
        var color = cell.empty ? '#bbb' : '#fff';
        html += '<td style="min-width:120px;padding:10px 14px;background:'+bg+';border:'+border+';border-radius:8px;text-align:left;color:'+color+';">' + cell.inner + '</td>';
      }
      html += '</tr>';
    }
    html += '</table>';
    const container = (typeof manualPlayers !== 'undefined' && manualPlayers) ? manualPlayers : document.getElementById('manualLobbyPlayers');
    if (container) container.innerHTML = html;
  } catch(e) {}

    // Robust: delegate click for Kick buttons (global, works across re-renders)
    try { if (typeof translateEmptySlotsInManualLobby === 'function') translateEmptySlotsInManualLobby(); } catch(_){}
}  function safe(fn){ try{ fn(); }catch(e){} }

  // Hide legacy timer/status elements globally
  safe(function(){
    var t = document.getElementById('lobbyTimer'); if (t){ t.style.display='none'; t.textContent=''; }
    var s = document.getElementById('lobbyStatus'); if (s){ s.style.display='none'; s.textContent=''; }
  });

  // Replace updateLobbyTexts to remove timer/waiting and only show players in manual lobbies
  window.updateLobbyTexts = function(){
  try {
    var tr = (window.TRANSLATIONS && (window.TRANSLATIONS[window.currentLang] || window.TRANSLATIONS['en'])) || {};
    var manualPanel = document.getElementById('manualLobbyPanel');
    var lobbyPlayersEl = document.getElementById('lobbyPlayers');
    var showPlayers = manualPanel && manualPanel.style.display !== 'none';
    var max = 6, count = 0;
    try { max = Number((window.lobbyData && window.lobbyData.max) || 6) || 6; } catch(_){ max = 6; }
    try {
      if (window.lobbyData && window.lobbyData.players && typeof window.lobbyData.players === 'object') {
        count = Object.keys(window.lobbyData.players).length;
      } else if (window.lobbyData && Array.isArray(window.lobbyData.players)) {
        count = window.lobbyData.players.length;
      } else if (typeof window.lobbyData?.count !== 'undefined') {
        count = Number(window.lobbyData.count) || 0;
      }
    } catch(_){ count = Number(window.lobbyData && window.lobbyData.count) || 0; }
    if (lobbyPlayersEl) lobbyPlayersEl.textContent = showPlayers ? ((tr.playersInGame || 'Players in game') + ' : ' + count + '/' + max) : '';
    // Hide legacy timer/status unconditionally in this global updater
    try { var t = document.getElementById('lobbyTimer'); if (t){ t.style.display='none'; t.textContent=''; } } catch(_){}
    try { var s = document.getElementById('lobbyStatus'); if (s){ s.style.display='none'; s.textContent=''; } } catch(_){}
  } catch(_){}
};

  // Wrap updateUITexts to force the "Join" label (no waiting state on main)
  if (typeof window.updateUITexts === 'function'){
    var _updateUITexts = window.updateUITexts;
    window.updateUITexts = function(){
      try { _updateUITexts.apply(this, arguments); } catch(_){}
      var tr = (window.TRANSLATIONS && window.TRANSLATIONS[window.currentLang]) || (window.TRANSLATIONS && window.TRANSLATIONS['en']) || {};
      var lobbyJoin = document.getElementById("lobbyJoin") || window.lobbyJoin;
      if (lobbyJoin) lobbyJoin.textContent = tr.join || 'Join';

// Keep the Join button localized even if other code changes its text
(function(){
  const el = document.getElementById('lobbyJoin');
  if (!el) return;
  const ensure = () => {
    const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
    const expected = (tr.join || 'Join');
    if (el.textContent !== expected) el.textContent = expected;
  };
  const mo = new MutationObserver(ensure);
  mo.observe(el, {characterData:true, childList:true, subtree:true});
  ensure();
})();
    };
  }

  // Ensure Replay returns to lobby (reload)
  safe(function(){
    var btnReplay = document.getElementById('btnReplay');
    if (btnReplay) btnReplay.onclick = function(){ try { location.reload(); } catch(_){} };
  });

  // Override main Join click to start solo immediately (server handles launch)
  safe(function(){
    var lobbyJoin = document.getElementById("lobbyJoin") || window.lobbyJoin;
    var pseudoInput = document.getElementById('pseudoInput');
    if (lobbyJoin){
      if (lobbyJoin) lobbyJoin.onclick = function(){
        if (!pseudoInput || !pseudoInput.value || !pseudoInput.value.trim()){
          if (pseudoInput){ pseudoInput.focus(); pseudoInput.style.background = '#fdd'; setTimeout(function(){ pseudoInput.style.background=''; }, 600); }
          return;
        }
        ensureMySkinLoaded().then(() => socket.emit('setPseudoAndReady', (pseudoInput && pseudoInput.value || '').trim())); try { localStorage.setItem('zombi_last_pseudo', String((pseudoInput && pseudoInput.value || '').trim())); } catch(_) {}
        window.lobbyJoined = true;
        try { if (lobbyJoin) lobbyJoin.disabled = true; if (pseudoInput) pseudoInput.readOnly = true; 
          try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }} catch(_){}
        try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){}
      };
    }
  });

  // Clear players line on main load until manual panel is visible
  safe(function(){ var p = document.getElementById('lobbyPlayers'); if (p) p.textContent=''; });


  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
(function(){
  function setVersionBox(){
    try{
      var langRaw = (typeof window.currentLang === 'string' && window.currentLang)
                 || (typeof currentLang === 'string' && currentLang)
                 || ((navigator.language||'en').slice(0,2));
      // normalize aliases coming from browser locales
      var alias = { ja:'jp', zh:'cn', ko:'kr' };
      var lang = alias[langRaw] || langRaw;
      var tr = (window.TRANSLATIONS && (TRANSLATIONS[lang]||TRANSLATIONS['en'])) || {};
      var el = document.getElementById('versionBox');
      if (!el) return;
      var ver = (typeof window.GAME_VERSION==='string' ? window.GAME_VERSION : '1.0.0');
      var fallbackTpl = {
        en:'Version {v} by Myg',
        fr:'Version {v} par Myg',
        es:'Versión {v} por Myg',
        pt:'Versão {v} por Myg',
        de:'Version {v} von Myg',
        ru:'Версия {v} от Myg',
        cn:'版本 {v} 由 Myg',
        jp:'バージョン {v}（Myg）',
        pl:'Wersja {v} od Myg',
        kr:'버전 {v} - Myg'
      }[lang] || 'Version {v} by Myg';
      var tpl = tr.versionBy || fallbackTpl;
      el.textContent = tpl.replace('{v}', ver);
    }catch(_){}
}
  // First display
  setVersionBox();
  // Retry hook once DOM and all scripts are loaded (ensures updateUITexts exists)
  function tryHook(){
    if (typeof window.updateUITexts === 'function') {
      var _u = window.updateUITexts;
      window.updateUITexts = function(){
        try { _u.apply(this, arguments); } catch(_){}
        setVersionBox();
      };
    } else {
      // if not yet defined, try again on next tick
      setTimeout(tryHook, 50);
    }
  }
  tryHook();
  // Also refresh on visibility change just in case
  document.addEventListener('visibilitychange', function(){ if(!document.hidden) setVersionBox(); }, {passive:true});
  window.addEventListener('resize', setVersionBox, {passive:true});
  document.addEventListener('DOMContentLoaded', function(){ try{ setVersionBox(); }catch(_){}} , {once:true, passive:true});
  window.setVersionBox = setVersionBox;



try { setVersionBox(); } catch(_){}
})();
</script>
<script>
(function(){
  function setWorkerBox(){
    try {
      var el = document.getElementById('workerBox');
      if (!el) return;
      var id = (window.__workerId|0);
      if (!id) { el.textContent = ''; el.style.display='none'; return; }
      el.style.display = 'block';
      var langRaw = (typeof window.currentLang === 'string' && window.currentLang)
                 || (typeof currentLang === 'string' && currentLang)
                 || ((navigator.language||'en').slice(0,2));
      var alias = { ja:'jp', zh:'cn', ko:'kr' };
      var lang = alias[langRaw] || langRaw;
      var tr = (window.TRANSLATIONS && (TRANSLATIONS[lang]||TRANSLATIONS['en'])) || {};
      var tpl = tr.serverLabel || 'Server {n}';
      el.textContent = tpl.replace('{n}', id);
    } catch(_){}
  }
  window.setWorkerBox = setWorkerBox;
  try { setWorkerBox(); } catch(_){}

  // Ensure we never miss workerInfo even if emitted before our listener:
  (function(){
    function attachWorkerListener(sock){
      try{
        if(!sock || sock.__workerAttached) return;
        sock.__workerAttached = true;
        sock.on && sock.on('workerInfo', function(info){
          try { window.__workerId = (info && info.id)|0; } catch(_){ window.__workerId = 0; }
          try { setWorkerBox(); } catch(_){}
        });
        // Fallback: ask again after connect, if server supports it
        try {
          sock.on && sock.on('connect', function(){
            try {
              if (!(window.__workerId|0) && typeof sock.emit === 'function') {
                sock.emit('requestWorkerInfo'); // server may optionally handle this
              }
            } catch(_){}
          });
        } catch(_){}
      }catch(_){}
    }
    try { attachWorkerListener(window.socket); } catch(_){}
    try {
      if (window.io && !window.__io_patched_for_worker) {
        var orig = window.io;
        function patched(){
          var s = orig.apply(this, arguments);
          try { attachWorkerListener(s); } catch(_){}
          return s;
        }
        try { for (var k in orig) { patched[k] = orig[k]; } } catch(_){}
        window.io = patched; window.__io_patched_for_worker = true;
      }
    } catch(_){}
  })();

  // Listen to server marker
      try {
        if (window.socket && typeof socket.on === 'function') {
          socket.on('workerInfo', function(info){
            try { window.__workerId = (info && info.id)|0; } catch(_){ window.__workerId = 0; }
            try { setWorkerBox(); } catch(_){}

  // Ensure we never miss workerInfo even if emitted before our listener:
  (function(){
    function attachWorkerListener(sock){
      try{
        if(!sock || sock.__workerAttached) return;
        sock.__workerAttached = true;
        sock.on && sock.on('workerInfo', function(info){
          try { window.__workerId = (info && info.id)|0; } catch(_){ window.__workerId = 0; }
          try { setWorkerBox(); } catch(_){}
        });
        // Fallback: ask again after connect, if server supports it
        try {
          sock.on && sock.on('connect', function(){
            try {
              if (!(window.__workerId|0) && typeof sock.emit === 'function') {
                sock.emit('requestWorkerInfo'); // server may optionally handle this
              }
            } catch(_){}
          });
        } catch(_){}
      }catch(_){}
    }
    try { attachWorkerListener(window.socket); } catch(_){}
    try {
      if (window.io && !window.__io_patched_for_worker) {
        var orig = window.io;
        function patched(){
          var s = orig.apply(this, arguments);
          try { attachWorkerListener(s); } catch(_){}
          return s;
        }
        try { for (var k in orig) { patched[k] = orig[k]; } } catch(_){}
        window.io = patched; window.__io_patched_for_worker = true;
      }
    } catch(_){}
  })();

          });
        }
      } catch(_){}
      // Refresh on visibility change & resize (matches version box behavior)
  document.addEventListener('visibilitychange', function(){ if(!document.hidden) setWorkerBox(); }, {passive:true});
  window.addEventListener('resize', setWorkerBox, {passive:true});
})();
</script>


  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
// --- Join lobby count badge (polling every 2s) ---
(function(){
  var openLobbyCount = 0;

  function updateJoinLobbyBtnText(){
    try {
      var btn = document.getElementById('btnJoinLobbyList');
      if (!btn) return;
      var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
      var base = tr.joinLobby || 'Join lobby';
      btn.textContent = base + ' (' + (openLobbyCount|0) + ')';
    } catch(e){}
  }

  // Hook into updateUITexts so localization is preserved and the count suffix stays
  (function hookUpdateUITexts(){
    try {
      if (typeof window.updateUITexts === 'function') {
        var _u = window.updateUITexts;
        window.updateUITexts = function(){
          try { _u.apply(this, arguments); } catch(_){}
          updateJoinLobbyBtnText();
        };
      } else {
        // if not yet defined, try again a bit later
        setTimeout(hookUpdateUITexts, 50);
      }
    } catch(e){}
  })();

  // Update the cached count whenever the server sends the lobbies list
  try {
    if (window.socket) {
      socket.on('lobbiesList', function(list){
        try { openLobbyCount = Array.isArray(list) ? list.length : 0; } catch(e){ openLobbyCount = 0; }
        updateJoinLobbyBtnText();
      });
    }
  } catch(e){}

  // Poll count every 2 seconds, but skip if the list panel is already visible (it's already polling)
  var __lobbyCountInterval = setInterval(function(){
    try {
      if (!window.socket || !socket.connected) return;
      var panel = document.getElementById('joinLobbyPanel');
      if (panel && panel.style.display === 'block') return; // join list already polling
      socket.emit('requestLobbies'); // reuse existing endpoint
    } catch(e){}
  }, 2000);

  // Clean up on unload
  window.addEventListener('beforeunload', function(){ try{ clearInterval(__lobbyCountInterval); }catch(_){}});

  // Initial paint
  updateJoinLobbyBtnText();

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
(function(){
  function setMenuUIHidden(on){ try { document.body.classList.toggle('menu-hide-ui', !!on); } catch(e){} }
  // Initially hide until game starts
  setMenuUIHidden(true);
  try {
    socket.on('lobbyUpdate', function(data){
      try { setMenuUIHidden(!(data && data.started)); } catch(_){}
    });
    socket.on('gameStarted', function(){ setMenuUIHidden(false); });
  } catch(e){}
  // In case UI functions are used elsewhere
  window.setMenuUIHidden = setMenuUIHidden;

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
(function(){
  try {
    var container = document.getElementById('manualLobbyPlayers');
    if (container) {
      container.addEventListener('click', function(ev){
        var btn = ev.target && ev.target.closest && ev.target.closest('.kick-btn');
        if (!btn) return;
        if (!window.socket) return;
        var targetId = btn.getAttribute('data-target');
            console.log('[KICK] Click sur bouton rouge → targetId=', targetId);
        if (!targetId) return;
        // Only host will see the button; server will re-check permissions
        try { socket.emit('kickPlayer', { targetId: targetId }); } catch(e){}
      });
    }
  } catch(e){}

  try {
    if (window.socket) {
      
          
          socket.on('kicked', function(info){
            
            // Ensure browser can show native dialogs immediately
            try { if (document.fullscreenElement) { document.exitFullscreen().catch(function(){}); } } catch(_){}
            try { if (document.pointerLockElement && document.exitPointerLock) { document.exitPointerLock(); } } catch(_){}
            try { var ae = document.activeElement; if (ae && ae.blur) ae.blur(); } catch(_){}
// Force back to main menu without relying on local-scope functions
            try {
              var panel = document.getElementById('manualLobbyPanel');
              if (panel) panel.style.display = 'none';
            } catch(_){}
            try {
              var listPanel = document.getElementById('joinLobbyPanel');
              if (listPanel) listPanel.style.display = 'none';
            } catch(_){}
            try { window.lobbyJoined = false; } catch(_){}
            try {
              if (window.pseudoInput) {
                pseudoInput.style.display = '';
                pseudoInput.disabled = false;
                
          try { pseudoInput.readOnly = false; pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }if (!pseudoInput.value && window.myPseudo) pseudoInput.value = window.myPseudo;
                try { pseudoInput.focus(); } catch(_){}
              }
            } catch(_){}
            try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){}
            try {
              var tr = (window.TRANSLATIONS && (TRANSLATIONS[currentLang] || TRANSLATIONS['en'])) || {};
              var wait = (info && info.until && info.until > Date.now()) ? Math.ceil((info.until - Date.now())/1000) : 30;
              var msg = (tr && tr.kickedMsg) ? tr.kickedMsg.replace('{s}', String(wait)) : ('You were kicked. You can rejoin in ~' + wait + 's.');
              try { setTimeout(function(){ showTopMessage(msg); }, 0); } catch(_){ }try { if (typeof showModal === 'function') showModal('kicked', { message: msg }); } catch(_){ }} catch(_){}
          });
}
  } catch(e){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<div id="chatPanel" role="region" aria-label="Chat">
  <div id="chatHeader">
    <div id="chatTitle">Chat</div>
    <button id="chatToggle" title="Collapse">–</button>
  </div>
  <div id="chatTabs">
    <button id="tabWorld" class="chatTab active">World chat</button>
    <button id="tabLobby" class="chatTab">Lobby chat</button>
  </div>
  <div id="chatMessages" aria-live="polite"></div>
  <div id="chatInputRow">
    <input id="chatInput" type="text" maxlength="50" placeholder="Message (max 50)" />
    <button id="chatSend">Send</button>
  </div>
</div>
<button id="chatCollapsedBtn" title="Chat">💬</button>

<script>(function(){
  const MAX_LEN = 50;
  const COOLDOWN_MS = 2000;
  let lastSent = 0;

  const CHAT_MAX_AGE_MS = 60000; // messages auto-disappear after 60s

  let currentChannel = 'world'; // 'world' | 'lobby'
  let pendingHistoryFor = null;
  const chatBuf = { world: [], lobby: [] };
  const chatSeen = { world: new Set(), lobby: new Set() };

  let inGame = false;
  let inManualLobby = false;
  let __chatBoundTo = null;
  let __chatPrevMode = null;

  function qs(id){ return document.getElementById(id); }
  const panel = qs('chatPanel');
  const toggle = qs('chatToggle');
  const title = qs('chatTitle');
  const list = qs('chatMessages');
  const input = qs('chatInput');
  const sendBtn = qs('chatSend');
  const collapsedBtn = qs('chatCollapsedBtn');
  const tabWorld = qs('tabWorld');
  const tabLobby = qs('tabLobby');

  // Mark when typing in chat to disable WASD/Arrows
  try {
    if (input && !input.__typingFlagInstalled) {
      input.__typingFlagInstalled = true;
      function __clearNavKeys(){
        try {
          var arr = ['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'];
          for (var i=0;i<arr.length;i++){ try{ keys[arr[i]] = false; }catch(_){ } }
        } catch(_){}
      }
      input.addEventListener('focus', function(){ try { window.__typingInChat = true; __clearNavKeys(); } catch(_){ } }, { passive:true });
      input.addEventListener('blur', function(){ try { window.__typingInChat = false; } catch(_){ } }, { passive:true });
    }
  } catch(_){}

  try { if (typeof window.updateButtonsDisabled === 'function') window.updateButtonsDisabled(); } catch(_){}
  // Toggle / expand handlers
  if (toggle) toggle.addEventListener('click', async function(){ setCollapsed(true); }, {passive:true});
  if (collapsedBtn) collapsedBtn.addEventListener('click', async function(){ setCollapsed(false); try{ if (window.__igChatClearNotify) window.__igChatClearNotify(); }catch(_){ } }, {passive:true});

  // -- Helper: position collapsed button above HUD (best-effort)
  function positionCollapsedBtn(){
    try{
      if (!collapsedBtn) return;
      if (!inGame) { collapsedBtn.style.bottom = '12px'; return; }

  

      var hud = document.getElementById('hudStats') || document.getElementById('hudAlive') || document.getElementById('hudMoney');
      if (hud && hud.getBoundingClientRect){
        var r = hud.getBoundingClientRect();
        var fromBottom = Math.max(12, Math.round(window.innerHeight - r.top + 12));
        collapsedBtn.style.bottom = fromBottom + 'px';
      } else {
        collapsedBtn.style.bottom = '12px';
      }
    }catch(e){}
  }

// Format timestamp as HH:MM (24h)
  function __fmtTime(ts){
    try {
      var d = new Date(typeof ts === 'number' ? ts : Date.now());
      var hh = String(d.getHours()).padStart(2,'0');
      var mm = String(d.getMinutes()).padStart(2,'0');
      return '[' + hh + ':' + mm + ']';
    } catch(_){ return ''; }
  }
  // Remove expired messages from DOM
  function __scheduleRemoval(div, ts){
    try {
      var delay = Math.max(0, CHAT_MAX_AGE_MS - (Date.now() - (ts||0)));
      if (delay <= 0) {
        if (div && div.parentNode) div.parentNode.removeChild(div);
        return;
      }
      setTimeout(function(){
        try { if (div && div.parentNode) div.parentNode.removeChild(div); } catch(_){}
      }, delay);
    } catch(_){}
  }
  // Prune old messages from buffer for a channel (keep last minute only)
  function __pruneBuf(ch){
    try {
      var cutoff = Date.now() - CHAT_MAX_AGE_MS;
      if (!chatBuf || !chatBuf[ch]) return;
      chatBuf[ch] = chatBuf[ch].filter(function(m){ return m && (m.ts||0) >= cutoff; });
    } catch(_){}
  }



  // i18n
  function applyChatI18n(){
    try{
      const tr = (window.TRANSLATIONS && (TRANSLATIONS[currentLang] || TRANSLATIONS['en'])) || {};
      title.textContent = tr.chat || 'Chat';
      tabWorld.textContent = tr.worldChat || 'World chat';
      tabLobby.textContent = tr.lobbyChat || 'Lobby chat';
      sendBtn.textContent = tr.send || 'Send';
      input.placeholder = tr.chatPlaceholder || 'Message (max 50)';
      toggle.title = tr.collapse || 'Collapse';
      collapsedBtn.title = tr.chat || 'Chat';
    }catch(e){}
  }
  applyChatI18n();
  if (typeof window.updateUITexts === 'function'){
    const _u = window.updateUITexts;
    window.updateUITexts = function(){ try{ _u.apply(this, arguments); }catch(_){}
      applyChatI18n();
    };
  }

  // Collapse/expand
  function setCollapsed(on){
    if (on){
      if (panel) panel.style.display = 'none';
      if (collapsedBtn) collapsedBtn.style.display = 'flex';
      positionCollapsedBtn();
      try { localStorage.setItem('chatCollapsed','1'); } catch(_){}
      // When collapsing the chat, also deselect the chat button in the bottom menu
      try {
        var chatBtn = document.querySelector('#inGameMenu .ig-btn[data-action="chat"]');
        if (chatBtn) chatBtn.classList.remove('active');
      } catch(_){}
    } else {
      if (panel) panel.style.display = 'flex';
      if (collapsedBtn) collapsedBtn.style.display = 'none';
      if (collapsedBtn) collapsedBtn.classList.remove('notify');
      positionCollapsedBtn();
      try { localStorage.setItem('chatCollapsed','0'); } catch(_){}
      // When expanding the chat, mark the chat button as active
      try {
        var chatBtn = document.querySelector('#inGameMenu .ig-btn[data-action="chat"]');
        if (chatBtn) chatBtn.classList.add('active');
      } catch(_){}
      try { input && input.focus(); } catch(_){}
    }
  }

  
  // Render from buffer
  
  // Render from buffer
  function renderChannel(ch){
    try{
      __pruneBuf(ch);
      chatSeen[ch] = new Set((chatBuf[ch]||[]).map(function(m){ return ((m.sid||'')+'|'+(m.text||'')+'|'+Math.floor((m.ts||0)/2000)); }));
      var arr = (chatBuf[ch]||[]);
      var cutoff = Date.now() - CHAT_MAX_AGE_MS;
      list.innerHTML = '';
      for (var i=0;i<arr.length;i++){
        var msg = arr[i];
        if (!msg || (msg.ts||0) < cutoff) continue;
        var name = (msg && msg.pseudo) ? String(msg.pseudo) : 'player';
        var text = (msg && msg.text) ? String(msg.text) : '';
        var ts = (msg && msg.ts) ? Number(msg.ts) : Date.now();

        var div = document.createElement('div');
        div.className = 'chatLine';
        div.setAttribute('data-ts', String(ts));

        var timeSpan = document.createElement('span');
        timeSpan.className = 'chatTime';
        timeSpan.textContent = __fmtTime(ts) + ' ';
        div.appendChild(timeSpan);

        var nameSpan = document.createElement('span');
        nameSpan.className = 'chatName';
        nameSpan.textContent = name + ':';
        div.appendChild(nameSpan);

        div.appendChild(document.createTextNode(' ' + text));

        list.appendChild(div);
        __scheduleRemoval(div, ts);
      }
      list.scrollTop = list.scrollHeight + 1000;
    }catch(e){}
  }

  // Select channel
  function pushMsg(msg){
    try{
      if (!msg) return;
      var ch = (msg && msg.channel) ? ((msg.channel === 'lobby') ? 'lobby' : 'world') : currentChannel;
      __pruneBuf(ch);
      var arr = chatBuf[ch] = chatBuf[ch] || [];
      var key = ((msg.sid||'')+'|'+(msg.text||'')+'|'+Math.floor((msg.ts||0)/2000));
      if (chatSeen[ch] && chatSeen[ch].has(key)) { return; }
      try { chatSeen[ch].add(key); } catch(_){}
      var tsNow = Number(msg.ts || Date.now());
      if ((Date.now() - tsNow) >= CHAT_MAX_AGE_MS) {
        return;
      }
      arr.push(msg); if (arr.length > 200) arr.shift();
      if (ch === currentChannel){
        var name = (msg && msg.pseudo) ? String(msg.pseudo) : 'player';
        var text = (msg && msg.text) ? String(msg.text) : '';
        var ts  = (msg && msg.ts) ? Number(msg.ts) : Date.now();

        var div = document.createElement('div');
        div.className = 'chatLine';
        div.setAttribute('data-ts', String(ts));

        var timeSpan = document.createElement('span');
        timeSpan.className = 'chatTime';
        timeSpan.textContent = __fmtTime(ts) + ' ';
        div.appendChild(timeSpan);

        var nameSpan = document.createElement('span');
        nameSpan.className = 'chatName';
        nameSpan.textContent = name + ':';
        div.appendChild(nameSpan);

        div.appendChild(document.createTextNode(' ' + text));
        list.appendChild(div);
        __scheduleRemoval(div, ts);
        list.scrollTop = list.scrollHeight + 1000;
        while (list.childElementCount > 200) list.removeChild(list.firstElementChild);
      }
    }catch(e){}
  }
function selectChannel(ch){
    if (ch !== 'world' && ch !== 'lobby') ch = 'world';
    if (collapsedBtn && ch === 'lobby') { try { collapsedBtn.classList.remove('notify'); } catch(_){} }
    if (tabLobby && ch === 'lobby') { try { tabLobby.classList.remove('notify'); } catch(_){} }
    if (tabWorld && ch === 'world') { try { tabWorld.classList.remove('notify'); } catch(_){} }
    if (ch === currentChannel) return;
    currentChannel = ch;
    tabWorld.classList.toggle('active', ch === 'world');
    tabLobby.classList.toggle('active', ch === 'lobby');
    renderChannel(currentChannel);
    pendingHistoryFor = ch;
    try { if (window.socket) window.socket.emit('chat:join', { channel: ch }); } catch(_){ }
    applyChatI18n();
  }
  if (tabWorld) tabWorld.addEventListener('click', async function(){ selectChannel('world'); });
  if (tabLobby) tabLobby.addEventListener('click', async function(){ selectChannel('lobby'); });

  // Send
  function send(){
    try {
      if (!window.socket || !window.socket.connected) return;
      const now = Date.now();
      // Block sending if no pseudo entered
      try {
        var __pi = window.pseudoInput || document.getElementById('pseudoInput');
        var __has = !!(__pi && __pi.value && __pi.value.trim());
        if (!__has) { if (__pi) try { __pi.focus(); } catch(_){ } return; }
      } catch(_){}
      if (now - lastSent < COOLDOWN_MS) return;
      let t = (input.value || '').replace(/[\r\n\t]/g,' ').trim();
      if (!t) return;
      if (t.length > MAX_LEN) t = t.slice(0, MAX_LEN);
      
      // Local duplicate pseudo pre-check (align with lobby join behavior)
      try {
        if (currentChannel === 'lobby' && window && window.lobbyData && window.lobbyData.players) {
          var myId = (window.socket && socket.id) || null;
          var p = String(window.myPseudo || '').trim();
          if (p) {
            var arr = Object.keys(window.lobbyData.players).map(function(k){
              var o = window.lobbyData.players[k];
              return (o && o.pseudo) ? { sid: k, name: String(o.pseudo) } : null;
            }).filter(Boolean);
            var taken = arr.some(function(o){ return o && o.name && o.name.toLowerCase() === p.toLowerCase() && o.sid !== myId; });
            if (taken) { try { __alertPseudoTaken(); } catch(_){ } return; }
          }
        }
      } catch(_){}

      // World channel duplicate pseudo pre-check using recent history
      try {
        if (false && currentChannel === 'world' && (!window || !window.loggedUser)) {
          var myId = (window.socket && socket.id) || null;
          var pInput = (window.pseudoInput || document.getElementById('pseudoInput'));
          var p = pInput && pInput.value ? String(pInput.value).trim().substring(0,10).replace(/[^a-zA-Z0-9]/g,'') : '';
          if (!p && window.myPseudo) { p = String(window.myPseudo).trim(); }
          if (p) {
            var arr = (typeof chatBuf !== 'undefined' && chatBuf && Array.isArray(chatBuf['world'])) ? chatBuf['world'] : [];
            var taken = false;
            for (var i=0;i<arr.length;i++){
              var m = arr[i];
              if (!m || !m.pseudo) continue;
              if (String(m.pseudo).toLowerCase() === p.toLowerCase() && m.sid !== myId) { taken = true; break; }
            }
            if (taken) { try { __alertPseudoTaken(); } catch(_){ } return; }
          }
        }
      } catch(_){}
window.socket.emit('chat:send', { channel: currentChannel, text: t, name: (window.myPseudo || '') });
      lastSent = now;
      input.value = '';
    } catch(e){}
  }
  if (sendBtn) sendBtn.addEventListener('click', send);
  if (input) input.addEventListener('keydown', function(ev){
    if (ev.key === 'Enter'){ ev.preventDefault(); send(); }
  });

  // Socket bindings
  function initSocketBindings(){
    try {
      if (!window.socket) return false;
      if (!panel) return false;
      if (__chatBoundTo === window.socket) return true;
      __chatBoundTo = window.socket;

      panel.style.display = 'flex';
      window.socket.emit('chat:join', { channel: currentChannel });

      if (window.socket.off){
        window.socket.off('chat:history');
        window.socket.off('chat:msg');
        window.socket.off('chat:error');
      }
      window.socket.on('chat:history', function(payload){
        try{
          if (!payload) return;
          var __chan = (payload && payload.channel) ? payload.channel : currentChannel;
          chatBuf[__chan] = (payload.history||[]);
          __pruneBuf(__chan);
          chatSeen[__chan] = new Set((chatBuf[__chan]||[]).map(m => ((m.sid||'')+'|'+(m.text||'')+'|'+Math.floor((m.ts||0)/2000))));
          if (__chan === currentChannel) renderChannel(currentChannel);
          if (pendingHistoryFor === __chan) pendingHistoryFor = null;
        }catch(_){}
      });
      window.socket.on('chat:msg', function(msg){
        try {
          var isCollapsed = panel && panel.style && panel.style.display === 'none';
          if (isCollapsed && msg && msg.channel === 'lobby' && collapsedBtn) collapsedBtn.classList.add('notify');
          // Notify world on collapsed when not in game (menu or lobby)
          if (isCollapsed && msg && msg.channel === 'world' && !inGame && collapsedBtn) collapsedBtn.classList.add('notify');
          if (!isCollapsed && msg && msg.channel === 'lobby' && currentChannel !== 'lobby' && tabLobby) tabLobby.classList.add('notify');
          if (!isCollapsed && msg && msg.channel === 'world' && !inGame && currentChannel !== 'world' && tabWorld) tabWorld.classList.add('notify');
        } catch(_){ }
        try {
  var __ua = (navigator.userAgent||'');
  var __isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(__ua);
  var __isSelf = !!(msg && msg.sid && window.socket && (msg.sid === window.socket.id));
  if (__isMobile && inGame && isCollapsed && !__isSelf && msg && msg.channel === 'lobby' && collapsedBtn) { collapsedBtn.classList.add('notify'); }
} catch(_){ }
        try {
          var __self2 = !!(msg && msg.sid && window.socket && (msg.sid === window.socket.id));
          if (msg && msg.channel === 'lobby' && inGame && isCollapsed && !__self2 && typeof window.__igChatNotify==='function') { /* guarded */ if (msg && msg.channel === 'lobby') window.__igChatNotify(); }
        } catch(_){ }
        pushMsg(msg);
      });window.socket.on('chat:error'
, function(e){
  try {
    if (!e || !e.type) return;
    if (e.type === 'cooldown') {
      try { sendBtn.disabled = true; setTimeout(function(){ sendBtn.disabled = false; }, Math.min(1200, e.waitMs || 1000)); } catch(_){}
      return;
    }
    if (e.type === 'pseudo_taken' || e.type === 'reserved') {
      try {
        var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
        if (e.type === 'reserved') {
          var msg = tr.reservedName || 'This nickname is reserved by an account. Choose another one.';
          showTopMessage(msg);
        } else {
          __alertPseudoTaken();
        }
      } catch(_) { __alertPseudoTaken(); }
      return;
    }
  } catch(_) { }
});
      window.socket.on('connect', function(){ try { __chatBoundTo = null; initSocketBindings(); } catch(_){}});
      window.socket.on('reconnect', function(){ try { __chatBoundTo = null; initSocketBindings(); } catch(_){}});
      window.socket.on('gameStarted', function(info){ inGame = true; updateTabs(); positionCollapsedBtn(); try { var humans=0; var pls=(info&&info.players)||{}; for (var k in pls){ if(!Object.prototype.hasOwnProperty.call(pls,k)) continue; var p=pls[k]; if(p&&p.isBot) continue; humans++; } setCollapsed(true); } catch(_){ }});
      return true;
    } catch(e){ return false; }
  }
  positionCollapsedBtn();
  if (window.socket) initSocketBindings();
  var __chatTry = setInterval(function(){ if (initSocketBindings()){ clearInterval(__chatTry); } }, 300);

  // Periodic history refresh (fallback)
  setInterval(function(){
    try {
      if (window.socket && window.socket.connected) {
        window.socket.emit('chat:join', { channel: currentChannel });
      }
    } catch(_){}
  }, 2000);

  // Modes & tabs
  function updateTabs(){
    const modeMain = (!inManualLobby && !inGame);
    const modeLobby = (inManualLobby && !inGame);
    const modeGame = inGame;
    const newMode = modeGame ? 'game' : (modeLobby ? 'lobby' : 'main');
    if (__chatPrevMode === newMode) return;
    __chatPrevMode = newMode;

    if (newMode === 'main'){
      tabWorld.style.display = '';
      tabLobby.style.display = 'none';
      if (currentChannel !== 'world') selectChannel('world');
    } else if (newMode === 'lobby'){
      tabWorld.style.display = '';
      tabLobby.style.display = '';
    } else {
      tabWorld.style.display = 'none';
      tabLobby.style.display = '';
      if (currentChannel !== 'lobby') selectChannel('lobby');
    }
  }

  function refreshLobbyMode(){
    try {
      var pnl = document.getElementById('manualLobbyPanel');
      inManualLobby = !!(pnl && pnl.style && pnl.style.display !== 'none');
      updateTabs();
      positionCollapsedBtn();
    } catch(_){}
  }
  // show by default, ignore previous collapsed state
  try { localStorage.removeItem('chatCollapsed'); } catch(_){}
  setCollapsed(false); try{ if (window.__igChatClearNotify) window.__igChatClearNotify(); }catch(_){ }
  setInterval(refreshLobbyMode, 1500);
  window.addEventListener('resize', positionCollapsedBtn);
})();</script>
<script>
/* === SOLO MODE CHAT HIDING (client-only, robust & non-invasive) ===
   Hides both the chat panel and the collapsed chat button whenever a game is started
   with only one human player (solo). Re-enables chat automatically when back to lobby/menu.
   Does not modify server behavior.
*/
(function(){
  try {
    var FORCED_HIDE = false;

    function getEl(id){ return document.getElementById(id); }
    function applyVisibility(){
      try {
        // Hide chat when server selection overlay is visible
        try {
          var overlay = document.getElementById('serverOverlay');
          var cs = (window.getComputedStyle ? getComputedStyle(overlay) : null);
          var overlayVisible = !!(overlay && ((overlay.style && overlay.style.display !== 'none') || (cs && cs.display !== 'none')));
          if (overlayVisible) {
            panel && (panel.style.display = 'none');
            btn && (btn.style.display = 'none');
            return;
          }
        } catch(_){}
    
        var panel = getEl('chatPanel');
        var btn = getEl('chatCollapsedBtn');
        if (!panel || !btn) return;
        if (FORCED_HIDE) {
          panel.style.display = 'none';
          btn.style.display = 'none';
          // clear any visual notifications to avoid stale UI when re-enabled
          try { btn.classList.remove('notify'); } catch(_) {}
          try { var tabW = getEl('tabWorld'); tabW && tabW.classList.remove('notify'); } catch(_) {}
          try { var tabL = getEl('tabLobby'); tabL && tabL.classList.remove('notify'); } catch(_) {}
        } else {
          // do not force-show; keep existing collapse state managed by the chat script
        }
      } catch(_){}
    }

    function isSoloFromPayload(info){
      try {
        var players = (info && info.players) || {};
        var humans = 0;
        for (var id in players){
          if (!players.hasOwnProperty(id)) continue;
          var p = players[id];
          if (p && p.isBot) continue;
          humans++;
        }
        return humans <= 1;
      } catch(_){ return false; }
    }

    
    // Observe server overlay visibility to hide/show chat on menu
    try {
      var __chatOverlayObserverInit = false;
      (function(){
        if (__chatOverlayObserverInit) return;
        __chatOverlayObserverInit = true;
        var overlay = document.getElementById('serverOverlay');
        if (!overlay || typeof MutationObserver === 'undefined') { applyVisibility(); return; }
        try {
          var mo = new MutationObserver(function(){ applyVisibility(); });
          mo.observe(overlay, { attributes: true, attributeFilter: ['style', 'class'], subtree: false });
        } catch(_){}
        applyVisibility();
      })();
    } catch(_){}
if (window.socket && typeof window.socket.on === 'function') {
      // When a game starts, hide chat if solo; otherwise ensure it's not forced-hidden
      window.socket.on('gameStarted', function(info){
        try {
          FORCED_HIDE = !!isSoloFromPayload(info);
          applyVisibility();
        } catch(_){}
      });

      // When we return to the lobby (game not started), re-enable chat
      window.socket.on('lobbyUpdate', function(data){
        try {
          if (!data || data.started === false) {
            FORCED_HIDE = false;
            applyVisibility();
          }
        } catch(_){}
      });

      // Also on reconnect, reset the forced flag (state will re-apply on next events)
      window.socket.on('reconnect', function(){ try { FORCED_HIDE = false; applyVisibility(); } catch(_){}});
    }

    // Expose for debugging if needed
    window.__forceHideChatSolo = function(on){ FORCED_HIDE = !!on; applyVisibility(); };
  } catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
(function(){
  try {
    if (window.socket) {
      socket.on('setPseudoAndReadyResult', function(res){
        try {
          if (!res || res.ok) return;
          var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
          try {
  var r = (res && res.reason) || '';
  var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
  if (r === 'reserved') {
    showTopMessage(tr.reservedName || 'This nickname is reserved by an account. Choose another one.');
  
            if (window.pseudoInput) {
              try { window.pseudoInput.value = ''; } catch(_){ }
              try { window.pseudoInput.style.background = '#3b0000'; setTimeout(function(){ try { window.pseudoInput.style.background = ''; } catch(_){ } }, 450); } catch(_){ }
            }
} else {
    __alertPseudoTaken();
  }
  if (window.__flashPseudoError) window.__flashPseudoError();
} catch(_){ }
try { if (window.__unlockJoinAfterPseudoError) __unlockJoinAfterPseudoError(r || (e && e.type)); } catch(_){ }} catch(_){}
      });
socket.on('renameResult', function(res){
        try {
          if (!res || res.ok) return;
          if (res && res.reason === 'pseudo_taken') {
            var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            __alertPseudoTaken();
          }
        } catch(_){}
      });
    }
  } catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<script>
function __alertPseudoTaken(){
  try {
    var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
    showTopMessage(tr.pseudoTaken || 'Nickname already in use.');
  } catch(_) { showTopMessage('Nickname already in use.'); }
}
</script>

<script>
// Unlock Join UI immediately on nickname errors so users can retry without waiting.
(function(){
  if (window.__unlockJoinInstalled) return; window.__unlockJoinInstalled = true;
  window.__unlockJoinAfterPseudoError = function(reason){
    try {
      // Clear fast-click lock
      try { window.__joinLockTs = 0; } catch(_){}
      // UI elements
      var pseudoInput = document.getElementById('pseudoInput');
      var lobbyJoin = document.getElementById('lobbyJoin') || window.lobbyJoin;
      // Reset joined flag so buttons aren't disabled
      try { window.lobbyJoined = false; } catch(_){}
      // Re-enable controls immediately
      try {
        if (lobbyJoin) { lobbyJoin.disabled = false; }
        if (pseudoInput) {
          pseudoInput.disabled = false;
          pseudoInput.readOnly = false;
          pseudoInput.style.background = '#fff';
          pseudoInput.style.color = '#000';
          pseudoInput.style.border = '1px solid #444';
          // focus so the user can retry right away
          pseudoInput.focus();
          pseudoInput.select && pseudoInput.select();
        }
      } catch(_){}
      try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){}
    } catch(_){}
  };

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>



<script>
// Robust listener to ensure popup on pseudo_taken for chat send, even if other handlers exist.
(function ensurePseudoTakenPopup(){
  function bind(){
    try{
      if (!window.socket || !window.socket.on) return false;
      window.socket.on('chat:error', function(e){
        try{
          if (e && e.type === 'pseudo_taken') {
            var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            showTopMessage(tr.pseudoTaken || 'Nickname already in use.');
          } else if (e && (e.type === 'reserved' || e.reason === 'reserved')) {
            showTopMessage(tr.reservedName || 'This nickname is reserved by an account. Choose another one.');
          
            if (window.pseudoInput) {
              try { window.pseudoInput.value = ''; } catch(_){ }
              try { window.pseudoInput.style.background = '#3b0000'; setTimeout(function(){ try { window.pseudoInput.style.background = ''; } catch(_){ } }, 450); } catch(_){ }
            }
}
        }catch(_){ }
      });
      return true;
    }catch(_){ return false; }
  }
  if (!bind()){
    var __ptint = setInterval(function(){ if (bind()) { clearInterval(__ptint); } }, 300);
  }

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
// Robust listener to ensure popup on pseudo_taken for Join lobby actions (server-side signal)
(function ensureJoinPseudoTakenPopup(){
  function bind(){
    try{
      if (!window.socket || !window.socket.on) return false;
      window.socket.on('join:error', function(e){
        try{
          if (e && e.type === 'pseudo_taken') {
            var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            showTopMessage(tr.pseudoTaken || 'Nickname already in use.');
          } else if (e && (e.type === 'reserved' || e.reason === 'reserved')) {
            showTopMessage(tr.reservedName || 'This nickname is reserved by an account. Choose another one.');
          
            if (window.pseudoInput) {
              try { window.pseudoInput.value = ''; } catch(_){ }
              try { window.pseudoInput.style.background = '#3b0000'; setTimeout(function(){ try { window.pseudoInput.style.background = ''; } catch(_){ } }, 450); } catch(_){ }
            }
}
        }catch(_){ }
      });
return true;
    }catch(_){ return false; }
  }
  if (!bind()){
    var __jpt = setInterval(function(){ if (bind()) { clearInterval(__jpt); } }, 300);
  }

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
// Ensure we instantly re-enable Join UI on server-side join errors (e.g., pseudo_taken/reserved)
(function(){
  function bind(){
    try{
      if (!window.socket || !window.socket.on) return false;
      window.socket.on('join:error', function(e){
        try{
          if (!e) return;
          var t = (e.type || e.reason || '');
          if (t === 'pseudo_taken' || t === 'reserved' || t === 'invalid_pseudo'){
            if (window.__unlockJoinAfterPseudoError) __unlockJoinAfterPseudoError(t);
          }
        }catch(_){}
      });
      window.socket.on('setPseudoAndReadyResult', function(res){
        try{
          if (!res || res.ok) return;
          var r = res.reason || '';
          if (r === 'pseudo_taken' || r === 'reserved' || r === 'invalid_pseudo'){
            if (window.__unlockJoinAfterPseudoError) __unlockJoinAfterPseudoError(r);
          }
        }catch(_){}
      });
      return true;
    }catch(_){ return false; }
  }
  if (!bind()){
    var __unlockInt = setInterval(function(){ if (bind()) clearInterval(__unlockInt); }, 300);
  }

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>



<!-- MOBILE LOBBY RESIZE PATCH JS -->
<script id="mobile-lobby-resize-patch-js">
(function(){
  // Compute reliable 1% viewport height in px, update --vh on resize/keyboard/orientation
  function setVH() {
    try {
      var h = (window.visualViewport && window.visualViewport.height) || window.innerHeight || document.documentElement.clientHeight || 0;
      if (h > 0) document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
    } catch(_) {}
  }
  setVH();
  window.addEventListener('resize', setVH, {passive:true});
  window.addEventListener('orientationchange', setVH, {passive:true});
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', setVH);
    window.visualViewport.addEventListener('scroll', setVH); // some UIs move on keyboard
  }

  // Fallback: if content still taller than viewport, scale the box down slightly.
  function fitLobbyBoxMobile(){
    try {
      var box = document.getElementById('lobbyBox');
      var screen = document.getElementById('lobbyScreen');
      if (!box || !screen) return;
      if (window.matchMedia('(min-width: 769px)').matches) {
        box.style.transform = '';
        box.style.transformOrigin = '';
        return;
      }
      var vh = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
      var maxH = Math.max(200, vh - 24);
      box.style.maxHeight = maxH + 'px';
      box.style.overflowY = 'auto';

      // Only scale down when even with scroll the box would overflow viewport badly
      // (rare on iOS with toolbars showing). Clamp between 0.82 and 1.
      var contentHeight = box.scrollHeight;
      var scale = Math.min(1, Math.max(0.82, maxH / (contentHeight + 8)));
      if (scale < 1) {
        box.style.transformOrigin = 'center';
        box.style.transform = 'scale(' + scale.toFixed(3) + ')';
      } else {
        box.style.transform = '';
        box.style.transformOrigin = '';
      }
    } catch(e){}
  }
  // Observe changes inside the lobby to refit when panels switch
  var mo;
  function ensureObserver(){
    try{
      if (mo) return;
      var box = document.getElementById('lobbyBox');
      if (!box) return;
      mo = new MutationObserver(function(){ fitLobbyBoxMobile(); });
      mo.observe(box, {childList:true, subtree:true, attributes:true});
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    setVH(); fitLobbyBoxMobile(); ensureObserver();
  });
  window.addEventListener('load', function(){
    setVH(); fitLobbyBoxMobile(); ensureObserver();
  });
  window.addEventListener('resize', fitLobbyBoxMobile, {passive:true});
  if (window.visualViewport) window.visualViewport.addEventListener('resize', fitLobbyBoxMobile);

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
/* === AUTH CLIENT === */
(function(){
  'use strict';
  function trAuth(key, fallback){
    try {
      const lang = (window.currentLang || 'en');
      const pack = (window.TRANSLATIONS && window.TRANSLATIONS[lang]) || (window.TRANSLATIONS && window.TRANSLATIONS['en']) || {};
      return pack[key] || fallback || key;
    } catch(e){ return fallback || key; }
  }
  const btnLogin = document.getElementById('btnLogin');
  const btnSignup = document.getElementById('btnSignup');
  const btnLogout = document.getElementById('btnLogout');
  const btnSettings = document.getElementById('btnSettings');
  const modal = document.getElementById('authModal');
  const overlay = document.getElementById('authModalOverlay');
  const btnShop = document.getElementById('btnAccountShop');
  const modalTitle = document.getElementById('authModalTitle');
  const modalBody = document.getElementById('authModalBody');
  const btnCancel = document.getElementById('authCancel');
  const btnSubmit = document.getElementById('authSubmit');
  const pseudoInput = document.getElementById('pseudoInput');
  const lobbyJoin = document.getElementById("lobbyJoin") || window.lobbyJoin;
  const btnJoinLobbyList = document.getElementById('btnJoinLobbyList');
  const btnCreateLobby = document.getElementById('btnCreateLobby');
  let reservedPseudo = false;
  let loggedUser = null;
  // === Robust lock for pseudo input when logged in ===
  (function(){
    try {
      var __pseudo = document.getElementById('pseudoInput');
      // Helper: are we logged in right now?
      function __isLoggedIn(){
        try {
          // Prefer global state set by setAuthUI
          if (typeof loggedUser !== 'undefined' && loggedUser) return true;
        } catch(_){}
        try {
          var b = document.getElementById('btnLogout');
          return !!(b && b.style && b.style.display !== 'none');
        } catch(_){}
        return false;
      }
      function enforcePseudoLock(){
        try {
          if (!__pseudo) __pseudo = document.getElementById('pseudoInput');
          if (!__pseudo) return;
          if (__isLoggedIn()){
            try {
              // Force account username and lock the field
              var name = (typeof loggedUser !== 'undefined' && loggedUser) ? String(loggedUser) : (__pseudo.value||'');
              __pseudo.value = name;
              __pseudo.readOnly = true;
              __pseudo.setAttribute('readonly','readonly');
              // Keep visual "green/locked" style
              __pseudo.style.background = '#c7f7c7';
              __pseudo.style.color = '#000';
              __pseudo.style.border = '1px solid #49c749';
            } catch(_){}
          }
        } catch(_){}
      }
      // Prevent any user edits while logged in
      if (__pseudo){
        __pseudo.addEventListener('beforeinput', function(ev){ if (__isLoggedIn()){ ev.preventDefault(); enforcePseudoLock(); } }, true);
        __pseudo.addEventListener('keydown', function(ev){
          try {
            if (!__isLoggedIn()) return;
            var k = ev && (ev.key || ev.code || '');
            // Allow navigation keys, deny all that would edit
            var allow = ['Tab','Enter','Escape','ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End'];
            if (allow.indexOf(k) === -1) { ev.preventDefault(); enforcePseudoLock(); }
          } catch(_){}
        }, true);
        __pseudo.addEventListener('paste', function(ev){ if (__isLoggedIn()){ ev.preventDefault(); enforcePseudoLock(); } }, true);
        __pseudo.addEventListener('drop', function(ev){ if (__isLoggedIn()){ ev.preventDefault(); enforcePseudoLock(); } }, true);
      }
      // Re‑enforce periodically in case some other code toggles readonly
      setInterval(enforcePseudoLock, 800);
      // Make globally accessible for calls from other UI flows
      try { window.enforcePseudoLock = enforcePseudoLock; } catch(_){}
    } catch(_){}
  })();


  function setAuthUI(loggedIn, username){
    try {
      if (btnLogin) btnLogin.style.display = loggedIn ? 'none' : '';
      if (btnSignup) btnSignup.style.display = loggedIn ? 'none' : '';
      if (btnLogout) btnLogout.style.display = loggedIn ? '' : 'none';
      if (btnSettings) btnSettings.style.display = loggedIn ? '' : 'none';
    } catch(_){}
    try {
      if (pseudoInput) {
        if (loggedIn) {
          pseudoInput.value = username || '';
          pseudoInput.readOnly = true;
          
          try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }window.myPseudo = username || '';
          try { localStorage.setItem('zombi_pseudo', window.myPseudo); } catch(_){}
        } else {
          pseudoInput.disabled = false;
        
          try { pseudoInput.readOnly = false; pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }}
        if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled();
      }
    } catch(_){}
    loggedUser = loggedIn ? (username || '') : null; try{ window.loggedUser = loggedIn ? (username||'') : null; }catch(_){}
     try{ window.__meOk = !!loggedIn; }catch(_){ } validatePseudoBlocking(); try{ if (loggedIn && typeof pseudoInput!=='undefined' && pseudoInput && document.activeElement===pseudoInput) pseudoInput.blur(); }catch(_){} // re-validate
      try{ if (window.enforcePseudoLock) window.enforcePseudoLock(); }catch(_){ }
  }

  function updateAuthTexts(){
    try {
      if (btnLogin) btnLogin.textContent = trAuth('login','Log in');
      if (btnSignup) btnSignup.textContent = trAuth('signup','Sign up');
      if (btnLogout) btnLogout.textContent = trAuth('signout','Sign out');
      if (btnSettings) btnSettings.textContent = trAuth('settings','Settings');
      if (modal && modal.style.display !== 'none') {
        document.getElementById('authCancel').textContent = trAuth('cancel','Cancel');
        document.getElementById('authSubmit').textContent = trAuth('submit','Submit');
      }
    } catch(_){}
  }
  window.updateAuthTexts = updateAuthTexts;

  // Hook into existing updateUITexts
  setTimeout(function(){
    try {
      if (typeof window.updateUITexts === 'function') {
        const _orig = window.updateUITexts;
        window.updateUITexts = function(){ try { _orig.apply(this, arguments); } catch(_){ } try { updateAuthTexts(); } catch(_){ } };
      } else {
        updateAuthTexts();
      }
    } catch(_){}
  }, 0);

  function showModal(kind, payload){
    overlay.style.display = 'flex';
    modal.style.display = 'flex';
    try { if (document.getElementById('authCancel')) document.getElementById('authCancel').textContent = trAuth('cancel','Cancel'); if (document.getElementById('authSubmit')) document.getElementById('authSubmit').textContent = trAuth('submit','Submit'); } catch(_){}if (kind === 'login') {
      modalTitle.textContent = trAuth('login','Log in');
      var __shopHtml = ''
        + '<div style="display:flex;flex-direction:column;gap:8px;">'
        + '  <label>' + trAuth('username','Username') + '</label>'
        + '  <input id="authUser" maxlength="10" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('password','Password') + '</label>'
        + '  <input id="authPass" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '</div>';
      modalBody.innerHTML = __shopHtml;
      
      btnSubmit.onclick = doLogin;
      btnSubmit.style.display = '';
    } else if (kind === 'signup') {
      modalTitle.textContent = trAuth('signup','Sign up');
      modalBody.innerHTML = ''
        + '<div style="display:flex;flex-direction:column;gap:8px;">'
        + '  <label>' + trAuth('username','Username') + '</label>'
        + '  <input id="authUser" maxlength="10" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('password','Password') + '</label>'
        + '  <input id="authPass" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('confirmPassword','Confirm your password') + '</label>'
        + '  <input id="authPass2" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '</div>';
      btnSubmit.onclick = doSignup;
      btnSubmit.style.display = '';

    } else if (kind === 'shop') {
      // Shop content inside auth modal
      modalTitle.textContent = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang]||TRANSLATIONS['en'])||{}).shopMain || 'Shop';
      // Initial placeholder while fetching
      if (!document.getElementById('shopUpgradesLobby')) { modalBody.innerHTML = '<div style="padding:8px;color:#9ab;">Loading...</div>'; }
      btnSubmit.style.display = 'none';
(async function(){
        try{
          const r = await fetch('/api/me', { credentials:'include' });
          const j = await r.json();
          const T = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang]||TRANSLATIONS['en'])) || {};
          if (!j || !j.ok) { try{ showTopMessage((T.needLoginShop || 'You must be logged in to access the shop.')); }catch(_){} try{ overlay.style.display='none'; modal.style.display='none'; }catch(_){} return; }
          const gold = j.gold|0;
          try { window.myMoney = gold; } catch(_){ }
      const up = Object.assign({hp:0,dmg:0}, j.shopUpgrades||{});
          
            try { window.accountShop = up; } catch(_){}
            try { if (typeof renderShopUpgrades === 'function') renderShopUpgrades(); } catch(_){}
    const hpLv = up.hp|0, dmgLv = up.dmg|0;
          const hpMax = 20, dmgMax = 20, HP_PRICE = 50, DMG_PRICE = 200;
          function item(id, title, desc, level, max, price){
            const disabled = level>=max || gold < price;
            const note = (level>=max) ? '<div style="color:#9ab; font-size:12px;">'+(T.maxLevel||'Max level reached')+'</div>' : '';
            return (
              '<div style="display:flex;align-items:center;gap:12px;background:#232834;border:1px solid #344;padding:12px;border-radius:12px;margin:8px 0;">'
            + '  <div id="badge-' + id + '" style="width:40px;height:40px;border-radius:10px;background:#ffa00022;border:2px solid #ffb300;display:flex;align-items:center;justify-content:center;font-weight:700;">' + (id==='hp' ? (100 + (level|0)*10) : (10 + (level|0)*1)) + '</div>'
            + '  <div style="flex:1;">'
            + '    <div style="font-size:17px;font-weight:700;">'+title+'</div>'
            + '    <div style="color:#9ab;font-size:13px;">'+desc+'</div>'
            + '    <div style="margin-top:6px;font-size:14px;">'+(T.level||'Level')+': <b>'+level+'</b> / '+max+'</div>'
            + '  </div>'
            + '  <div style=\"display:flex;flex-direction:column;align-items:center;gap:6px;min-width:160px;width:160px;\">'
            + '    <div style="font-size:14px;">'+(T.price||'Price')+': <b>'+price+'</b> '+(T.gold||'Gold')+'</div>'
            + '    <button data-shop-buy="'+id+'" style="padding:8px 12px;border:none;border-radius:10px;background:'+(disabled?'#444':'#ff8800')+';color:#fff;cursor:'+(disabled?'not-allowed':'pointer')+';" '+(disabled?'disabled':'')+'>'+(T.buy||'Buy')+'</button>'
            +       note
            + '  </div>'
            + '</div>'
            );
          }
          const hpTitle = T.hpUpgTitle || 'HP +10';
          const hpDesc  = T.hpUpgDesc  || 'Start each game with +10 HP per level (up to +200).';
          const dmgTitle= T.dmgUpgTitle|| 'Damage +1';
          const dmgDesc = T.dmgUpgDesc || 'Start each game with +1 damage per level (up to +20).';
          modalBody.innerHTML = ''
            + '<div style="margin-bottom:8px;"><b>'+(T.gold||'Gold')+'</b>: <span id="shopGoldVal">'+gold+'</span></div>'
            + item('hp', hpTitle, hpDesc, hpLv, hpMax, HP_PRICE)
            + item('dmg', dmgTitle, dmgDesc, dmgLv, dmgMax, DMG_PRICE)
            + '<div style="margin-top:10px; font-size:12px; color:#9ab;">'+(T.goldHowTo||'Earn gold by clearing waves 5+ (wave 5=+1, 6=+2, etc.).')+'</div>';
          
          var __wrapM = document.getElementById('shopUpgradesLobby');
          if (__wrapM) { __wrapM.innerHTML = __shopHtml; } else { modalBody.innerHTML = '<div id="shopUpgradesLobby">' + __shopHtml + '</div>'; }
// Bind buys (inside modal)
          Array.prototype.slice.call(modalBody.querySelectorAll('[data-shop-buy]')).forEach(function(btn){
            btn.addEventListener('click', async function(){
              const type = this.getAttribute('data-shop-buy');
              try{
                const r = await fetch('/api/shop/buy', { method:'POST', headers:{'Content-Type':'application/json'}, credentials:'include', body: JSON.stringify({ type }) });
                const jj = await r.json();
                if (jj && jj.ok){
                  // refresh view in-place
                  (typeof window.refreshShopPanel==='function' ? window.refreshShopPanel() : (typeof showModal==='function' ? showModal('shop') : void 0));
                } else {
                  if (jj && jj.code === 'not_enough_gold') showTopMessage(T.notEnoughGold||'Not enough gold.');
                  else if (jj && jj.code === 'max_level') showTopMessage(T.maxLevel||'Max level reached');
                  else showTopMessage(T.actionImpossible||'Action impossible.');
                }
              }catch(_){ showTopMessage('Shop not available.'); }
            }, { passive:false });
          });
        }catch(_){ modalBody.innerHTML = '<div style="padding:12px; background:#3a2f2f; border:1px solid #6b3; color:#ffd; border-radius:10px;">Shop not available.</div>'; }
      })();
    
    } else if (kind === 'settings') {
      modalTitle.textContent = trAuth('settings','Settings');
      modalBody.innerHTML = ''
        + '<div style="display:flex;flex-direction:column;gap:8px;">'
        + '  <label>' + trAuth('currentPassword','Current password') + '</label>'
        + '  <input id="currPass" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('newPassword','New password') + '</label>'
        + '  <input id="newPass" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('confirmNewPassword','Confirm your new password') + '</label>'
        + '  <input id="newPass2" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '</div>';
      btnSubmit.onclick = doChangePassword;
      btnSubmit.style.display = '';
    }
    
 else if (kind === 'kicked') {
      try {
        var trAuthFn = (typeof trAuth === 'function') ? trAuth : function(){ return arguments[1] || ''; };
        var m = (payload && payload.message) || 'You were kicked. You can rejoin in ~30s.';
        modalTitle.textContent = trAuthFn('info', 'Info');
        // Set message safely without HTML injection
        if (modalBody) { modalBody.textContent = m; }
        if (btnSubmit) { btnSubmit.style.display = 'none'; btnSubmit.onclick = null; }
        if (btnCancel) { btnCancel.style.display=''; btnCancel.textContent = (trAuth && trAuth('cancel','Cancel')) || 'Cancel'; btnCancel.onclick = hideModal; }
      } catch(_){}
    
      return;
    }
btnSubmit.textContent = trAuth('submit','Submit');
    setTimeout(() => { const u = document.getElementById('authUser'); if (u) u.focus(); }, 30);

}
function hideModal(){ overlay.style.display='none'; modal.style.display='none'; modalBody.innerHTML=''; }

  async function fetchJSON(url, opts){
    const res = await fetch(url, Object.assign({ headers:{'Content-Type':'application/json'} }, opts||{}));
    let data = null; try { data = await res.json(); } catch(_){}
    return { ok: res.ok && data && (data.ok===true || data.ok===undefined), status: res.status, data };
  }

  async function doSignup(){
    try {
      const u = document.getElementById('authUser').value.trim();
      const p = document.getElementById('authPass').value;
      const p2 = document.getElementById('authPass2').value;
      if (!u || !p || !p2) { showTopMessage(trAuth('fillAll')); return; }
      if (p !== p2) { showTopMessage(trAuth('confirmPassword') + ' ✖'); return; }
      const { ok, data, status } = await fetchJSON('/api/signup', { method:'POST', body: JSON.stringify({ username: u, password: p })});
      if (ok && (!data || data.ok)) { hideModal(); showTopMessage(trAuth('signupOk')); }
      else {
        if (data && data.code === 'exists') showTopMessage(trAuth('userExists'));
        else if (data && (data.code === 'weak_password' || status === 400)) showTopMessage(trAuth('weakPassword'));
        else showTopMessage('Error.');
      }
    } catch(e){ showTopMessage('Error'); }
  }
  async function doLogin(){
    try {
      const u = document.getElementById('authUser').value.trim();
      const p = document.getElementById('authPass').value;
      if (!u || !p) { showTopMessage(trAuth('fillAll')); return; }
      const { ok, data } = await fetchJSON('/api/login', { method:'POST', body: JSON.stringify({ username: u, password: p })});
      if (ok && data && data.username) { hideModal(); setAuthUI(true, data.username);
        try{ if (window.socket){ try{ socket.disconnect(); }catch(_){ } setTimeout(function(){ try{ socket.connect(); window.linkSocketToSession && window.linkSocketToSession(); }catch(_){ } }, 300); } }catch(_){ }
        try{ if (window.socket){ try{ socket.disconnect(); }catch(_){ } setTimeout(function(){ try{ socket.connect(); }catch(_){ } }, 150); } }catch(_){ }
        showTopMessage(trAuth('loginOk')); }
      else { showTopMessage(trAuth('invalidCredentials')); }
    } catch(e){ showTopMessage('Error'); }
  }
  async function doChangePassword(){
    try {
      const c = document.getElementById('currPass').value;
      const n = document.getElementById('newPass').value;
      const n2 = (document.getElementById('newPass2') && document.getElementById('newPass2').value) || '';
      if (!c || !n || !n2) { showTopMessage(trAuth('fillAll')); return; }
      if (n !== n2) { showTopMessage(trAuth('confirmNewPassword') + ' ✖'); return; }
      const { ok, data } = await fetchJSON('/api/change-password', { method:'POST', body: JSON.stringify({ currentPassword: c, newPassword: n })});
      if (ok) { hideModal(); setAuthUI(false); showTopMessage(trAuth('pwdChanged')); }
      else { if (data && data.code === 'weak_password') showTopMessage(trAuth('weakPassword')); else showTopMessage(trAuth('invalidCredentials')); }
    } catch(e){ showTopMessage('Error'); }
  }

  // Check if pseudo is reserved by an account when not logged in
  let checkTimer = null;
  async function validatePseudoBlocking(){
    try {
      if (!pseudoInput) return;
      const name = (pseudoInput.value || '').trim();
      if (!name) { reservedPseudo = false; setButtonsEnabled(true); return; }
      if (loggedUser && name.toLowerCase() === (loggedUser||'').toLowerCase()) {
        reservedPseudo = false; setButtonsEnabled(true); return;
      }
      const { ok, data } = await fetchJSON('/api/username-taken?u=' + encodeURIComponent(name), { method:'GET' });
      reservedPseudo = !!(ok && data && data.taken && !loggedUser);
      setButtonsEnabled(!reservedPseudo);
    } catch(_){ reservedPseudo = false; setButtonsEnabled(true); }
  }
  function setButtonsEnabled(enabled){
    try {
      [lobbyJoin, btnJoinLobbyList, btnCreateLobby].forEach(el => { if (el) el.disabled = !enabled; });
      if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled();
    } catch(_){}
  }

  if (pseudoInput) pseudoInput.addEventListener('input', function(){
    clearTimeout(checkTimer);
    checkTimer = setTimeout(validatePseudoBlocking, 200);
  }, { passive:true });

  if (btnLogin) btnLogin.addEventListener('click', async function(){ showModal('login'); }, { passive:true });
  if (btnShop) btnShop.addEventListener('click', async function(){ try{ if (typeof window.showShopPanel==='function') window.showShopPanel(); else (typeof window.refreshShopPanel==='function' ? window.refreshShopPanel() : (typeof showModal==='function' ? showModal('shop') : void 0)); }catch(e){ console.error(e);} }, { passive:true });
  if (btnSignup) btnSignup.addEventListener('click', async function(){ showModal('signup'); }, { passive:true });
  if (btnLogout) btnLogout.addEventListener('click', async function(){
    try { await fetchJSON('/api/logout', { method:'POST' }); } catch(_){ }
    try { if (typeof setAuthUI === 'function') setAuthUI(false); } catch(_){ }
    try { if (typeof showTopMessage === 'function') showTopMessage(trAuth('logoutOk')); } catch(_){ }
    try {
      // Prefer the existing hardReload() if available (disconnects socket + full reload)
      if (typeof hardReload === 'function') { hardReload(); return; }
      // Fallback: ensure socket is closed then force a full page reload
      if (window.socket && socket && socket.connected) { try { socket.disconnect(); } catch(_){ } }
      if (typeof location !== 'undefined' && location && location.reload) location.reload();
      else window.location = window.location;
    } catch(_){ /* swallow to avoid breaking UI */ }
  }, { passive:true });
  if (btnSettings) btnSettings.addEventListener('click', async function(){ showModal('settings'); }, { passive:true });
  if (overlay) overlay.addEventListener('click', hideModal, { passive:true });
  if (btnCancel) btnCancel.addEventListener('click', hideModal, { passive:true });
// Intercept clicks to block reserved pseudo
  function guardAction(e){
    if (reservedPseudo) { e.preventDefault(); e.stopPropagation(); showTopMessage(trAuth('reservedName')); return false; }
  }
  [lobbyJoin, btnJoinLobbyList, btnCreateLobby].forEach(el => { if (el) el.addEventListener('click', guardAction, true); });
  // Also guard chat sending (button click and Enter key) when pseudo is reserved
  try {
    var chatSendBtn = document.getElementById('chatSend');
    var chatInputEl = document.getElementById('chatInput');
    if (chatSendBtn) chatSendBtn.addEventListener('click', guardAction, true);
    if (chatInputEl) chatInputEl.addEventListener('keydown', function(ev){
      try {
        var k = ev && (ev.key || ev.code || '');
        var isEnter = (k === 'Enter') || (ev && (ev.keyCode === 13));
        if (isEnter && reservedPseudo) { ev.preventDefault(); ev.stopPropagation(); showTopMessage(trAuth('reservedName')); return false; }
      } catch(_){}
    }, true);
  } catch(_){}

  // Also guard chat sending (button click and Enter key) when pseudo is reserved
  try {
    var chatSendBtn = document.getElementById('chatSend');
    var chatInputEl = document.getElementById('chatInput');
    if (chatSendBtn) chatSendBtn.addEventListener('click', guardAction, true);
    if (chatInputEl) chatInputEl.addEventListener('keydown', function(ev){
      try {
        var k = ev && (ev.key || ev.code || '');
        var isEnter = (k === 'Enter') || (ev && (ev.keyCode === 13 || ev.which === 13));
        if (isEnter && reservedPseudo) { ev.preventDefault(); ev.stopPropagation(); showTopMessage(trAuth('reservedName')); return false; }
      } catch(_){}
    }, true);
  } catch(_){}

  // Initial state from server
  async function refreshMe(){
    try {
      const { ok, data } = await fetchJSON('/api/me', { method:'GET' });
      if (ok && data && data.username) setAuthUI(true, data.username);
      else setAuthUI(false);
    } catch(_){ setAuthUI(false); }
  }
  document.addEventListener('DOMContentLoaded', function(){ refreshMe(); updateAuthTexts(); validatePseudoBlocking(); }, { passive:true });

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
// Keep Ladder UI translated instantly on language change (button, title, back, table headers)
(function(){
  function currentTR(){
    try { return (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {}; } catch(e){ return {}; }
  }
  function applyLadderTexts(){
    try {
      var tr = currentTR();
      var b = document.getElementById('btnLadder'); if (b) b.textContent = tr.ladder || 'Ladder';
      var t = document.getElementById('ladderTitle'); if (t) t.textContent = tr.ladderTitle || (tr.ladder || 'Ladder');
      var back = document.getElementById('btnBackFromLadder'); if (back) back.textContent = tr.back || 'Back';
      // Update table headers live if Ladder is open
      var list = document.getElementById('ladderList');
      if (list) {
        var ths = list.querySelectorAll('thead th');
        if (ths && ths.length >= 4) {
          if (ths[0]) ths[0].textContent = tr.rank || 'Rank';
          if (ths[1]) ths[1].textContent = tr.player || 'Player';
          if (ths[2]) ths[2].textContent = tr.roundReached || 'Wave reached';
          if (ths[3]) ths[3].textContent = tr.zombiesKilled || 'Zombies killed';
        }
      }
    } catch(e){}
  }
  function hook(){
    // Patch updateUITexts so any language switch updates Ladder labels immediately
    if (typeof window.updateUITexts === 'function' && !window.__ladderHooked) {
      window.__ladderHooked = true;
      var _u = window.updateUITexts;
      window.updateUITexts = function(){
        try { _u.apply(this, arguments); } catch(_){}
        applyLadderTexts();
      };
    }
    applyLadderTexts();
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', hook, {passive:true}); else hook();

  // Also listen for generic lang change via Mutation (flags toggling currentLang on window)
  (function observeLang(){
    try {
      var last = window.currentLang;
      setInterval(function(){
        if (window.currentLang !== last) { last = window.currentLang; applyLadderTexts(); }
      }, 150);
    } catch(_){}
  })();

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
(function(){
  function qs(id){ return document.getElementById(id); }
  const btnLadder = qs('btnLadder');
  const btnBack = qs('btnBackFromLadder');
  const panelLadder = qs('ladderPanel');
  const panelManual = qs('manualLobbyPanel');
  const panelList = qs('joinLobbyPanel');
  const ladderList = qs('ladderList');

  function showLadder(){
    // Ensure Shop UI is fully closed if open (panel or account modal)
    try { var panelShop = document.getElementById('shopPanel'); if (panelShop) panelShop.style.display = 'none'; } catch(_){}
    try {
      var modal = document.getElementById('authModal');
      if (modal && modal.style.display !== 'none' && document.getElementById('shopUpgradesLobby')) {
        var ov = document.getElementById('authModalOverlay');
        if (ov) ov.style.display = 'none';
        modal.style.display = 'none';
      }
    } catch(_){}

    try { if (panelManual) panelManual.style.display = 'none'; } catch(_){}
    try { if (panelList) panelList.style.display = 'none'; } catch(_){}
    try { if (panelLadder) panelLadder.style.display = 'block'; } catch(_){}
    try { var row = document.getElementById('lobbyBtnRow'); if (row) row.style.display='flex'; } catch(_){}
    try{ if (typeof pseudoInput!=='undefined' && pseudoInput) pseudoInput.style.display='none'; }catch(_){ }
    // Fetch ladder
    fetch('/api/ladder', { method: 'GET' })
      .then(r => r.json().catch(()=>({ok:false})))
      .then(data => {
        try{
          const tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
          if (!data || (data.ok===false)) {
            ladderList.innerHTML = '<div style="text-align:center;color:#ccc;padding:8px;">' + (tr.noData || 'No data') + '</div>';
            return;
          }
          const arr = Array.isArray(data.ladder) ? data.ladder : (Array.isArray(data) ? data : []);
          if (!arr.length) {
            ladderList.innerHTML = '<div style="text-align:center;color:#ccc;padding:8px;">' + (tr.noData || 'No data') + '</div>';
            return;
          }
          // Build table
          let html = '';
          html += '<table style="width:100%; border-collapse:separate; border-spacing:0; font-size:14px;">';
          html += '<thead><tr>';
          html += '<th style="position:sticky;top:0;background:#222;border-bottom:1px solid #333;text-align:left;padding:8px 10px;">' + (tr.rank || 'Rank') + '</th>';
          html += '<th style="position:sticky;top:0;background:#222;border-bottom:1px solid #333;text-align:left;padding:8px 10px;">' + (tr.player || 'Player') + '</th>';
          html += '<th style="position:sticky;top:0;background:#222;border-bottom:1px solid #333;text-align:right;padding:8px 10px;">' + (tr.roundReached || 'Wave reached') + '</th>';
          html += '<th style="position:sticky;top:0;background:#222;border-bottom:1px solid #333;text-align:right;padding:8px 10px;">' + (tr.zombiesKilled || 'Zombies killed') + '</th>';
          html += '</tr></thead><tbody>';
          for (let i=0; i<Math.min(arr.length, 100); i++){
            const it = arr[i] || {};
            const rank = (i+1);
            const name = (it.player || it.pseudo || it.name || '???');
            const wave = (it.wave|0);
            const kills = (it.kills|0);
            html += '<tr style="border-bottom:1px solid rgba(255,255,255,0.06);">';
            html += '<td style="padding:6px 10px; color:#9ab;">#' + rank + '</td>';
            html += '<td style="padding:6px 10px; white-space:normal; overflow:visible; text-overflow:clip; word-break:break-word;">' + escapeHtml(String(name)) + '</td>';
            html += '<td style="padding:6px 10px; text-align:right;">' + wave + '</td>';
            html += '<td style="padding:6px 10px; text-align:right;">' + kills + '</td>';
            html += '</tr>';
          }
          html += '</tbody></table>';
          ladderList.innerHTML = html;
        } catch(e){ try{ ladderList.innerHTML = '<div style="text-align:center;color:#ccc;padding:8px;">Error</div>'; }catch(_){ } }
      })
      .catch(()=>{
        try{ ladderList.innerHTML = '<div style="text-align:center;color:#ccc;padding:8px;">Error</div>'; }catch(_){}
      });
  }
  function showMainFromLadder(){
    try { if (panelLadder) panelLadder.style.display = 'none'; } catch(_){}
    try { if (panelManual) panelManual.style.display = 'none'; } catch(_){}
    try { if (panelList) panelList.style.display = 'none'; } catch(_){}
  
    try{ if (typeof pseudoInput!=='undefined' && pseudoInput){ pseudoInput.style.display=''; if (window.myPseudo && !pseudoInput.value) pseudoInput.value = window.myPseudo; } }catch(_){ }
  }
  function escapeHtml(s){
    return s.replace(/[&<>"]/g, function(c){
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]);
    });
  }

  if (btnLadder) btnLadder.addEventListener('click', async function(){ showLadder(); }, { passive: true });
  if (btnBack) btnBack.addEventListener('click', async function(){
    showMainFromLadder();
    try{
      if (typeof pseudoInput!=='undefined' && pseudoInput){
        var loggedIn = false;
        try { var btnLg = document.getElementById('btnLogout'); loggedIn = !!(btnLg && btnLg.style.display !== 'none'); } catch(_){ }
        pseudoInput.disabled = false;
        if (loggedIn || window.lobbyJoined) {
          pseudoInput.readOnly = true;
          try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }
        } else {
          pseudoInput.readOnly = false;
          try { pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }
        }
        try { if (window.myPseudo) pseudoInput.value = window.myPseudo; } catch(_){ }
        try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){ }
      try{ if (window.enforcePseudoLock) window.enforcePseudoLock(); }catch(_){ }
      }
    }catch(_){ }
  }, { passive: true });

  // Expose for debug
  
  // Close ladder when main action buttons are clicked
  const btnSolo = qs('lobbyJoin');
  const btnJoin = qs('btnJoinLobbyList');
  const btnCreate = qs('btnCreateLobby');
  function hideLadderOnly(){ try { if (panelLadder) panelLadder.style.display = 'none'; } catch(_){} }
  if (btnSolo) btnSolo.addEventListener('click', hideLadderOnly, { passive: true });
  if (btnJoin) btnJoin.addEventListener('click', hideLadderOnly, { passive: true });
  if (btnCreate) btnCreate.addEventListener('click', hideLadderOnly, { passive: true });

  window.showLadder = showLadder;

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<script>
(function(){
  function qs(id){ return document.getElementById(id); }
  const panelShop   = qs('shopPanel');
  const panelManual = qs('manualLobbyPanel');
  const panelList   = qs('joinLobbyPanel');
  const panelLadder = qs('ladderPanel');
  const content     = qs('shopPanelContent');
  const titleEl     = qs('shopPanelTitle');
  const btnBack     = qs('btnBackFromShop');

  const shopSoloBtn  = qs('shopSoloBtn');
  const shopJoinList = qs('shopJoinLobbyListBtn');
  const shopCreate   = qs('shopCreateLobbyBtn');
function applyShopLobbyTexts(){
    try {
      if (btnBack) btnBack.textContent = tr('back','Back');
      if (shopSoloBtn)  shopSoloBtn.textContent  = tr('join','Solo');
      if (shopJoinList) shopJoinList.textContent = tr('joinLobby','Join lobby');
      if (shopCreate)   shopCreate.textContent   = tr('createLobby','Create lobby');
if (titleEl)      titleEl.textContent      = tr('shopMain','Shop');
    } catch(_){}
  }
  applyShopLobbyTexts();

  try { window.applyShopLobbyTexts = applyShopLobbyTexts; } catch(_){ }


  // Bind forwarding actions oncece
  try {
    if (shopSoloBtn && !shopSoloBtn.__bound) {
      shopSoloBtn.__bound = true;
      shopSoloBtn.addEventListener('click', async function(){
        try { hideShopPanel(); } catch(_){}
        try { var el = document.getElementById('lobbyJoin'); if (el) el.click(); } catch(_){}
      }, { passive:true });
    }
    if (shopJoinList && !shopJoinList.__bound) {
      shopJoinList.__bound = true;
      shopJoinList.addEventListener('click', async function(){
        try { hideShopPanel(); } catch(_){}
        try { var el = document.getElementById('btnJoinLobbyList'); if (el) el.click(); } catch(_){}
      }, { passive:true });
    }
    if (shopCreate && !shopCreate.__bound) {
      shopCreate.__bound = true;
      shopCreate.addEventListener('click', async function(){
        try { hideShopPanel(); } catch(_){}
        try { var el = document.getElementById('btnCreateLobby'); if (el) el.click(); } catch(_){}
      }, { passive:true });
    }
  } catch(_) {}

  function tr(key, fallback){
    try {
      var T = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
      return T[key] || fallback || key;
    } catch(_){ return fallback || key; }
  }

  async function renderShopPanel(){
    if (!content) return;
    try {
      if (!document.getElementById('shopUpgradesLobby')) { content.innerHTML = '<div style="padding:8px;color:#9ab;">Loading...</div>'; }
      titleEl.textContent = tr('shopMain','Shop');
      const r = await fetch('/api/me', { credentials:'include' });
      const j = await r.json();
      if (!j || !j.ok){
        try { if (typeof showTopMessage==='function') showTopMessage(tr('needLoginShop','Please log in to access the shop.')); } catch(_){}
        // Return to main list
        hideShopPanel();
        return;
      }
      const T = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang]||TRANSLATIONS['en'])) || {};
      const gold = j.gold|0;
      const up = Object.assign({hp:0,dmg:0}, j.shopUpgrades||{});
      try { window.accountShop = up; } catch(_){}
      try { if (typeof renderShopUpgrades === 'function') renderShopUpgrades(); } catch(_){}

      const hpLv = up.hp|0, dmgLv = up.dmg|0;
      const hpMax = 20, dmgMax = 20, HP_PRICE = 50, DMG_PRICE = 200;

      function item(id, title, desc, level, max, price){
  const disabled = level>=max || gold < price;
  const note = (level>=max) ? '<div style="color:#9ab;font-size:12px;min-height:16px;">'+(T.maxLevel||'Max level reached')+'</div>' : '<div style="min-height:16px;"></div>';
  return (
    '<div style="display:flex;align-items:center;gap:12px;border:1px solid #344;padding:12px;border-radius:12px;margin:8px 0;">'
  + '  <div id="badge-' + id + '" style="width:40px;height:40px;border-radius:10px;border:2px solid #ffb300;display:flex;align-items:center;justify-content:center;font-weight:700;">'
  +        String((id==='hp') ? (100 + (level|0)*10) : (10 + (level|0)*1))
  + '  </div>'
  + '  <div style="flex:1;">'
  + '    <div style="font-size:17px;font-weight:700;">'+title+'</div>'
  + '    <div style="color:#9ab;font-size:13px;">'+desc+'</div>'
  + '    <div style="margin-top:6px;font-size:14px;">'+(T.level||'Level')+': <b>'+level+'</b> / '+max+'</div>'
  + '  </div>'
  + '  <div style=\"display:flex;flex-direction:column;align-items:center;gap:6px;min-width:160px;width:160px;\">'
  + '    <div style="font-size:14px;">'+(T.price||'Price')+': <b>'+price+'</b> '+(T.gold||'Gold')+'</div>'
  + '    <button class="btn-buy" data-shop-buy="'+id+'" style="padding:7px 14px;'+(disabled?'opacity:0.6;cursor:not-allowed;':'cursor:pointer;')+'background:#ff8800;color:#fff;border:none;border-radius:8px;" '+(disabled?'disabled':'')+'>'+(T.buy||'Buy')+'</button>'
  +        note
  + '  </div>'
  + '</div>'
  );
}
// Assemble list
      let html = '';
      html += '<div style="margin-bottom:8px;"><b>'+(T.gold||'Gold')+'</b>: <span id="shopGoldVal">'+gold+'</span></div>';
      const hpTitle = T.hpUpgTitle || 'HP +10';
      const hpDesc  = T.hpUpgDesc  || 'Start each game with +10 HP per level (up to +200).';
      const dmgTitle= T.dmgUpgTitle|| 'Damage +1';
      const dmgDesc = T.dmgUpgDesc || 'Start each game with +1 damage per level (up to +20).';
      html += item('hp',  hpTitle,  hpDesc,  hpLv,  hpMax,  HP_PRICE);
      html += item('dmg', dmgTitle, dmgDesc, dmgLv, dmgMax, DMG_PRICE);
      // Character skin row
      html += (
        '<div data-skin-item="1" style="display:flex;align-items:center;gap:12px;border:1px solid #344;padding:12px;border-radius:12px;margin:8px 0;">'
      + '  <div style="width:40px;height:40px;border-radius:10px;border:2px solid #66c;display:flex;align-items:center;justify-content:center;overflow:hidden;background:#223;">'
      + '    <img src="/sprites/player.png" alt="player" style="width:100%;height:100%;image-rendering:pixelated;object-fit:contain;">'
      + '  </div>'
      + '  <div style="flex:1;">'
      + '    <div style="font-size:17px;font-weight:700;">' + ((T.characterSkin||'Character skin')) + '</div>'
      + '    <div style="color:#9ab;font-size:13px;">' + ((T.characterSkinDesc||'Customize hair, skin and clothes colors.')) + '</div>'
      + '  </div>'
      + '  <div style="display:flex;flex-direction:column;align-items:center;gap:6px;min-width:160px;width:160px;">'
      + '    <div style="font-size:14px;">' + ((T.price||'Price')) + ': <b>20</b> ' + ((T.gold||'Gold')) + '</div>'
      + '    <button class="skinOpenBtn" type="button" style="pointer-events:auto; onclick="try{window.__openCharacterSkin && window.__openCharacterSkin();}catch(e){}" style="pointer-events:auto; padding:7px 14px;background:#4aa3ff;color:#fff;border:none;border-radius:8px;cursor:pointer;">' + ((T.customize||'Customize')) + '</button>'
      + '    <div style="min-height:16px;"></div>'
      + '  </div>'
      + '</div>'
      );

      // Placeholder for turret skins/upgrades if provided by the backend:
      if (j.turretShop && Array.isArray(j.turretShop)){
        j.turretShop.forEach(function(t){
          const id   = String(t.id||'').slice(0,3);
          const name = String(t.title||'Turret');
          const d    = String(t.desc||'');
          const lv   = (t.level|0);
          const mx   = (t.max|0) || 10;
          const pr   = (t.price|0) || 100;
          html += item(id, name, d, lv, mx, pr);
        });
      }
      var __wrap = document.getElementById('shopUpgradesLobby');
      if (__wrap) { __wrap.innerHTML = html; } else { content.innerHTML = '<div id="shopUpgradesLobby">'+html+'</div>'; }

      // Bind purchases
      Array.prototype.slice.call(content.querySelectorAll('[data-shop-buy]')).forEach(function(btn){
        btn.addEventListener('click', async function(){
          const type = this.getAttribute('data-shop-buy');
          try {
            const r = await fetch('/api/shop/buy', {
              method:'POST', headers:{ 'Content-Type': 'application/json' },
              credentials:'include', body: JSON.stringify({ type })
            });
        // Event delegation for Character skin "Customize" button
        try {
          content.addEventListener('click', function(ev){
            var t = ev.target;
            if (!t) return;
            var btn = t.closest ? t.closest('.skinOpenBtn') : null;
            if (!btn) return;
            try {
              if (typeof window.openSkinModal === 'function') window.openSkinModal();
              else if (typeof openSkinModal === 'function') openSkinModal();
            } catch(_) {}
            try { if (typeof window.fetchMe==='function') window.fetchMe(); } catch(_){}
          }, { passive:true });
        } catch(_) {}

            const jj = await r.json();
            if (jj && jj.ok){
              try { if (typeof showTopMessage==='function') showTopMessage(T.purchaseOk || 'Purchase successful.'); } catch(_){}
              refreshShopPanel();
              try { if (typeof drawHUD==='function') drawHUD(); } catch(_){}
            } else {
              if (jj && jj.code === 'not_enough_gold') { try{showTopMessage(T.notEnoughGold||'Not enough gold.');}catch(_){}} 
              else if (jj && jj.code === 'max_level') { try{showTopMessage(T.maxLevel||'Max level reached');}catch(_){}}
              else { try{showTopMessage(T.actionImpossible||'Action impossible.');}catch(_){} }
            }
          } catch(_){
            try{ showTopMessage('Shop not available.'); }catch(_){}
          }
        }, { passive:true });

      // Bind Character skin customize button
      try {
        Array.prototype.slice.call(content.querySelectorAll('.skinOpenBtn')).forEach(function(b){
          if (!b.__bound){
            b.__bound = true;
            b.addEventListener('click', async function(){
              try {
                if (typeof window.fetchMe==='function' && typeof window.openSkinModal==='function') { (window.__openCharacterSkin||window.openSkinModal||openSkinModal||function(){})();; }
                else { setTimeout(function(){ try{ if (typeof window.fetchMe==='function' && typeof window.openSkinModal==='function') (window.__openCharacterSkin||window.openSkinModal||openSkinModal||function(){})();; }catch(_){} }, 50); }
              } catch(_) {}
            }, { passive:true });
          }
        });
      } catch(_){}
      });

    } catch(e){
      console.error(e);
      content.innerHTML = '<div style="padding:8px;color:#e88;">Error loading shop.</div>';
    }
  }

  function hideShopPanel(){
    try { if (panelShop) panelShop.style.display='none'; } catch(_){}
    try { if (panelManual) panelManual.style.display='none'; } catch(_){}
    try { if (panelList) panelList.style.display='none'; } catch(_){}
    try { if (panelLadder) panelLadder.style.display='none'; } catch(_){}
    // Show main lobby buttons + restore pseudo input if needed
    try { var row = document.getElementById('lobbyBtnRow'); if (row) row.style.display=''; } catch(_){}
    try { var pe = document.getElementById('pseudoInput'); if (pe) pe.style.display=''; }catch(_){}
  }
  

  function showShopPanel(){
    try { if (panelManual) panelManual.style.display='none'; } catch(_){}
    try { if (panelList) panelList.style.display='none'; } catch(_){}
    try { if (panelLadder) panelLadder.style.display='none'; } catch(_){}
    try { if (panelShop) panelShop.style.display='block'; } catch(_){}
    try { var row = document.getElementById('lobbyBtnRow'); if (row) row.style.display='none'; } catch(_){}
    try { var pe = document.getElementById('pseudoInput'); if (pe) pe.style.display='none'; }catch(_){}
    renderShopPanel();
  }

  function refreshShopPanel(){
    if (!panelShop || panelShop.style.display!=='block') return;
    renderShopPanel();
  }

  if (btnBack) btnBack.addEventListener('click', async function(){
    // go back to list panel
    hideShopPanel();
    try {
      // show the default lobby panel (buttons)
      var list = qs('joinLobbyPanel'); if (list) list.style.display='none';
      var manual = qs('manualLobbyPanel'); if (manual) manual.style.display='none';
      var ladder = qs('ladderPanel'); if (ladder) ladder.style.display='none';
    } catch(_){}
  }, { passive:true });

  // Close Shop when main action buttons are clicked
  try {
    ['lobbyJoin','btnJoinLobbyList','btnCreateLobby','btnLadder'].forEach(function(id){
      var el = document.getElementById(id);
      if (!el || el.__closeShopBound) return;
      el.__closeShopBound = true;
      el.addEventListener('click', async function(){
        try { if (panelShop && panelShop.style.display === 'block') hideShopPanel(); } catch(_){}
        // also close account Shop modal if open
        try {
          var modal = document.getElementById('authModal');
          if (modal && modal.style.display !== 'none' && document.getElementById('shopUpgradesLobby')) {
            var ov = document.getElementById('authModalOverlay');
            if (ov) ov.style.display = 'none';
            modal.style.display = 'none';
          }
        } catch(_){}
      }, { passive:true });
    });
  } catch(_){}


  // Expose globals used elsewhere
  try { window.showShopPanel = showShopPanel; window.refreshShopPanel = refreshShopPanel; } catch(_){}
})();

  try {
    var _u = window.updateUITexts;
    window.updateUITexts = function(){ try { if (typeof _u==='function') _u.apply(this, arguments); }catch(_){}
      try { if (typeof window.applyShopLobbyTexts==='function') window.applyShopLobbyTexts(); } catch(_){ }try {
        var p = document.getElementById('shopPanel');
        if (p && p.style.display !== 'none' && typeof window.refreshShopPanel === 'function') { window.refreshShopPanel(); }
      } catch(_){}
      try {
        var modal = document.getElementById('authModal');
        if (modal && modal.style.display !== 'none' && document.getElementById('shopUpgradesLobby')) {
          if (typeof window.showModal === 'function') window.showModal('shop');
        }
      } catch(_){}
    };
  } catch(_){}
</script>


  <!-- Visual Debug Console -->
  <style id="debugConsoleStyles">
    #debugConsole { position: fixed; left: 0; right: 0; bottom: 0; max-height: 42vh; z-index: 2147483647; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; line-height: 1.35; background: rgba(0,0,0,0.75); color: #c7f284; overflow-y:auto; padding:6px 8px; display:none; box-shadow: 0 -4px 12px rgba(0,0,0,0.35); }
    #debugConsole .line { white-space: pre-wrap; word-break: break-word; margin: 0; padding: 1px 0; }
    #debugConsoleBar { position: fixed; bottom: 8px; right: 8px; z-index: 2147483647; display:flex; gap:6px; }
    #debugToggle, #debugClear, #debugCopy { font-size: 12px; padding: 6px 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.35); background: rgba(0,0,0,0.65); color: #fff; backdrop-filter: blur(4px); }
    #debugToggle:active, #debugClear:active, #debugCopy:active { transform: translateY(1px); }
    @media (hover:hover) { #debugToggle:hover, #debugClear:hover, #debugCopy:hover { background: rgba(0,0,0,0.8); } }
  </style>
  <div id="debugConsole" aria-label="Debug console (tap to scroll)"></div>
  <!-- <div id="debugConsoleBar" aria-hidden="false">
    <button id="debugToggle" type="button">🐛 Log</button>
    <button id="debugClear" type="button">Clear</button>
    <button id="debugCopy" type="button">Copy</button>
  </div> -->
  <script>
  (function(){
    var dc = document.getElementById('debugConsole');
    var toggle = document.getElementById('debugToggle');
    var clearBtn = document.getElementById('debugClear');
    var copyBtn = document.getElementById('debugCopy');
    var MAX_LINES = 400;
    function fmtArg(a){
      try {
        if (typeof a === 'string') return a;
        if (a === null) return 'null';
        if (typeof a === 'undefined') return 'undefined';
        if (a instanceof Error) return a.name + ': ' + (a.message || String(a));
        var s = JSON.stringify(a);
        return s;
      } catch(e){ try { return String(a); } catch(_) { return '[unprintable]'; } }
    }
    function ts(){
      var d = new Date();
      var ms = String(d.getMilliseconds()).padStart(3,'0');
      return d.toTimeString().slice(0,8) + '.' + ms;
    }
    function write(kind, args){
      try {
        var line = document.createElement('div');
        line.className = 'line';
        var prefix = kind ? ('['+kind+'] ') : '';
        var text = '['+ts()+'] ' + prefix + (args && args.length ? args.map(fmtArg).join(' ') : '');
        line.textContent = text;
        dc.appendChild(line);
        if (dc.childElementCount > MAX_LINES) dc.removeChild(dc.firstChild);
        dc.scrollTop = dc.scrollHeight;
      } catch(e){ /* ignore */ }
    }
    window.debugLog = function(){ try { console.log.apply(console, arguments); } catch(_){} write('LOG', Array.prototype.slice.call(arguments)); };
    window.debugWarn = function(){ try { console.warn.apply(console, arguments); } catch(_){} write('WARN', Array.prototype.slice.call(arguments)); };
    window.debugError = function(){ try { console.error.apply(console, arguments); } catch(_){} write('ERR', Array.prototype.slice.call(arguments)); };
    if (toggle) toggle.addEventListener('click', async function(){ dc.style.display = (dc.style.display === 'block') ? 'none' : 'block'; });
    if (clearBtn) clearBtn.addEventListener('click', async function(){ dc.innerHTML = ''; });
    if (copyBtn) copyBtn.addEventListener('click', async function(){
      try {
        var parts = [];
        try { for (var i=0;i<dc.children.length;i++){ parts.push(dc.children[i].textContent); } } catch(_){ parts.push(dc.textContent || ''); }
        var text = parts.join('\n');
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          var ta = document.createElement('textarea');
          ta.value = text; ta.style.position='fixed'; ta.style.opacity='0'; ta.style.left='-9999px';
          document.body.appendChild(ta); ta.focus(); ta.select(); try { document.execCommand('copy'); } catch(_) {}
          document.body.removeChild(ta);
        }
        var old = copyBtn.textContent; copyBtn.textContent = 'Copied!'; copyBtn.disabled = true;
        debugLog('📋 copied', dc.children.length || 0, 'line(s) to clipboard');
        setTimeout(function(){ copyBtn.textContent = 'Copy'; copyBtn.disabled = false; }, 1400);
      } catch(e){ debugError('copy failed', e && (e.message || e)); }
    });
    // Mirror console.* into overlay
    (function(){
      if (window.__consoleMirror) return;
      var orig = { log: console.log, info: console.info, warn: console.warn, error: console.error };
      function mirror(kind, args){ write(kind, Array.prototype.slice.call(args)); }
      console.log = function(){ try { orig.log.apply(console, arguments); } catch(_){} mirror('LOG', arguments); };
      console.info = function(){ try { orig.info.apply(console, arguments); } catch(_){} mirror('INFO', arguments); };
      console.warn = function(){ try { orig.warn.apply(console, arguments); } catch(_){} mirror('WARN', arguments); };
      console.error = function(){ try { orig.error.apply(console, arguments); } catch(_){} mirror('ERR', arguments); };
      window.__consoleMirror = true;
    })();
  })();
  </script>
  <!-- /Visual Debug Console -->

<script>
(function(){
  if (window.__forceGameEnterInstalled) return;
  window.__forceGameEnterInstalled = true;
  window.forceGameEnter = function(){
    try {
      window.__ingame = true;
      var lobby = document.getElementById('lobbyScreen');
      if (lobby) { lobby.style.setProperty('display','none','important'); }
      try { var m1 = document.getElementById('manualLobbyPanel'); if (m1) m1.style.display = 'none'; } catch(_){}
      try { var m2 = document.getElementById('joinLobbyPanel'); if (m2) m2.style.display = 'none'; } catch(_){}
      try { document.body.classList.remove('menu-hide-ui'); } catch(_){}
      var canvas = document.getElementById('gameCanvas');
      if (canvas) { canvas.style.display='block'; canvas.style.visibility='visible'; canvas.style.opacity='1'; }
      try { var btn = document.getElementById('lobbyJoin'); if (btn) { btn.disabled = true; btn.onclick = null; btn.dataset.clicked='1'; } } catch(_){}
      if (!window.__gameLoopStarted && typeof window.gameLoop === 'function') {
        window.__gameLoopStarted = true;
        debugLog('🎯 forceGameEnter: starting gameLoop()');
        setTimeout(function(){ try { window.gameLoop(); } catch(e){ debugError('gameLoop start error', e && e.message); } }, 120);
      } else {
        debugLog('🎯 forceGameEnter: gameLoop already started');
      }
    } catch(e) { debugError('forceGameEnter error', e && (e.message||e)); }
  };

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
// NON_BLOCKING_GAMESTARTED_HELPER
(function(){
  try {
    socket.on('gameStarted', function(data){
      try {
        // Try to fix myId if not found (solo or from candidate sid)
        if (typeof playersHealth !== 'undefined' && data && data.players) {
          try { playersHealth = data.players; } catch(_){}
          try {
            var ok = (typeof myId !== 'undefined') && playersHealth && playersHealth[myId];
            if (!ok) {
              var cand = window.__candidateSid || (function(){ try { return localStorage.getItem('zombi_candidate_sid'); } catch(_){ return null; } })();
              if (cand && playersHealth[cand]) { myId = cand; debugWarn('🧭 myId fallback to candidateSid:', cand); ok = true; }
              if (!ok) {
                var keys = Object.keys(playersHealth||{});
                if (keys.length === 1) { myId = keys[0]; debugWarn('🧭 myId fallback to sole id:', myId); ok = true; }
              }
            }
            debugLog('🧪 postStart check: myId=', myId, 'hasMine=', !!(playersHealth && myId && playersHealth[myId]), 'keys=', playersHealth ? Object.keys(playersHealth).length : 'n/a');
          } catch(e){ debugWarn('postStart myId check error', e && e.message); }
        }
        if (typeof forceGameEnter === 'function') forceGameEnter();
      } catch(e){ debugError('postStart handler error', e && e.message); }
    });
  } catch(e){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
(function(){
  function attachSocketDebug(s){
    try {
      if (!s || s.__debugAttached) return;
      s.__debugAttached = true;
      debugLog('📡 trying connect to server');
      s.on('connect', function(){
        try { debugLog('✅ connect', 'socket.id=', s.id, 'transport=', s.io && s.io.engine && s.io.engine.transport && s.io.engine.transport.name); } catch(_){}
      });
      try {
        if (s.io && s.io.engine && s.io.engine.on) {
          s.io.engine.on('upgrade', function(tr){ debugLog('⤴️ upgrade →', tr && tr.name); });
        }
      } catch(_){}
      s.on('connect_error', function(err){ debugError('connect_error', err && (err.message || err)); });
      if (s.io && s.io.on) {
        s.io.on('reconnect_attempt', function(n){ debugWarn('reconnect_attempt', n, 'transport=', s.io.engine && s.io.engine.transport && s.io.engine.transport.name); });
        s.io.on('reconnect', function(n){ debugLog('reconnect OK after', n, 'attempt(s), transport=', s.io.engine && s.io.engine.transport && s.io.engine.transport.name); });
        s.io.on('reconnect_error', function(err){ debugError('reconnect_error', err && (err.message || err)); });
        s.io.on('reconnect_failed', function(){ debugError('reconnect_failed'); });
      }
      s.on('disconnect', function(reason){ debugWarn('disconnect', reason); });
      s.on('error', function(err){ debugError('socket error', err && (err.message || err)); });
      // Wrap emit for key events with throttle for setPseudoAndReady
      try {
        var origEmit = s.emit.bind(s);
        s.emit = function(ev){
          var argv = Array.prototype.slice.call(arguments,1);
          
          // --- Injected: normalize callback to surface pseudo_taken/reserved like Create lobby ---
          try {
            var evName = ev;
            // joinLobbyById(payload, cb)
            if (evName === 'joinLobbyById' || evName === 'joinManualLobby') {
              var lastArg = argv[argv.length - 1];
              if (typeof lastArg === 'function') {
                (function(origCb){
                  argv[argv.length - 1] = function(res){
                    try {
                      if (res && !res.ok && (res.reason === 'pseudo_taken' || res.reason === 'reserved')) {
                        try {
                          var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
                          if (res.reason === 'reserved') {
                            showTopMessage(tr.reservedName || 'This nickname is reserved by an account. Choose another one.');
                          } else {
                            if (typeof __alertPseudoTaken === 'function') __alertPseudoTaken();
                            else showTopMessage(tr.pseudoTaken || 'Nickname already in use.');
                          }
                        } catch(_){}
                      }
                    } catch(_){}
                    try { return origCb.apply(this, arguments); } catch(_){}
                  };
                })(lastArg);
              }
            }
          } catch(_){}
          // --- End injected ---
if (ev === 'setPseudoAndReady') {
            try {
              var now = Date.now();
              if (typeof window.__lastJoinEmit === 'number' && (now - window.__lastJoinEmit) < 900) {
                debugWarn('⛔ duplicate setPseudoAndReady blocked within', (now - window.__lastJoinEmit), 'ms');
                return s;
              }
              window.__lastJoinEmit = now;
            } catch(_){}
          }
          if (['setPseudoAndReady','startManualLobby','joinManualLobby','createManualLobby','reclaimPlayer'].indexOf(ev) !== -1) {
            debugLog('📤 emit', ev, argv);
          }
          return origEmit.apply(s, arguments);
        };
      } catch(_){}
      // Incoming markers
      s.on('gameStarted', function(payload){
        try {
          var pcount = payload && payload.players ? Object.keys(payload.players).length : 'n/a';
          debugLog('🎮 gameStarted received', '; players=', pcount);
        } catch(_){}
      });
      s.on('lobbyUpdate', function(data){
        try { debugLog('📥 lobbyUpdate id=', data && data.id, 'started=', data && data.started); } catch(_){}
      });
    } catch(e){ debugWarn('attachSocketDebug error', String(e)); }
  }
  try { attachSocketDebug(window.socket); } catch(_){}
  // Patch global io() to auto-attach for future sockets
  (function(){
    if (!window.io || window.__io_patched_for_debug) return;
    var originalIO = window.io;
    function patchedIO(){
      var s = originalIO.apply(this, arguments);
      try { attachSocketDebug(s); } catch(_){}
      return s;
    }
    try { for (var k in originalIO) { patchedIO[k] = originalIO[k]; } } catch(_){}
    window.io = patchedIO; window.__io_patched_for_debug = true;
  })();

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

  <!-- <!-- <div id="renderProbeBadge" style="position:fixed;left:8px;top:8px;z-index:2147483646;background:rgba(0,0,0,0.5);color:#fff;font:11px/1.3 ui-monospace,monospace;padding:4px 6px;border-radius:6px;display:none">🧪 render-probe</div> --> -->

</script>

<script>
(function(){
  function topmostAtCenter(){
    try {
      var el = document.elementFromPoint(Math.floor(window.innerWidth/2), Math.floor(window.innerHeight/2));
      if (!el) { debugWarn('🧱 topmost@center = null'); return; }
      var id = el.id ? ('#'+el.id) : '';
      var cls = el.className ? ('.'+String(el.className).replace(/\s+/g,'.')) : '';
      debugLog('🧱 topmost@center =', el.tagName+id+cls);
    } catch(e){ try{ debugError('topmost error', e && (e.message||e)); }catch(_){ } }
  }
  function ensureCanvasSize(canvas){
    try {
      if (!canvas) return;
      var ratio = Math.max(1, (window.devicePixelRatio || 1));
      var uiScale = (typeof window.__uiScale === 'number' && window.__uiScale > 0) ? window.__uiScale : 1;
      var cssW = canvas.clientWidth || 0;
      var cssH = canvas.clientHeight || 0;
      if (cssW === 0 || cssH === 0) { cssW = window.innerWidth || 0; cssH = window.innerHeight || 0; }
      var targetW = Math.max(16, Math.floor((cssW * ratio) / uiScale));
      var targetH = Math.max(16, Math.floor((cssH * ratio) / uiScale));
      if (canvas.width !== targetW || canvas.height !== targetH) {
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width = targetW; canvas.height = targetH;
        debugLog('📐 canvas resized attr →', targetW, 'x', targetH, '(css=', cssW, 'x', cssH, 'ratio=', ratio, 'uiScale=', uiScale, ')');
      }
    } catch(e){ try{ debugWarn('ensureCanvasSize error', e && (e.message||e)); }catch(_){ } }
  }
  function drawMarker(canvas){
  try {
    // Disabled: avoid drawing the small green square + 'tick' text on desktop.
    // Return false so any probing logic that depends on this simply no-ops.
    return false;
  } catch(e){ try{ debugError('drawMarker error', e && (e.message||e)); }catch(_){ } return false; }
}
  function readOnePixel(canvas){
    try {
      var ctx = canvas.getContext && canvas.getContext('2d'); if (!ctx) return null;
      var d = ctx.getImageData(3,3,1,1).data; var rgba = [d[0],d[1],d[2],d[3]];
      debugLog('🧬 pixel@3,3 =', rgba.join(',')); return rgba;
    } catch(e){ try{ debugWarn('readOnePixel error', e && (e.message||e)); }catch(_){ } return null; }
  }
  window.ensureCanvasReady = function(){
    try {
      var canvas = document.getElementById('gameCanvas');
      if (!canvas) { debugWarn('🎯 no #gameCanvas'); return; }
      canvas.style.display='block'; canvas.style.visibility='visible'; canvas.style.opacity='1';
      ensureCanvasSize(canvas);
      // Normalize for devicePixelRatio so 1 unit = 1 CSS pixel
      try {
        var ratio = Math.max(1, (window.devicePixelRatio || 1));
      var uiScale = (typeof window.__uiScale === 'number' && window.__uiScale > 0) ? window.__uiScale : 1;
        canvas.style.width = (canvas.clientWidth || window.innerWidth || 0) + 'px';
        canvas.style.height = (canvas.clientHeight || window.innerHeight || 0) + 'px';
        var ctx2d = canvas.getContext && canvas.getContext('2d');
        if (ctx2d) { ctx2d.setTransform(ratio,0,0,ratio,0,0); debugLog('🔎 DPR applied to 2D context:', ratio); }
      } catch(_) {}

      topmostAtCenter();
      var __ua = (navigator.userAgent||'');
      var __isMobile = /Android|iPhone|iPad|iPod|Mobile|Windows Phone/i.test(__ua) || (Math.max(window.innerWidth||0, window.innerHeight||0) <= 812);
      var ok = false;
      if (!__isMobile) { ok = drawMarker(canvas); if (ok) { readOnePixel(canvas); } }
      var badge = document.getElementById('renderProbeBadge'); 
      if (badge) { badge.style.display='block'; setTimeout(function(){ try{ badge.style.display='none'; }catch(_){ } }, 2000); }
    } catch(e){ try{ debugError('ensureCanvasReady error', e && (e.message||e)); }catch(_){ } }
  };
  window.addEventListener('orientationchange', function(){ try{ ensureCanvasReady(); }catch(_){ } });
  window.addEventListener('resize', function(){ try{ ensureCanvasReady(); }catch(_){ } });
  setTimeout(function(){ try{ ensureCanvasReady(); }catch(_){ } }, 500);

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
// GAMESTARTED_CANVASREADY_HELPER
try { if (window.socket && socket.on) { socket.on('gameStarted', function(){ try { if (window.ensureCanvasReady) ensureCanvasReady(); } catch(_){ } }); } } catch(_){}
</script>

<style id="mobile-portrait-lock-and-size-overrides">
/* === Mobile portrait "lock" & UI size tweaks (no effect on desktop) === */

/* Fullscreen rotate overlay (only shows on mobile + landscape) */
#rotateOverlay{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.9);
  color: #fff;
  z-index: 2147483647;
  font-weight: 700;
  text-align: center;
  padding: 28px;
  line-height: 1.35;
  -webkit-user-select: none;
  user-select: none;
}

@media (hover: none) and (pointer: coarse) and (orientation: landscape){
  #rotateOverlay{ display: flex; }
}

/* Mobile-only UI sizing + right alignment for build tiles */
@media (hover: none) and (pointer: coarse){
  /* Make build tiles hug the right edge */
  #buildTiles{ justify-content: flex-end; }
  /* Slightly smaller shop & auto-fire buttons */
  #shopBtn{ font-size: 18px !important; padding: 8px 18px 8px 14px !important; }
  #autoFireBtn{ font-size: 14px !important; padding: 3px 8px 3px 5px !important; gap: 6px !important; }
  #autoFireBtn > span:first-child{ width: 12px !important; height: 12px !important; }

  /* Smaller construction blocks */
  #buildTiles .build-tile > div:first-child{ width: 36px !important; height: 36px !important; }
  #buildTiles .build-tile > div + div{ font-size: 12px !important; padding: 2px 6px !important; }

  /* Keep the bar tight to the right/bottom on mobile */
  #buildBar{ right: 12px !important; bottom: 112px !important; gap: 8px !important; }
}
</style>


<script id="mobile-portrait-lock-and-zoom">
(function(){
  const isMobile = window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse)').matches;

  // Ensure overlay node exists (idempotent)
  function ensureRotateOverlay(){
    if (!document.getElementById('rotateOverlay')){
      const d = document.createElement('div');
      d.id = 'rotateOverlay';
      d.setAttribute('aria-hidden', 'true');
      d.textContent = (window.trLoc ? trLoc('rotateToPortrait', 'Rotate your device to portrait.') : 'Rotate your device to portrait.');
      document.body.appendChild(d);
    }
  }

  // Best-effort portrait lock using Screen Orientation API (requires user gesture/fullscreen on many browsers)
  async function tryLockPortrait(){
    if (!isMobile) return;
    try {
      if (screen.orientation && screen.orientation.lock){
        await screen.orientation.lock('portrait');
      }
    } catch(_e){
      // ignore — overlay + CSS will enforce UX when in landscape
    }
  }

  function once(el, ev, fn, opts){
    const wrap = function(e){ try{ fn(e); }finally{ el.removeEventListener(ev, wrap, opts);} };
    el.addEventListener(ev, wrap, opts);
  }

  // Inject overlay ASAP
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureRotateOverlay, {passive:true});
  } else {
    ensureRotateOverlay();
  }

  if (isMobile){
    // Try to lock on first user interaction
    ['pointerup','touchend','click'].forEach(ev => once(window, ev, tryLockPortrait, {passive:true}));
    // Retry on orientation changes
    window.addEventListener('orientationchange', tryLockPortrait, {passive:true});
  }

  // Zoom out a bit when the game starts (mobile only) — relies on existing pinchScale/updateRenderScale
  function mobileZoomOut(){
    if (!isMobile) return;
    try {
      // Respect existing clamp constants if present
      var minP = (typeof MIN_PINCH === 'number') ? MIN_PINCH : 0.6;
      var maxP = (typeof MAX_PINCH === 'number') ? MAX_PINCH : 1.6;
      var target = 0.85; // slightly zoomed out
      if (typeof pinchScale === 'number') {
        pinchScale = Math.max(minP, Math.min(maxP, target));
      } else {
        window.pinchScale = target;
      }
      if (typeof updateRenderScale === 'function') updateRenderScale();
    } catch(_e){ /* no-op */ }
  }

  try {
    if (window.socket && typeof socket.on === 'function'){
      socket.on('gameStarted', function(){ tryLockPortrait(); mobileZoomOut(); });
    } else {
      // Fallback: if socket arrives later, hook then
      const iv = setInterval(function(){
        if (window.socket && typeof socket.on === 'function'){
          clearInterval(iv);
          socket.on('gameStarted', function(){ tryLockPortrait(); mobileZoomOut(); });
        }
      }, 120);
      setTimeout(()=>clearInterval(iv), 10000);
    }
  } catch(_e){ /* ignore */ }
})();










// ---- Mobile drag-to-place: select block, drag on canvas, auto-place on release ----
(function(){
  try {
    var touchCap = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    if (!touchCap) return;
    if (!canvas || canvas.__dragPlaceV2) return;
    canvas.__dragPlaceV2 = true;

    var placing = false;
    var activeId = null;
    var lastX = 0, lastY = 0;

    function findById(e, id){
      if (!e) return null;
      var pools = [e.touches, e.changedTouches];
      for (var p=0; p<pools.length; p++){
        var list = pools[p] ? Array.prototype.slice.call(pools[p]) : [];
        for (var i=0;i<list.length;i++){ if (list[i].identifier === id) return list[i]; }
      }
      return null;
    }

    function ts(e){
      if (!buildMode) return;
      if (!(e.touches && e.touches.length === 1)) return; // ignore multi-touch (pinch/joysticks)
      var t = e.changedTouches && e.changedTouches[0];
      if (!t) return;
      // ignore if touch starts on joystick
      try{
        var el = document.elementFromPoint(t.clientX, t.clientY);
        if (el && el.classList && (el.classList.contains('joystick-base') || el.classList.contains('joystick-stick'))) return;
      }catch(_){}
      placing = true; activeId = t.identifier;
      lastX = t.clientX; lastY = t.clientY;
      var st = screenToWorldTile(lastX, lastY);
      buildHover.tx = st.tx; buildHover.ty = st.ty;
      e.preventDefault(); e.stopPropagation();
    }
    function tm(e){
      if (!placing || !buildMode) return;
      var t = findById(e, activeId) || (e.changedTouches && e.changedTouches[0]);
      if (!t) return;
      lastX = t.clientX; lastY = t.clientY;
      var st = screenToWorldTile(lastX, lastY);
      buildHover.tx = st.tx; buildHover.ty = st.ty;
      e.preventDefault(); e.stopPropagation();
    }
    function te(e){
      if (!placing) return;
      // Use last coords
      try {
        tryPlaceStructureAtCursor(lastX, lastY);
      } catch(_){}
      placing = false; activeId = null;
      // Exit build mode so auto-fire & other controls are usable immediately
      try { buildMode = null; buildHover = { tx:-1, ty:-1 }; } catch(_){}
      try { if (document && document.body && document.body.dataset) document.body.dataset.buildMode = ''; } catch(_){}
try { if (window.__applyBuildTileHighlight) window.__applyBuildTileHighlight(); } catch(_){}
e.preventDefault(); e.stopPropagation();
    }

    canvas.addEventListener('touchstart', ts,   { passive: false });
    canvas.addEventListener('touchmove',  tm,   { passive: false });
    canvas.addEventListener('touchend',   te,   { passive: false });
    canvas.addEventListener('touchcancel',te,   { passive: false });
  } catch(_e) { /* ignore */ }
})();
// ---- /Mobile drag-to-place ----

</script>



<script id="buildtile-highlight">
(function(){
  if (window.__buildTileHighlightSetup) return;
  window.__buildTileHighlightSetup = true;

  function currentBuildMode() {
    try {
      if (typeof buildMode !== 'undefined' && buildMode !== null) return buildMode;
    } catch(_){}
    try {
      if (typeof window.buildMode !== 'undefined' && window.buildMode !== null) return window.buildMode;
    } catch(_){}
    try {
      if (document.body && document.body.dataset && document.body.dataset.buildMode) return document.body.dataset.buildMode;
    } catch(_){}
    return null;
  }

  function applyBuildTileHighlight(){
    try{
      var mode = currentBuildMode();
      var tiles = document.querySelectorAll('#buildTiles .build-tile');
      tiles.forEach(function(btn){
        try{
          var type = btn.getAttribute('data-type');
          if (mode && mode === type) { btn.classList.add('mb-selected'); }
          else { btn.classList.remove('mb-selected'); }
        }catch(_){}
      });
    }catch(_){}
  }

  // filet de sécurité périodique
  try { setInterval(applyBuildTileHighlight, 200); } catch(_){}

  // clics dans le conteneur
  try {
    var cont = document.getElementById('buildTiles');
    if (cont) cont.addEventListener('click', async function(){ setTimeout(applyBuildTileHighlight, 0); }, true);
  } catch(_){}

  // patch non intrusif
  try {
    var orig = window.updateBuildTilesState;
    if (typeof orig === 'function'){
      window.updateBuildTilesState = function(){
        try { orig.apply(this, arguments); } catch(_){}
        applyBuildTileHighlight();
      };
    }
  } catch(_){}

  // expose pour débogage
  try { window.__applyBuildTileHighlight = applyBuildTileHighlight; } catch(_){}

  applyBuildTileHighlight();

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>




<script id="build-tooltip-stabilizer">
(function(){
  try{
    if (window.__buildTooltipStabilizer) return;
    window.__buildTooltipStabilizer = true;

    // --- 1) Kill legacy duplicates early (but keep references safe)
    function nodelistToArray(nl){ try { return Array.prototype.slice.call(nl||[]); } catch(_){ return []; } }
    function disableLegacyTooltips(){
      try{
        var olds = document.querySelectorAll('#buildTooltip');
        nodelistToArray(olds).forEach(function(el){
          try{
            el.style.display = 'none';
            el.setAttribute('aria-hidden','true');
            el.dataset.disabled = '1';
            if (el.parentNode) el.parentNode.removeChild(el); // detach from DOM; refs remain safe
          }catch(_){}
        });
      }catch(_){}
    }
    disableLegacyTooltips();

    // --- 2) Stable tooltip node (single instance, fixed to viewport)
    function ensureStableTooltip(){
      var box = document.getElementById('buildTooltipStable');
      if (box) return box;
      box = document.createElement('div');
      box.id = 'buildTooltipStable';
      // UI-safe styles
      box.style.position = 'fixed';
      box.style.display = 'none';
      box.style.left = '0';
      box.style.top = '0';
      box.style.maxWidth = '320px';
      box.style.padding = '6px 8px';
      box.style.borderRadius = '8px';
      box.style.background = '#111c';
      box.style.color = '#fff';
      box.style.fontSize = '13px';
      box.style.lineHeight = '1.2';
      box.style.boxShadow = '0 4px 18px #000a';
      box.style.pointerEvents = 'none';
      box.style.whiteSpace = 'nowrap';
      box.style.zIndex = '2147480000';
      box.setAttribute('role','tooltip');
      document.body.appendChild(box);
      return box;
    }
    window.getBuildTooltipBox = ensureStableTooltip;

    // Utility: localized strings where possible (non-throwing)
    function uiLang(){
      try {
        var L = (window.currentLang || (navigator.language||'en')).slice(0,2);
        var alias = { fr:'fr', en:'en', es:'es', de:'de', it:'it', pt:'pt' };
        return alias[L] || 'en';
      } catch(_){ return 'en'; }
    }
    function upperFirstLocalizedSafe(s){
      try{
        if (!s) return s;
        var i = s.search(/[A-Za-zÀ-ÖØ-öø-ÿĀ-žА-Яа-яЁё]/u);
        if (i < 0) return s;
        return s.slice(0, i) + s.charAt(i).toUpperCase() + s.slice(i + 1);
      }catch(_){
        try { return s.charAt(0).toUpperCase() + s.slice(1); } catch(__){ return s; }
      }
    }
    function computeTurretDamageDisplay(type){
      try { if (typeof window.computeTurretDamageDisplay === 'function') return window.computeTurretDamageDisplay(type); }
      catch(_){}
      // Fallbacks
      return (type==='t')?5 : (type==='T')?10 : 25;
    }
    function computeTipForType(type){
      try {
        if (typeof window.computeTipForType === 'function'){
          var v = window.computeTipForType(type);
          if (v) return v;
        }
      } catch(_){}
      var T = window.TRANSLATIONS || {};
      var tr = (T[uiLang()] || T['en']) || {};
      var names = tr.turretType || {};
      var hpLabel = tr.hpShort || 'HP';
      var dmgLabel = tr.damage || 'Damage';
      var rateLabel = tr.fireRate || 'Fire rate';
      var perSec = tr.perSec || '/s';
      var baseHP = { T:500, t:200, G:2500, B:500, D:500 };
      var name = (type==='B') ? (tr.buildWall || 'Wall')
               : (type==='D') ? (tr.buildDoor || 'Door')
               : (names[type] || 'Turret');
      name = upperFirstLocalizedSafe(name);
      if (type==='B' || type==='D'){
        return name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ')';
      } else {
        var rate = (type==='T') ? '1' : (type==='G') ? '2' : '0.5';
        var dmg = computeTurretDamageDisplay(type);
        return name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ', ' + dmgLabel + ': ' + dmg + ', ' + rateLabel + ': ' + rate + perSec + ')';
      }
    }

    // --- 3) Delegated hover for original Build bar (robust to re-renders)
    function attachDelegatedTooltip(container){
      if (!container || container.__tooltipBound) return;
      container.__tooltipBound = true;

      var box = ensureStableTooltip();
      var overEl = null;

      function showFor(el, clientX, clientY){
        try{
          var type = el.getAttribute('data-type');
          var tip = computeTipForType(type);
          box.textContent = tip || '';
          // Position near cursor if coords provided, else near element
          var x = clientX, y = clientY;
          if (typeof x !== 'number' || typeof y !== 'number'){
            var r = el.getBoundingClientRect();
            x = r.left + r.width/2;
            y = r.top - 8;
          }
          x = Math.max(8, Math.min((window.innerWidth||800) - 8, x));
          y = Math.max(8, Math.min((window.innerHeight||600) - 8, y));
          box.style.left = (x + 10) + 'px';
          box.style.top  = (y - 10) + 'px';
          box.style.display = 'block';
        }catch(_){}
      }
      function hideBox(){
        try { box.style.display = 'none'; } catch(_){}
      }

      container.addEventListener('mouseover', function(ev){
        var t = ev.target;
        if (!t) return;
        if (!t.classList) return;
        if (!t.classList.contains('build-tile')){
          t = t.closest ? t.closest('.build-tile') : null;
        }
        if (!t) return;
        overEl = t;
        showFor(t, ev.clientX, ev.clientY);
      }, { passive:true, capture:true });

      container.addEventListener('mousemove', function(ev){
        try {
          // If the pointer is no longer over a .build-tile, hide the tooltip
          var t = ev.target;
          var tile = (t && t.classList && t.classList.contains('build-tile')) ? t : (t && t.closest ? t.closest('.build-tile') : null);
          if (!tile) {
            overEl = null;
            hideBox();
            return;
          }
          // Otherwise, keep following the cursor for the last tile we hovered
          if (!overEl) overEl = tile;
          showFor(overEl, ev.clientX, ev.clientY);
        } catch(_){}
      }, { passive:true, capture:true });

      container.addEventListener('mouseleave', function(){
        overEl = null;
        hideBox();
  
      // Also hide when the mouse truly leaves a tile but remains inside the container
      container.addEventListener('mouseout', function(ev){
        try {
          var t = ev.target;
          if (!t || !t.classList || !t.classList.contains('build-tile')) return;
          var rel = ev.relatedTarget;
          if (rel && (rel===t || (rel.closest && rel.closest('.build-tile')===t))) return; // moving within same tile
          overEl = null;
          hideBox();
        } catch(_){}
      }, { passive:true, capture:true });
    }, { passive:true, capture:true });
    }

    function initDelegation(){
      var wrap = document.getElementById('buildTiles');
      if (wrap) { attachDelegatedTooltip(wrap); return; }
      // Observe until it exists
      if (window.MutationObserver){
        var mo = new MutationObserver(function(){
          var w = document.getElementById('buildTiles');
          if (w){ try { attachDelegatedTooltip(w); mo.disconnect(); } catch(_){ } }
        });
        mo.observe(document.documentElement || document.body, { childList:true, subtree:true });
      }
    }
    initDelegation();

  }catch(e){
    try { console.error('[build-tooltip-stabilizer] failed', e); } catch(_){}
  }
})();
</script>

<!-- Account Gold Shop Modal -->


      <button id="accountShopClose" style="border:none; background:#333; color:#fff; padding:6px 10px; border-radius:8px; cursor:pointer;">✕</button>
    </div>
    <div id="accountGoldLine" style="margin:8px 0 14px; font-size:16px;"><b>Gold</b>: <span id="accountGoldValue">0</span></div>
    <div id="accountShopItems"></div>
    <div style="margin-top:10px; font-size:12px; color:#9ab;" id="accountShopHint"></div>
  </div>
</div>


<script>
// Ultra-robust Shop button watchdog: ensures the button exists, is visible, and is bound like other buttons.
(function(){
  if (window.__shopBtnWatchInstalled) return; window.__shopBtnWatchInstalled = true;
  function ensureShopButton(){
    try{
      var row = document.getElementById('ladderBtnRow');
      if (!row) return;
      var btn = document.getElementById('btnAccountShop');
      if (!btn){
        btn = document.createElement('button');
        btn.id = 'btnAccountShop';
        btn.textContent = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang]||TRANSLATIONS['en'])||{}).shopMain || 'Shop';
        btn.setAttribute('style', 'font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#ff8800; color:#fff; cursor:pointer; margin-top:7px;');
        row.appendChild(btn);
      } else {
        // ensure visible
        btn.style.display = '';
        btn.style.pointerEvents = 'auto';
      }
      if (!btn.__shopBound){
        btn.addEventListener('click', async function(){ try{ if (typeof showModal==='function') (typeof window.refreshShopPanel==='function' ? window.refreshShopPanel() : (typeof showModal==='function' ? showModal('shop') : void 0)); }catch(e){ console.error(e); } }, { passive:true });
        btn.__shopBound = true;
      }
    }catch(e){}
  }
  function relabel(){
    try{
      var btn = document.getElementById('btnAccountShop');
      if (!btn) return;
      var T = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang]||TRANSLATIONS['en'])) || {};
      var label = T.shopMain || 'Shop';
      if (btn.textContent !== label) btn.textContent = label;
    }catch(_){}
  }
  ensureShopButton(); relabel();
  try{ var mo = new MutationObserver(function(){ ensureShopButton(); relabel(); }); mo.observe(document.body, { childList:true, subtree:true }); }catch(_){}
  try{ setInterval(function(){ ensureShopButton(); relabel(); }, 1200); }catch(_){}
  // hook updateUITexts
  try {
    var u = window.updateUITexts;
    window.updateUITexts = function(){ try { if (typeof u==='function') u.apply(this, arguments); }catch(_){}
      try { relabel(); } catch(_){};
    };
  } catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<script>
(function(){
  if (window.__hudGoldInstalled) return; window.__hudGoldInstalled = true;
  try { window.accountGold = window.accountGold|0; } catch(_){}
  try {
    fetch('/api/me', { credentials:'include' })
      .then(function(r){ return r.json(); })
      .then(function(j){ if (j && j.ok){ window.__meOk = true; window.accountGold = j.gold|0; window.accountShop = Object.assign({hp:0,dmg:0}, (j.shopUpgrades||{}));
            try { if (typeof renderShopUpgrades === 'function') renderShopUpgrades(); } catch(_){}
            try { if (typeof window.updateAccountShopBadges === 'function') window.updateAccountShopBadges(); } catch(_){}
             try{ window.linkSocketToSession && window.linkSocketToSession(); }catch(_){ } } })
      .catch(function(){});
  } catch(_){}
  try {
    if (window.socket) {
      socket.on('goldUpdate', function(p){
        try { if (p && Number.isFinite(p.total)) { window.__meOk = true; window.accountGold = p.total|0; } } catch(_){}
      });
    }
  } catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<!-- VIEWPORT & FULLSCREEN SIZING FIX -->
<style id="viewport-fullscreen-fix">
  :root{ --vh: 1vh; }
  /* Use dynamic viewport units when supported, fallback to JS-set --vh */
  #gameCanvas, #deathScreen, #lobbyScreen{
    height: calc(var(--vh, 1vh) * 100) !important;
  }
  @supports (height: 100dvh){
    #gameCanvas, #deathScreen, #lobbyScreen{
      height: 100dvh !important;
    }
  }
</style>
<script id="viewport-fullscreen-fix-js">
(function(){
  if (window.__viewportFixInstalled) return;
  window.__viewportFixInstalled = true;
  function setVH(){
    try{
      var vh = (window.innerHeight||0) * 0.01;
      document.documentElement.style.setProperty('--vh', vh + 'px');
    }catch(_){}
  }
  window.__setVHUnit = setVH;
  ['load','resize','orientationchange','fullscreenchange','webkitfullscreenchange','mozfullscreenchange','MSFullscreenChange','pageshow'].forEach(function(ev){
    try{ window.addEventListener(ev, setVH, { passive:true }); }catch(_){}
  });
  // ensure once
  setVH();
  // also when the game starts or we programmatically enter the game, fix sizes
  try{
    if (window.socket && socket.on){
      socket.on('gameStarted', function(){ try{ setVH(); if (window.ensureCanvasReady) ensureCanvasReady(); }catch(_){} });
    }
  }catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<!-- /VIEWPORT & FULLSCREEN SIZING FIX -->

<!-- MAIN BUTTON RESCUE (re-enable Solo/Create after quick leave) -->
<script id="main-buttons-rescue">
(function(){
  if (window.__mainBtnRescueInstalled) return;
  window.__mainBtnRescueInstalled = true;
  function rescue(){
    try{
      // Leaving to main menu means we're not in a lobby anymore
      window.lobbyJoined = false;
      var pseudoEl = document.getElementById('pseudoInput');
      var hasPseudo = !!(pseudoEl && pseudoEl.value && pseudoEl.value.trim());
      ['lobbyJoin','btnCreateLobby','btnJoinLobbyList'].forEach(function(id){
        var b = document.getElementById(id);
        if (b){
          // Only disable if no pseudo; otherwise ensure enabled
          b.disabled = !hasPseudo ? true : false;
        }
      });
      try{ if (typeof window.updateButtonsDisabled === 'function') window.updateButtonsDisabled(); }catch(_){}
    }catch(_){}
  }
  window.rescueMainButtons = rescue;
  try{
    var lobby = document.getElementById('lobbyScreen');
    if (lobby && window.MutationObserver){
      var mo = new MutationObserver(function(){
        try{
          // If the lobby overlay is visible again, fix buttons immediately
          var shown = (lobby.style.display !== 'none');
          if (shown) rescue();
        }catch(_){}
      });
      mo.observe(lobby, { attributes:true, attributeFilter:['style','class'] });
    }
  }catch(_){}
  // Also run on focus/pageshow
  try{ window.addEventListener('focus', rescue, {passive:true}); }catch(_){}
  try{ window.addEventListener('pageshow', rescue, {passive:true}); }catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<!-- /MAIN BUTTON RESCUE -->


<script id="canvas-fullscreen-ensure">
(function(){
  if (window.__canvasFullscreenEnsureInstalled) return;
  window.__canvasFullscreenEnsureInstalled = true;
  function ensure(){ try{ if (window.ensureCanvasReady) ensureCanvasReady(); }catch(_){ } }
  ['fullscreenchange','webkitfullscreenchange','mozfullscreenchange','MSFullscreenChange'].forEach(function(ev){
    try{ window.addEventListener(ev, ensure, {passive:true}); }catch(_){}
  });

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>


<!-- CANVAS-FIT ULTIMATE PATCH -->
<style id="canvas-fit-css">
  html, body { margin:0; padding:0; height:100%; }
  #gameCanvas, #lobbyScreen, #deathScreen{
    width: 100vw !important;
    height: calc(var(--vh, 1vh) * 100) !important;
  }
  @supports (height: 100dvh){
    #gameCanvas, #lobbyScreen, #deathScreen{
      height: 100dvh !important;
    }
  }
</style>
<script id="canvas-fit-ultimate">
(function(){
  if (window.__canvasFitInstalled) return;
  window.__canvasFitInstalled = true;

  function computeVHUnit(){
    try{
      var vh = (window.innerHeight||document.documentElement.clientHeight||1) * 0.01;
      document.documentElement.style.setProperty('--vh', vh + 'px');
    }catch(_){}
  }

  function canvasFit(){
    try{
      var canvas = document.getElementById('gameCanvas');
      if (!canvas) return;

      // Ensure the CSS covers the viewport
      try{
        canvas.style.width = '100vw';
        canvas.style.height = 'calc(var(--vh, 1vh) * 100)';
      }catch(_){}

      // Use the actual rendered size to set the backing resolution
      var rect = canvas.getBoundingClientRect();
      var w = Math.max(1, Math.round(rect.width || window.innerWidth || document.documentElement.clientWidth || screen.width || 1));
      var h = Math.max(1, Math.round(rect.height || window.innerHeight || document.documentElement.clientHeight || screen.height || 1));

      if (canvas.width !== w) canvas.width = w;
      if (canvas.height !== h) canvas.height = h;
    }catch(_){}
  }

  window.resizeCanvas = canvasFit; // override any previous definition
  window.__ensureCanvasReady = canvasFit;

  // Respond to all relevant viewport changes
  ['load','resize','orientationchange','pageshow','visibilitychange',
   'fullscreenchange','webkitfullscreenchange','mozfullscreenchange','MSFullscreenChange'
  ].forEach(function(ev){
    try{ window.addEventListener(ev, function(){ computeVHUnit(); canvasFit(); }, { passive:true }); }catch(_){}
  });

  // If sockets are present, attach to game/lobby events too
  try{
    if (window.socket && window.socket.on){
      socket.on('gameStarted', function(){ computeVHUnit(); canvasFit(); });
      socket.on('lobbyUpdate', function(){ computeVHUnit(); canvasFit(); });
    }
  }catch(_){}

  // First run + gentle watchdog (covers rare missed events)
  computeVHUnit();
  setTimeout(canvasFit, 0);
  setTimeout(canvasFit, 250);
  setInterval(canvasFit, 1000);

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<!-- /CANVAS-FIT ULTIMATE PATCH -->

<!-- MAIN BUTTON RESCUE 2 (clear fast-quit locks) -->
<script id="main-buttons-rescue-2">
(function(){
  if (window.__mainBtnRescue2Installed) return;
  window.__mainBtnRescue2Installed = true;

  function resetMainButtons(){
    try{
      // Clear fast-click locks
      try{ window.__joinLockTs = 0; }catch(_){}
      var ids = ['lobbyJoin','btnCreateLobby','btnJoinLobbyList'];
      for (var i=0;i<ids.length;i++){
        var b = document.getElementById(ids[i]);
        if (!b) continue;
        b.disabled = false;
        try{ b.dataset.clicked = ''; b.removeAttribute('data-clicked'); }catch(_){}
      }
      try{ if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); }catch(_){}
    }catch(_){}
  }

  function onLobbyVisible(){
    try{
      var lobby = document.getElementById('lobbyScreen');
      if (!lobby) return;
      // Run immediately when called
      resetMainButtons();
    }catch(_){}
  }

  try{
    var lobby = document.getElementById('lobbyScreen');
    if (lobby && window.MutationObserver){
      var mo = new MutationObserver(onLobbyVisible);
      mo.observe(lobby, {attributes:true, attributeFilter:['style','class']});
    }
  }catch(_){}
  ['pageshow','focus','visibilitychange'].forEach(function(ev){
    try{ window.addEventListener(ev, onLobbyVisible, { passive:true }); }catch(_){}
  });
  try{ if (window.socket && window.socket.on){ socket.on('lobbyUpdate', onLobbyVisible); } }catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<!-- /MAIN BUTTON RESCUE 2 -->

<script>
// Flash the nickname field red and restore last accepted pseudo (or empty)
(function(){
  if (window.__flashPseudoErrorInstalled) return;
  window.__flashPseudoErrorInstalled = true;
  window.__flashPseudoError = function(){
    try{
      var pseudoInput = document.getElementById('pseudoInput');
      if (!pseudoInput) return;
      // revert to last accepted nickname if available
      var fallback = (typeof window.myPseudo === 'string' && window.myPseudo) ? window.myPseudo : '';
      try { pseudoInput.value = fallback; } catch(_){}
      var old = pseudoInput.style.background;
      pseudoInput.style.background = '#3b0000';
      setTimeout(function(){ try{ pseudoInput.style.background = old || ''; }catch(_){} }, 450);
    }catch(_){}
  };

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>

<script>
// Global color sanitizer to normalize hex (accepts pure black/white).
// Defined globally so all modules (picker, inputs, preview) can use it safely.
window.__sanitizeHex = window.__sanitizeHex || function(hex){
  try{
    hex = String(hex||'').trim().toLowerCase();
    if (hex[0] !== '#') hex = '#' + hex;
    if (hex.length === 4) hex = '#' + hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
    if (!/^#[0-9a-f]{6}$/.test(hex)) hex = '#111111';
    /* allow pure black */
    /* allow pure white */
    return hex;
  } catch(_){ return '#111111'; }
};
</script>

<script>
// [PATCH] language-change sync for skin modal (no reload needed)
(function(){
  try {
    var prevUpdate = window.updateUITexts;
    if (typeof prevUpdate !== 'function') return;
    if (prevUpdate.__skinLocalePatched) return;
    function refreshSkinLocale(){
      try{
        var skin = document.getElementById('skinModal');
        var wasOpen = false;
        try { wasOpen = (skin && skin.style && skin.style.display !== 'none'); } catch(_){}
        if (skin && skin.parentNode) skin.parentNode.removeChild(skin);
        // Recreate skeleton to keep handlers ready if needed
        try { if (typeof window.ensureSkinModal === 'function') window.ensureSkinModal(); } catch(_){}
        if (wasOpen) { try { if (typeof window.openSkinModal === 'function') window.openSkinModal(); } catch(_){} }
      }catch(_){}
    }
    function patchedUpdateUITexts(){
      try { prevUpdate.apply(this, arguments); } catch(_){}
      // Also refresh skin modal texts immediately if present
      try { refreshSkinLocale(); } catch(_){}
    }
    patchedUpdateUITexts.__skinLocalePatched = true;
    window.updateUITexts = patchedUpdateUITexts;
  } catch(_){}
})();
</script>

<div id="versionBox"></div>
<div id="workerBox" title="Server"></div>

<script>
// === Robust pseudo guard for "Join lobby" and "Send" (inspired by Create lobby) ===
(function(){
  try {
    var pseudoInput = document.getElementById('pseudoInput');

    // Guard for the main "Join" button on the manual/lobby screen
    var joinBtn = document.getElementById('lobbyJoin');
    if (joinBtn && !joinBtn.__pseudoGuardInstalled) {
      joinBtn.__pseudoGuardInstalled = true;
      joinBtn.addEventListener('click', function(ev){
        try {
          var p = (pseudoInput && pseudoInput.value ? pseudoInput.value : '').trim();
          if (!p) return;

          var taken = false;
          // Prefer authoritative source: current lobby player's map
          try {
            var meId = (window.socket && socket.id) || null;
            var playersMap = (window.lobbyData && window.lobbyData.players) ? window.lobbyData.players : {};
            for (var sid in playersMap) {
              if (!playersMap.hasOwnProperty(sid)) continue;
              if (sid === meId) continue;
              var nm = (playersMap[sid] && playersMap[sid].pseudo) ? String(playersMap[sid].pseudo) : '';
              if (nm && nm.trim().toLowerCase() === p.toLowerCase()) { taken = true; break; }
            }
          } catch(_){}

          if (taken) {
            try { __alertPseudoTaken(); } catch(_){}
            ev.stopImmediatePropagation(); ev.preventDefault();
            return;
          }
        } catch(_){}
      }, true); // capture to run before other listeners
    }

    // Guard for chat "Send" button
    var sendBtn = document.getElementById('chatSend');
    if (sendBtn && !sendBtn.__pseudoGuardInstalled2) {
      sendBtn.__pseudoGuardInstalled2 = true;
      sendBtn.addEventListener('click', function(ev){
        try {
          var p = (pseudoInput && pseudoInput.value ? pseudoInput.value : '').trim();
          if (!p) return;
          var myId = (window.socket && socket.id) || '';
          var ch = (typeof window.currentChannel === 'string') ? window.currentChannel : 'world';
          var taken = false;

          if (ch === 'lobby' && window.lobbyData && window.lobbyData.players) {
            var playersMap = window.lobbyData.players || {};
            for (var sid in playersMap) {
              if (sid === myId) continue;
              var nm = (playersMap[sid] && playersMap[sid].pseudo) ? String(playersMap[sid].pseudo) : '';
              if (nm && nm.trim().toLowerCase() === p.toLowerCase()) { taken = true; break; }
            }
          } else {
            // world: fall back to recent chat buffer check (same approach already used before emit)
            try {
              var arr = (window.chatBuf && window.chatBuf[ch]) ? window.chatBuf[ch] : [];
              for (var i=0;i<arr.length;i++){
                var m = arr[i];
                if (!m || !m.pseudo) continue;
                if (String(m.pseudo).toLowerCase() === p.toLowerCase() && m.sid !== myId) { taken = true; break; }
              }
            } catch(_){}
          }

          if (taken) {
            try { __alertPseudoTaken(); } catch(_){}
            ev.stopImmediatePropagation(); ev.preventDefault();
            return;
          }
        } catch(_){}
      }, true);
    }
  } catch(_){}
})();
</script>


<!-- [PATCH] server label lang hook -->
<script>
(function(){
  if (window.__workerLabelLangHooked) return;
  window.__workerLabelLangHooked = true;
  var __prevUpdateUITexts = window.updateUITexts;
  window.updateUITexts = function(){
    try { if (typeof __prevUpdateUITexts === 'function') __prevUpdateUITexts.apply(this, arguments); } catch(_){}
    try {
      if (typeof window.setWorkerBox === 'function') {
        window.setWorkerBox();
      } else {
        var el = document.getElementById('workerBox');
        if (el) {
          var lang = (window.currentLang || 'en');
          var tr = (window.TRANSLATIONS && (TRANSLATIONS[lang]||TRANSLATIONS['en'])) || {};
          var id = (window.__workerId|0) || (window.__workerIdx|0) || 1;
          var tpl = tr.serverLabel || 'Server {n}';
          el.textContent = String(tpl).replace('{n}', String(id));
        }
      }
    } catch(_){}
  
    try {
      var btn = document.getElementById('btnChooseServer');
      if (btn) {
        var lang = (window.currentLang || 'en');
        var tr = (window.TRANSLATIONS && (TRANSLATIONS[lang]||TRANSLATIONS['en'])) || {};
        btn.textContent = (tr.chooseServer || 'Choose a server');
      }
    } catch(_){}
};
})();
</script>
</body></html>
      try { window.lobbyData = lobbyData; } catch(_){}
<!-- [PATCH] turret-skins-swap v1 -->
</script>

<script>
(function(){"use strict";
  const SPRITES = {
    T: new Image(), t: new Image(), G: new Image(),
    T_shoot: new Image(), t_shoot: new Image(), G_shoot: new Image(),
  };
  SPRITES.T.src = "/sprites/turret.png";
  SPRITES.t.src = "/sprites/mini_turret.png";
  SPRITES.G.src = "/sprites/big_turret.png";
  SPRITES.T_shoot.src = "/sprites/turret_shoot.png";
  SPRITES.t_shoot.src = "/sprites/mini_turret_shoot.png";
  SPRITES.G_shoot.src = "/sprites/big_turret_shoot.png";
  try { window.__TURRET_SPRITES__ = SPRITES; } catch(_){}

  function getSpriteFor(type, shooting){ return shooting ? (SPRITES[type + "_shoot"] || SPRITES[type]) : SPRITES[type]; }
  function imgReady(img){ return img && img.complete && img.naturalWidth > 0; }

  // Draw an image slightly larger than the tile, clipped to tile bounds (fills the square cleanly).
  function drawSpriteCover(ctx, img, x, y, size, scale, shiftUpPx, allowTopOverflowPx){
  // Anisotropic cover: slightly taller than wide so the base touches bottom & top
  const sBase = (typeof scale === 'number') ? scale : 1.7;
  const sX = Array.isArray(scale) ? (scale[0] ?? sBase) : sBase;
  const sY = Array.isArray(scale) ? (scale[1] ?? sBase) : (sBase * 1.15); // ~+15% height
  const up = (typeof shiftUpPx === 'number') ? shiftUpPx : (0.11 * size + 1);
  const allow = (typeof allowTopOverflowPx === 'number') ? allowTopOverflowPx : (0.18 * size);
  const cx = x + size/2, cy = y + size/2 - up;
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, y - allow, size, size + allow);
  ctx.clip();
  ctx.drawImage(img, cx - (size*sX)/2, cy - (size*sY)/2, size*sX, size*sY);
  ctx.restore();
}

  // Track firing state to show *_shoot skins while laser is visible
  const turretFireUntil = new Map(); // key "ty,tx" -> epoch ms
  const LASER_LIFE_MS = 60;

  function markTurretFiredFromXY(x0, y0){
    try {
      const ts = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const TILE = (typeof TILE_SIZE !== 'undefined') ? TILE_SIZE : (window.TILE_SIZE || 40);
      const tx = Math.floor(x0 / TILE);
      const ty = Math.floor(y0 / TILE);
      turretFireUntil.set(ty + "," + tx, ts + LASER_LIFE_MS);
    } catch(_){}
  }

  function markFromActiveLasers(){
    try {
      const arr = (typeof turretLasers !== 'undefined') ? turretLasers : window.turretLasers;
      if (!arr || !arr.length) return;
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      for (let i = 0; i < arr.length; i++) {
        const b = arr[i]; if (!b) continue;
        if (typeof b.t !== 'number') continue;
        if (now - b.t > LASER_LIFE_MS) continue;
        if (typeof b.x0 !== 'number' || typeof b.y0 !== 'number') continue;
        markTurretFiredFromXY(b.x0, b.y0);
      }
    } catch(_){}
  }

  (function attachLaserListeners(){
    try {
      if (!window.socket || attachLaserListeners._bound) return;
      attachLaserListeners._bound = true;
      socket.on('laserBeam', function(b){ if (b) markTurretFiredFromXY(b.x0 ?? b.x, b.y0 ?? b.y); });
      socket.on('laserBeams', function(arr){ try { for (let i=0;i<(arr?.length||0);i++){ const b=arr[i]; if (b) markTurretFiredFromXY(b.x0 ?? b.x, b.y0 ?? b.y); } } catch(_e){} });
    } catch(_e){}
  })();

  // --- Build tiles / Shop upgrades (unchanged from previous patch) ---
  function patchBuildTiles(){
    try{
      const cont=document.getElementById('buildTiles'); if(!cont) return;
      cont.querySelectorAll('.build-tile').forEach(btn=>{
        const type=btn.getAttribute('data-type'); if(!/^[tTG]$/.test(type||"")) return;
        const box=btn.querySelector(':scope > div:first-child'); if(!box) return;
        if(box.querySelector('img[data-skin="1"]')) return;
        box.innerHTML="";
        const img=document.createElement('img');
        img.src=(type==='T')?SPRITES.T.src:(type==='t')?SPRITES.t.src:SPRITES.G.src;
        img.setAttribute('data-skin','1');
        img.alt=(type==='T')?'Tourelle rouge':(type==='t')?'Mini-tourelle bleue':'Grande tourelle violette';
        Object.assign(img.style,{width:'100%',height:'100%',objectFit:'contain',imageRendering:'pixelated'});
        img.decoding='async';
        box.appendChild(img);
      });
    }catch(_){}
  }
  try{patchBuildTiles();}catch(_){}
  try{setInterval(patchBuildTiles,800);}catch(_){}

  (function(){
    try{
      const prev=window.renderShopUpgrades;
      window.renderShopUpgrades=function(){
        try{ if(typeof prev==='function') prev.apply(this,arguments); }catch(_){}
        try{
          const root=document.getElementById('shopUpgrades'); if(!root) return;
          root.querySelectorAll('.shop-upg-item').forEach(item=>{
            const btn=item.querySelector('.btn-turret-up[data-type]'); if(!btn) return;
            const type=btn.getAttribute('data-type'); if(!/^[tTG]$/.test(type||"")) return;
            const box=item.querySelector(':scope > div:first-child'); if(!box) return;
            if(box.querySelector('img[data-skin="1"]')) return;
            box.innerHTML='';
            const img=document.createElement('img');
            img.src=(type==='T')?SPRITES.T.src:(type==='t')?SPRITES.t.src:SPRITES.G.src;
            img.setAttribute('data-skin','1');
            img.alt=(type==='T')?'Tourelle rouge':(type==='t')?'Mini-tourelle bleue':'Grande tourelle violette';
            Object.assign(img.style,{width:'100%',height:'100%',objectFit:'contain',imageRendering:'pixelated'});
            img.decoding='async';
            box.appendChild(img);
          });
        }catch(_){}
      };
    }catch(_){}
  })();

  // Override drawStructures: call original, then overlay turret sprites (scaled + clipped)
  (function(){
    try {
      const orig = window.drawStructures;
      const patched = function(){
        try {
          // Draw everything as before
          try { if (typeof orig === 'function') orig(); } catch(_){}

          // Mark shooting from active lasers to ensure "*_shoot" skins always sync
          markFromActiveLasers();

          // Overlay sprites
          const _structures = (typeof structures !== 'undefined') ? structures : window.structures;
          const _ctx = (typeof ctx !== 'undefined') ? ctx : window.ctx;
          const TILE=(typeof TILE_SIZE!=='undefined')?TILE_SIZE:(window.TILE_SIZE||40);
          const camX=(typeof cameraX!=='undefined')?cameraX:(window.cameraX||0);
          const camY=(typeof cameraY!=='undefined')?cameraY:(window.cameraY||0);
          const _canvas=(typeof canvas!=='undefined')?canvas:window.canvas;
          const _renderScale=(typeof renderScale!=='undefined')?renderScale:(window.renderScale||1);
          if(!_structures||!_ctx) return;

          const rows=_structures.length, cols=rows?(_structures[0]?.length||0):0;
          const scrW=(_canvas&&_canvas.width)?(_canvas.width/_renderScale):(cols*TILE);
          const scrH=(_canvas&&_canvas.height)?(_canvas.height/_renderScale):(rows*TILE);
          const minCol=Math.max(0,Math.floor(camX/TILE)-1);
          const minRow=Math.max(0,Math.floor(camY/TILE)-1);
          const maxCol=Math.min(cols-1,Math.floor((camX+scrW)/TILE)+1);
          const maxRow=Math.min(rows-1,Math.floor((camY+scrH)/TILE)+1);

          for(let r=minRow;r<=maxRow;r++){
            const row=_structures[r]; if(!row) continue;
            for(let c=minCol;c<=maxCol;c++){
              const cell=row[c]; if(!cell) continue;
              const type=cell.type; if(!(type==='T'||type==='t'||type==='G')) continue;
              const x=c*TILE-camX, y=r*TILE-camY;
              const key=r+','+c;
              const now=(typeof performance!=='undefined'&&performance.now)?performance.now():Date.now();
              const shooting=(turretFireUntil.get(key)||0)>now;
              const img=getSpriteFor(type,shooting)||getSpriteFor(type,false);
              if(imgReady(img)){ _ctx.clearRect(x, y, TILE, TILE);
              drawSpriteCover(_ctx,img,x,y,TILE,1.7,0.11*TILE+1,0.18*TILE); }
            }
          }
        } catch(e){ try{ if(typeof orig==='function') orig(); }catch(_){} }
      };
      window.drawStructures = patched;
      try { drawStructures = patched; } catch(_){}
    } catch(_e){}
  })();

  // Override drawBuildPreview: use same cover+clip drawing in semi-transparency
  (function(){
    try {
      const orig = window.drawBuildPreview;
      const patched = function(){
        try {
          const _buildMode = (typeof buildMode!=='undefined')?buildMode:window.buildMode;
          const _hover = (typeof buildHover!=='undefined')?buildHover:window.buildHover;
          if(!_buildMode || !_hover){ if(typeof orig==='function') orig(); return; }
          const tx=_hover.tx, ty=_hover.ty;
          const MAP_COLS=(typeof MAP_COLS!=='undefined')?MAP_COLS:(window.MAP_COLS||0);
          const MAP_ROWS=(typeof MAP_ROWS!=='undefined')?MAP_ROWS:(window.MAP_ROWS||0);
          const TILE=(typeof TILE_SIZE!=='undefined')?TILE_SIZE:(window.TILE_SIZE||40);
          const camX=(typeof cameraX!=='undefined')?cameraX:(window.cameraX||0);
          const camY=(typeof cameraY!=='undefined')?cameraY:(window.cameraY||0);
          if(tx<0||ty<0||tx>=MAP_COLS||ty>=MAP_ROWS) return;
          if(!(_buildMode==='T'||_buildMode==='t'||_buildMode==='G')){ if(typeof orig==='function') return orig(); }
          const _ctx=(typeof ctx!=='undefined')?ctx:window.ctx;
          const x=tx*TILE-camX, y=ty*TILE-camY;
          const img=getSpriteFor(_buildMode,false);
          _ctx.save(); _ctx.globalAlpha=0.5;
          if(imgReady(img)) drawSpriteCover(_ctx,img,x,y,TILE,1.7,0.11*TILE+1,0.18*TILE);
          else{ _ctx.fillStyle=(_buildMode==='T')?'#d33':(_buildMode==='t')?'#3aa6ff':'#b48cff'; _ctx.fillRect(x,y,TILE,TILE); }
          _ctx.restore();
        } catch(_){ if(typeof orig==='function') try{orig();}catch(__){} }
      };
      window.drawBuildPreview = patched;
      try { drawBuildPreview = patched; } catch(_){}
    } catch(_e){}
  })();

  // Also hook drawTurretLasers to mark shooting tiles directly from the buffer (extra reliability)
  (function(){
    try {
      const orig = window.drawTurretLasers;
      if (typeof orig === 'function') {
        window.drawTurretLasers = function(){
          try { orig(); } catch(_){}
          try { markFromActiveLasers(); } catch(_){}
        };
        try { drawTurretLasers = window.drawTurretLasers; } catch(_){}
      }
    } catch(_e){}
  })();


  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<!-- /[PATCH] turret-skins-swap v1 -->

<!-- [PATCH] turret-skins-swap v1 - periodic shop patch -->
<script>
(function(){
  function patchShopTurretIcons(){
    try {
      const root = document.getElementById('shopUpgrades'); if (!root) return;
      const items = root.querySelectorAll('.shop-upg-item');
      items.forEach(item => {
        const btn = item.querySelector('.btn-turret-up[data-type]'); if (!btn) return;
        const type = btn.getAttribute('data-type'); if (!/^[tTG]$/.test(type)) return;
        const box = item.querySelector(':scope > div:first-child'); if (!box) return;
        if (box.querySelector('img[data-skin="1"]')) return;
        const src = (type==='T')? "/sprites/turret.png" : (type==='t')? "/sprites/mini_turret.png" : "/sprites/big_turret.png";
        box.innerHTML = '';
        const img = document.createElement('img');
        img.src = src; img.setAttribute('data-skin','1'); img.alt = 'turret';
        img.style.width='100%'; img.style.height='100%'; img.style.objectFit='contain'; img.style.imageRendering='pixelated'; img.decoding='async';
        box.appendChild(img);
      });
    } catch(_) {}
  }
  try { setInterval(patchShopTurretIcons, 1000); } catch(_){}

  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<!-- /[PATCH] turret-skins-swap v1 - periodic shop patch -->

<!-- [PATCH] build-tiles locale sync (ensure names follow menu language) -->
<script id="build-tiles-locale-sync">
(function(){ "use strict";
  if (window.__buildTilesLocaleSyncInstalled) return;
  window.__buildTilesLocaleSyncInstalled = true;

  function uiLang(){
    try {
      var raw = (typeof window.currentLang === 'string' && window.currentLang) || (navigator.language||'en');
      raw = String(raw).slice(0,2);
      var alias = { ja:'jp', zh:'cn', ko:'kr' };
      return alias[raw] || raw || 'en';
    } catch(_){ return 'en'; }
  }

  function upperFirstLocalizedSafe(s){
    try { return (typeof window.upperFirstLocalized==='function') ? window.upperFirstLocalized(s) : (s ? s.charAt(0).toUpperCase()+s.slice(1) : s); }
    catch(_){ return s; }
  }

  function computeTipForType(type){
    try {
      var T = window.TRANSLATIONS || {};
      var L = uiLang();
      var tr = (T[L] || T['en']) || {};
      var names = tr.turretType || {};
      var hpLabel = tr.hpShort || 'HP';
      var dmgLabel = tr.damage || 'Damage';
      var rateLabel = tr.fireRate || 'Fire rate';
      var perSec  = tr.perSec || '/s';
      var baseHP = { T:500, t:200, G:2500, B:500, D:500 };
      var name = (type==='B') ? (tr.buildWall || 'Wall')
               : (type==='D') ? (tr.buildDoor || 'Door')
               : (names[type] || 'Turret');
      name = upperFirstLocalizedSafe(name);
      if (type==='B' || type==='D') {
        return name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ')';
      } else {
        var rate = (type==='T') ? '1' : (type==='G') ? '2' : '0.5';
        var baseDmg = {t:5,T:10,G:25}[type] || 0;
        var dmg = (typeof window.computeTurretDamageDisplay==='function') ? window.computeTurretDamageDisplay(type) : baseDmg;
        return name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ', ' + dmgLabel + ': ' + dmg + ', ' + rateLabel + ': ' + rate + perSec + ')';
      }
    } catch(_){ return ''; }
  }

  function syncBuildTileLocale(){
    try{
      var cont = document.getElementById('buildTiles'); if (!cont) return;
      var T = window.TRANSLATIONS || {}; var L = uiLang(); var tr = (T[L]||T['en'])||{};
      cont.querySelectorAll('.build-tile').forEach(function(btn){
        try{
          var type = btn.getAttribute('data-type'); if (!type) return;
          // 1) Update tooltip source so every handler (legacy/new) uses the right language
          var tip = computeTipForType(type);
          if (tip) btn.setAttribute('data-tip', tip);

          // 2) Accessibility label for screen-readers
          var baseName = (type==='B') ? (tr.buildWall || 'Wall')
                        : (type==='D') ? (tr.buildDoor || 'Door')
                        : ((tr.turretType||{})[type] || 'Turret');
          baseName = upperFirstLocalizedSafe(baseName);
          btn.setAttribute('aria-label', baseName);
        }catch(_){}
      });

      // Also update mobile build button labels (idempotent)
      try{
        document.querySelectorAll('.mobile-build .mb-btn').forEach(function(b){
          var t = b.getAttribute('data-type'); if (!t) return;
          if (t==='B') { b.textContent = tr.buildWall || b.textContent; b.setAttribute('aria-label', (tr.buildWall||b.textContent) + ' (B)'); }
          else if (t==='D') { b.textContent = tr.buildDoor || b.textContent; b.setAttribute('aria-label', (tr.buildDoor||b.textContent) + ' (D)'); }
          else if (t==='t') { b.textContent = tr.buildMiniTurret || b.textContent; b.setAttribute('aria-label', (tr.buildMiniTurret||b.textContent) + ' (t)'); }
          else if (t==='T') { b.textContent = tr.buildTurret || b.textContent; b.setAttribute('aria-label', (tr.buildTurret||b.textContent) + ' (T)'); }
        });
      }catch(_){}

      // If tooltip is currently visible, refresh its text to the new language
      try{
        var visibleTip = document.getElementById('buildTooltipStable') || document.getElementById('buildTooltip');
        if (visibleTip && visibleTip.style && visibleTip.style.display==='block'){
          // Try to find the currently hovered tile
          var e = document.querySelector('#buildTiles .build-tile:hover');
          if (e){
            var t = e.getAttribute('data-type');
            var txt = computeTipForType(t);
            if (txt) visibleTip.textContent = txt;
          }
        }
      }catch(_){}
    }catch(_){}
  }

  // Expose
  try { window.syncBuildTileLocale = syncBuildTileLocale; } catch(_){}

  // Patch updateUITexts once to also sync tiles after any language change
  try {
    var _orig = window.updateUITexts;
    if (typeof _orig === 'function'){
      window.updateUITexts = function(){
        try { _orig.apply(this, arguments); } finally { try { syncBuildTileLocale(); } catch(_e){} }
      };
    }
  } catch(_){}

  // Initial run (post-DOM)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', syncBuildTileLocale, {passive:true});
  } else {
    syncBuildTileLocale();
  }
})(); 
</script>

<!-- [PATCH] character-skin shop & recolor v1 -->
<script>
(function(){
  if (window.__skinShopInstalled) return; 
  window.__skinShopInstalled = true;

  // ======= State & helpers =======

// Robust: ensure my skin is loaded before joining/starting a game (handles reconnect timing)
async function ensureMySkinLoaded(timeoutMs = 1200){
  try {
    if (__mySkin && __mySkin.hair && __mySkin.skin && __mySkin.clothes) return true;
    // Fire a fetch; don't throw if it fails
    try { await fetchMe(); } catch(_){}
    if (__mySkin && __mySkin.hair && __mySkin.skin && __mySkin.clothes) return true;
    // Wait a tiny bit for any in-flight /api/me
    await new Promise(r => setTimeout(r, 200));
    return !!(__mySkin && __mySkin.hair && __mySkin.skin && __mySkin.clothes);
  } catch(_){ return false; }
}
try {
  // On initial socket connect, refresh my profile+skin and bust cached sprite
  if (window.socket && typeof socket.on==='function'){
    socket.on('connect', function(){
      try { if (__myUser) __spriteCache[String(__myUser).toLowerCase()] = null; } catch(_){}
      try { fetchMe(); } catch(_){}
    });
  }
} catch(_){}

  var __basePlayerImg = (typeof playerImg !== 'undefined') ? playerImg : null;
  var __myUser = null;
  var __mySkin = null; // { hair, skin, clothes }
  var __spriteCache = {}; // pseudoLower -> Image

  function uiLang(){
    try { var raw = (window.currentLang||navigator.language||'en').slice(0,2); var alias={ja:'jp',zh:'cn',ko:'kr'}; return alias[raw]||raw||'en'; }catch(_){ return 'en'; }
  }

  function fetchMe(){
    return fetch('/api/me', { credentials:'include' })
      .then(function(r){ return r.json(); })
      .then(function(j){
        if (j && j.ok){
          __myUser = j.username || null;
          __mySkin = j.skin || __mySkin;
        }
      }).catch(function(_){});
  }

  function hexToRgb(h){ var m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(String(h||'')); return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:null; }
  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    var max=Math.max(r,g,b), min=Math.min(r,g,b);
    var h,s,l=(max+min)/2;
    if (max==min){ h=s=0; }
    else{
      var d=max-min;
      s=l>0.5? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=(g-b)/d + (g<b?6:0); break;
        case g: h=(b-r)/d + 2; break;
        case b: h=(r-g)/d + 4; break;
      }
      h/=6;
    }
    return {h:h,s:s,l:l};
  }
  function hslToRgb(h,s,l){
    var r,g,b;
    if(s===0){ r=g=b=l; }
    else{
      function hue2rgb(p,q,t){ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3 - t)*6; return p; }
      var q = l < 0.5 ? l * (1 + s) : l + s - l*s;
      var p = 2 * l - q;
      r = hue2rgb(p,q,h + 1/3);
      g = hue2rgb(p,q,h);
      b = hue2rgb(p,q,h - 1/3);
    }
    return {r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255)};
  }

  // Classify pixel by hue/sat ranges (robust to different base shades)
  

function classifyRegion(r,g,b,a){
    // Ignore near-transparent pixels entirely (anti-aliased halo)
    if (a < 64) return 'none';
    var hsl = rgbToHsl(r,g,b);
    var h = hsl.h*360, s = hsl.s, l = hsl.l;

    // Ignore outlines/eyes and fully transparent
    // Ignore outlines/eyes and fully transparent
    // Previous: l-extremes OR low saturation were skipped, which blocked near‑white/near‑black highlights.
    // Keep ignoring truly gray/outline pixels, but allow colored extremes so gradients with white/black apply correctly.
    if (s <= 0.06 || l <= 0.10 || l >= 0.94) return 'none';

    // Clothes: greens/cyans from the base sprite. Wider band to catch all shades.
    if (s > 0.12 && h >= 70 && h <= 190) return 'clothes';

    // Base orange/brown band used by hair/skin. Split by lightness.
    if (h >= 8 && h <= 70 && s > 0.06){
      return (l <= 0.56) ? 'hair' : 'skin';
    }

    // Fallback classification for borderline pixels (anti‑alias shades)
    var diffGreen = Math.min(Math.abs(h - 120), 360 - Math.abs(h - 120));
    var diffOrange = Math.min(Math.abs(h - 30),  360 - Math.abs(h - 30));
    if (s > 0.05){
      if (diffGreen < 30) return 'clothes';
      if (diffOrange < 35) return (l <= 0.56) ? 'hair' : 'skin';
    }
    return 'none';
  }

  function applyTintPreserveLight(rgbTarget, srcHsl){
    // If user picked pure black or pure white, apply it exactly
    // (do not preserve source lightness), otherwise keep the original shading behavior.
    if (rgbTarget && rgbTarget.r===0 && rgbTarget.g===0 && rgbTarget.b===0) return {r:0,g:0,b:0};
    if (rgbTarget && rgbTarget.r===255 && rgbTarget.g===255 && rgbTarget.b===255) return {r:255,g:255,b:255};
    var thsl = rgbToHsl(rgbTarget.r, rgbTarget.g, rgbTarget.b);
    // Blend saturation slightly to keep sprite relief
    var h = thsl.h;
    var s = Math.min(1, Math.max(0, thsl.s*0.85 + srcHsl.s*0.15));
    // Allow target lightness to influence the result near extremes (for white/black gradients),
    // while preserving shading in mid‑tones.
    var t = thsl.l; // target lightness
    // closeness=0 in mid-range (~[0.25..0.75]), -> preserve src lightness
    // closeness=1 near pure black/white -> follow target lightness (to let gradients work)
    var closeness = Math.max(0, Math.min(1, (Math.abs(t - 0.5) - 0.25) / 0.25));
    var l = srcHsl.l*(1 - closeness) + t*closeness;
    var out = hslToRgb(h,s,l);
    return out;
  }function recolorPlayerImage(baseImg, colors, cb){
    try{
      var canvas = document.createElement('canvas');
      var w = baseImg.naturalWidth||baseImg.width||64;
      var h = baseImg.naturalHeight||baseImg.height||64;
      if (!w || !h) { if (cb) cb(null); return; }
      canvas.width = w; canvas.height = h;
      var ctx = canvas.getContext('2d');
      try { ctx.imageSmoothingEnabled = false; }catch(_){}
      ctx.drawImage(baseImg, 0, 0, w, h);
      var id = ctx.getImageData(0,0,w,h);
      var d = id.data;
      var rgbHair = hexToRgb(colors.hair||'#6b4d2e');
      var rgbSkin = hexToRgb(colors.skin||'#f4c2c2');
      var rgbClothes = hexToRgb(colors.clothes||'#2aa84a');
      for (var i=0;i<d.length;i+=4){
        var r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
        var reg = classifyRegion(r,g,b,a);
        if (reg==='none') continue;
        var hsl = rgbToHsl(r,g,b);
        var target = (reg==='hair')?rgbHair : (reg==='skin')?rgbSkin : rgbClothes;
        var out = applyTintPreserveLight(target, hsl);
        d[i]=out.r; d[i+1]=out.g; d[i+2]=out.b; // keep alpha
      }
      
      // Post-process: clear near-transparent noise / isolated speckles
      // 1) Normalize ultra-low alpha to 0
      for (var j=0;j<d.length;j+=4){ if (d[j+3] <= 16) d[j+3] = 0; }
      // 2) Remove isolated 1px dots with weak alpha (4-neighbour check)
      var pxW = w, pxH = h;
      for (var y=1; y<pxH-1; y++){
        for (var x=1; x<pxW-1; x++){
          var k = (y*pxW + x) * 4;
          var a0 = d[k+3];
          if (a0 > 0 && a0 <= 80){
            var aL = d[k-4+3], aR = d[k+4+3], aT = d[k-4*pxW+3], aB = d[k+4*pxW+3];
            var aTL = d[k-4*pxW-4+3], aTR = d[k-4*pxW+4+3], aBL = d[k+4*pxW-4+3], aBR = d[k+4*pxW+4+3];
            var neigh = 0; if (aL>0) neigh++; if (aR>0) neigh++; if (aT>0) neigh++; if (aB>0) neigh++;
            if (aTL>0) neigh++; if (aTR>0) neigh++; if (aBL>0) neigh++; if (aBR>0) neigh++;
            if (neigh <= 1) { d[k+3] = 0; }
          }
        }
      }
ctx.putImageData(id,0,0);
      var url = canvas.toDataURL('image/png');
      var im = new Image(); im.src = url; im.decoding='async'; im.style.imageRendering='pixelated';
      if (cb) { if (im.complete) cb(im); else im.onload=function(){ cb(im); }; }
    }catch(e){ if (cb) cb(null); }
  }

  function getPlayerSpriteFor(pseudo, skinOpt){
    try{
      if (!pseudo) return __basePlayerImg;
      var key = String(pseudo||'').toLowerCase();
      if (__spriteCache[key]) return __spriteCache[key];
      var s = null;
      // Prefer explicit skin info from state payload
      if (skinOpt && typeof skinOpt==='object') {
        var hex = /^#[0-9a-fA-F]{6}$/;
        var h = hex.test(skinOpt.hair)? String(skinOpt.hair).toLowerCase() : null;
        var sk = hex.test(skinOpt.skin)? String(skinOpt.skin).toLowerCase() : null;
        var c = hex.test(skinOpt.clothes)? String(skinOpt.clothes).toLowerCase() : null;
        if (h && sk && c) { s = { hair:h, skin:sk, clothes:c }; }
      }
      // Fallback: local user skin (for ourselves) if not provided
      if (!s && __myUser && key === String(__myUser||'').toLowerCase() && __mySkin) {
        s = __mySkin;
      }
      if (s && __basePlayerImg){
        // async recolor; cache per pseudo
        recolorPlayerImage(__basePlayerImg, s, function(img){ __spriteCache[key] = img || __basePlayerImg; });
      }
      return __basePlayerImg;
    }catch(_){ return __basePlayerImg; }
  }
  try { window.getPlayerSpriteFor = getPlayerSpriteFor; } catch(_){}
  try { if (typeof window.fetchMe!=='function') window.fetchMe = fetchMe; } catch(_){ }
  try { if (typeof window.openSkinModal!=='function') window.openSkinModal = openSkinModal; } catch(_){ }

  // ======= Shop UI injection =======
  function ensureSkinModal(){
    var T = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang]||TRANSLATIONS['en'])) || {};
    
    if (document.getElementById('skinModal')) return;
    var modal = document.createElement('div');
    modal.id = 'skinModal';
    modal.style.cssText = 'display:none; position:fixed; inset:0; background:rgba(0,0,0,0.75); z-index:2147483646; align-items:center; justify-content:center;';
    modal.innerHTML = ''
      + '<div id="skinBox" style="background:#111;border:1px solid #222;max-width: min(92vw, 540px); color:#eee; box-shadow:0 10px 30px #000a;">'
      + '  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:10px;">'
      + '    <div style="font-weight:800;font-size:18px;">' + ((T.customizeCharacter||'Customize character')) + '</div>'
      + '    <button id="skinClose" style="background:#333;color:#fff;border:none;border-radius:8px;padding:6px 10px;cursor:pointer;">✕</button>'
      + '  </div>'
      + '  <div style="display:flex;gap:14px;flex-wrap:wrap;align-items:flex-start;">'
      + '    <div style="flex:1;min-width:200px;text-align:center;">'
      + '      <canvas id="skinPreview" width="96" height="96" style="width:160px;height:160px;border:1px solid #333;border-radius:8px;background:#222;"></canvas>'
      + '      <div style="margin-top:8px;font-size:12px;color:#9ab;">' + ((T.preview||'Preview')) + '</div>'
      + '    </div>'
      + '    <div style="flex:1;min-width:240px;">'
      + '      <div style="display:flex;flex-direction:column;gap:10px;">'
      + '        <label>' + ((T.hair||'Hair')) + ' <input id="hairColor" type="color" value="#6b4d2e" style="margin-left:8px;"></label>'
      + '        <label>' + ((T.skin||'Skin')) + ' <input id="skinColor" type="color" value="#f4c2c2" style="margin-left:8px;"></label>'
      + '        <label>' + ((T.clothes||'Clothes')) + ' <input id="clothesColor" type="color" value="#2aa84a" style="margin-left:8px;"></label>'
      + '        <div style="margin-top:4px;color:#ccc;font-size:14px;">' + ((T.price||'Price')) + ': <b>20</b> ' + ((T.gold||'Gold')) + '</div>'
      + '        <div id="skinMsg" style="min-height:18px;font-size:12px;color:#9ab;"></div>'
      + '        <div style="display:flex;gap:8px;flex-wrap:wrap;">'
      + '          <button id="skinBuy" style="flex:1;background:#ff8800;color:#fff;border:none;border-radius:8px;padding:10px 14px;cursor:pointer;">' + ((T.buy||'Buy')) + '</button>'
      + '          <button id="skinCancel" style="flex:1;background:#222;color:#fff;border:none;border-radius:8px;padding:10px 14px;cursor:pointer;">' + ((T.cancel||'Cancel')) + '</button>'
      + '        </div>'
      + '      </div>'
      + '    </div>'
      + '  </div>'
      + '</div>';
    document.body.appendChild(modal);
try { modal.addEventListener('click', function(ev){ if (ev.target && (ev.target.id==='skinCancel' || ev.target.id==='skinClose')) { modal.style.display='none'; } }, {passive:true}); } catch(_){ }
function close(){ modal.style.display='none'; }
    modal.addEventListener('click', function(ev){ if (ev.target===modal) close(); }, { passive:true });
    modal.querySelector('#skinClose').addEventListener('click', close, { passive:true });
    modal.querySelector('#skinCancel').addEventListener('click', close, { passive:true });
  }

  function openSkinModal(){
    var T = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang]||TRANSLATIONS['en'])) || {};
    
    ensureSkinModal();
    var modal = document.getElementById('skinModal');
    var canvas = document.getElementById('skinPreview');
    var ctx = canvas.getContext('2d');
    try { ctx.imageSmoothingEnabled = false; }catch(_){}

    var hairInp = document.getElementById('hairColor');
    var skinInp = document.getElementById('skinColor');
    var clothesInp = document.getElementById('clothesColor');
    var msg = document.getElementById('skinMsg');

    
    
    // --- Custom in-DOM color palette with "Valider" inside (replaces native popup) ---
    (function(){
      var overlay, svCanvas, svCtx, hueCanvas, hueCtx, okBtn, rIn, gIn, bIn, activeInput = null;
      function clamp(v,min,max){ return v<min?min: (v>max?max:v); }
      function hsv2rgb(h,s,v){
        h = (h%360+360)%360; s = clamp(s,0,1); v = clamp(v,0,1);
        var c = v*s, x = c*(1-Math.abs((h/60)%2-1)), m=v-c, r=0,g=0,b=0;
        if (h<60){ r=c; g=x; b=0; } else if (h<120){ r=x; g=c; b=0; }
        else if (h<180){ r=0; g=c; b=x; } else if (h<240){ r=0; g=x; b=c; }
        else if (h<300){ r=x; g=0; b=c; } else { r=c; g=0; b=x; }
        return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) };
      }
      function rgb2hsv(r,g,b){
        r/=255; g/=255; b/=255;
        var max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min, h=0, s=max===0?0:d/max, v=max;
        if(d!==0){
          switch(max){
            case r: h = 60*(((g-b)/d)%6); break;
            case g: h = 60*(((b-r)/d)+2); break;
            case b: h = 60*(((r-g)/d)+4); break;
          }
        }
        if (h<0) h+=360;
        return {h:h, s:s, v:v};
      }
      function hex2rgb(hex){
        hex = (hex||'').toString().trim();
        if (hex[0]==='#') hex = hex.slice(1);
        if (hex.length===3) hex = hex.split('').map(function(c){return c+c;}).join('');
        var n = parseInt(hex,16);
        if (isNaN(n) || hex.length!==6) return {r:0,g:0,b:0};
        return { r: (n>>16)&255, g: (n>>8)&255, b: n&255 };
      }
      function rgb2hex(r,g,b){ function h(x){ return (x|0).toString(16).padStart(2,'0'); } return '#' + h(r)+h(g)+h(b); }

      var hue = 240, sat = 1, val = 1;

      function ensureOverlay(){
        if (overlay) return;
        overlay = document.createElement('div');
        overlay.id = 'colorPaletteOverlay';
        overlay.style.position = 'fixed';
        overlay.style.zIndex = '2147483647';
        overlay.style.background = '#111';
        overlay.style.border = '1px solid #333';
        overlay.style.borderRadius = '10px';
        overlay.style.boxShadow = '0 10px 30px rgba(0,0,0,.5)';
        overlay.style.padding = '10px';
        overlay.style.display = 'none';
        overlay.style.width = '260px';

        var title = document.createElement('div');
        title.textContent = (T.color||'Color');
        title.style.color='#fff';
        title.style.fontWeight='700';
        title.style.margin='0 0 6px';
        overlay.appendChild(title);

        svCanvas = document.createElement('canvas');
        svCanvas.width = 240; svCanvas.height = 150;
        svCanvas.style.display = 'block';
        svCanvas.style.border = '1px solid #222';
        svCanvas.style.borderRadius = '8px';
        overlay.appendChild(svCanvas);
        svCtx = svCanvas.getContext('2d');

        hueCanvas = document.createElement('canvas');
        hueCanvas.width = 240; hueCanvas.height = 16;
        hueCanvas.style.display='block';
        hueCanvas.style.margin = '8px 0';
        hueCanvas.style.borderRadius = '8px';
        hueCanvas.style.border = '1px solid #222';
        overlay.appendChild(hueCanvas);
        hueCtx = hueCanvas.getContext('2d');

        var rgbWrap = document.createElement('div');
        rgbWrap.style.display='grid';
        rgbWrap.style.gridTemplateColumns='1fr 1fr 1fr';
        rgbWrap.style.gap='8px';
        function mkNum(label){
          var wrap=document.createElement('div');
          var i=document.createElement('input');
          i.type='number'; i.min='0'; i.max='255'; i.step='1';
          i.style.width='100%'; i.style.boxSizing='border-box';
          i.style.padding='6px 8px';
          i.style.borderRadius='6px'; i.style.border='1px solid #222'; i.style.background='#000'; i.style.color='#fff';
          var l=document.createElement('div');
          l.textContent=label; l.style.color='#9ab'; l.style.fontSize='12px'; l.style.marginTop='4px'; l.style.textAlign='center';
          wrap.appendChild(i); wrap.appendChild(l);
          return {wrap:wrap,input:i};
        }
        var nr=mkNum('R'), ng=mkNum('G'), nb=mkNum('B');
        rIn = nr.input; gIn = ng.input; bIn = nb.input;
        rgbWrap.appendChild(nr.wrap); rgbWrap.appendChild(ng.wrap); rgbWrap.appendChild(nb.wrap);
        overlay.appendChild(rgbWrap);

        var actions = document.createElement('div');
        actions.style.display='flex'; actions.style.gap='8px'; actions.style.marginTop='10px';
        okBtn = document.createElement('button');
        okBtn.textContent=(T.validate||'Apply');
        okBtn.style.flex='1';
        okBtn.style.background='#2a6aff'; okBtn.style.color='#fff'; okBtn.style.border='none';
        okBtn.style.padding='10px 14px'; okBtn.style.borderRadius='8px'; okBtn.style.cursor='pointer';
        actions.appendChild(okBtn);
overlay.appendChild(actions);

        document.body.appendChild(overlay);
document.addEventListener('keydown', function(e){ if (e.key==='Escape') hide(); }, {passive:true});
        document.addEventListener('mousedown', function(e){ try { if (overlay && overlay.style.display!=='none' && !overlay.contains(e.target) && e.target!==activeInput) { overlay.hide(); } } catch(_){ } }, true);

        function hide(){ overlay.style.display='none'; activeInput = null; }
        overlay.hide = hide;

        function drawHue(){
          var grd = hueCtx.createLinearGradient(0,0,hueCanvas.width,0);
          grd.addColorStop(0,'#f00'); grd.addColorStop(1/6,'#ff0');
          grd.addColorStop(2/6,'#0f0'); grd.addColorStop(3/6,'#0ff');
          grd.addColorStop(4/6,'#00f'); grd.addColorStop(5/6,'#f0f'); grd.addColorStop(1,'#f00');
          hueCtx.fillStyle = grd; hueCtx.fillRect(0,0,hueCanvas.width,hueCanvas.height);
        }
        function drawSV(){
          var w=svCanvas.width,h=svCanvas.height;
          var rgb=hsv2rgb(hue,1,1);
          svCtx.fillStyle = 'rgb('+rgb.r+','+rgb.g+','+rgb.b+')';
          svCtx.fillRect(0,0,w,h);
          var g1=svCtx.createLinearGradient(0,0,w,0);
          g1.addColorStop(0,'#fff'); g1.addColorStop(1,'rgba(255,255,255,0)');
          svCtx.fillStyle=g1; svCtx.fillRect(0,0,w,h);
          var g2=svCtx.createLinearGradient(0,0,0,h);
          g2.addColorStop(0,'rgba(0,0,0,0)'); g2.addColorStop(1,'#000');
          svCtx.fillStyle=g2; svCtx.fillRect(0,0,w,h);
          var x = clamp(sat,0,1)*w, y = (1-clamp(val,0,1))*h;
          svCtx.beginPath(); svCtx.arc(x,y,6,0,Math.PI*2);
          svCtx.lineWidth=2; svCtx.strokeStyle='#fff'; svCtx.stroke();
          svCtx.beginPath(); svCtx.arc(x,y,5,0,Math.PI*2);
          svCtx.strokeStyle='#000'; svCtx.stroke();
        }
        function updateInputs(){
          var rgb=hsv2rgb(hue,sat,val);
          rIn.value=rgb.r; gIn.value=rgb.g; bIn.value=rgb.b;
        }
        function setFromRGB(r,g,b){
          r=clamp(+r||0,0,255); g=clamp(+g||0,0,255); b=clamp(+b||0,0,255);
          var hsv=rgb2hsv(r,g,b); hue=hsv.h; sat=hsv.s; val=hsv.v;
          drawHue(); drawSV(); updateInputs(); pushPreview();
        }
        function pushPreview(){
          var hex = window.__sanitizeHex(rgb2hex(+rIn.value||0, +gIn.value||0, +bIn.value||0));
          if (activeInput===hairInp) { applied.hair = hex; schedulePreview(); }
          else if (activeInput===skinInp) { applied.skin = hex; schedulePreview(); }
          else if (activeInput===clothesInp) { applied.clothes = hex; schedulePreview(); }
        }

        hueCanvas.addEventListener('mousedown', function(e){
          var rect=hueCanvas.getBoundingClientRect();
          function move(ev){
            var x = clamp((ev.clientX-rect.left)/rect.width,0,1);
            hue = x*360; drawSV(); updateInputs(); pushPreview();
          }
          function up(){ window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }
          move(e); window.addEventListener('mousemove',move); window.addEventListener('mouseup',up);
        });
        svCanvas.addEventListener('mousedown', function(e){
          var rect=svCanvas.getBoundingClientRect();
          function move(ev){
            var x = clamp((ev.clientX-rect.left)/rect.width,0,1);
            var y = clamp((ev.clientY-rect.top)/rect.height,0,1);
            sat = x; val = 1-y; drawSV(); updateInputs(); pushPreview();
          }
          function up(){ window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }
          move(e); window.addEventListener('mousemove',move); window.addEventListener('mouseup',up);
        });
        [rIn,gIn,bIn].forEach(function(inp){
          inp.addEventListener('input', function(){ setFromRGB(rIn.value,gIn.value,bIn.value); }, {passive:true});
        });

        okBtn.addEventListener('click', async function(){
          try {
            var hex = window.__sanitizeHex(rgb2hex(+rIn.value||0, +gIn.value||0, +bIn.value||0));
            if (activeInput){ activeInput.value = hex; }
            pushPreview();
            overlay.hide();
          } catch(_){}
        }, {passive:true});
      }

      function openPickerFor(input){
        ensureOverlay();
        activeInput = input;
        var rect = input.getBoundingClientRect();
        overlay.style.left = Math.min(window.innerWidth-280, rect.left) + 'px';
        overlay.style.top  = Math.min(window.innerHeight-260, rect.bottom + 6) + 'px';
        overlay.style.display='block';
        var rgb = hex2rgb(input.value||'#000000');
        var hsv = rgb2hsv(rgb.r, rgb.g, rgb.b);
        hue=hsv.h; sat=hsv.s; val=hsv.v;
        (function renderStart(){
          // draw hue
          var grd = hueCtx.createLinearGradient(0,0,hueCanvas.width,0);
          grd.addColorStop(0,'#f00'); grd.addColorStop(1/6,'#ff0');
          grd.addColorStop(2/6,'#0f0'); grd.addColorStop(3/6,'#0ff');
          grd.addColorStop(4/6,'#00f'); grd.addColorStop(5/6,'#f0f'); grd.addColorStop(1,'#f00');
          hueCtx.fillStyle = grd; hueCtx.fillRect(0,0,hueCanvas.width,hueCanvas.height);
          // draw SV and inputs
          var w=svCanvas.width,h=svCanvas.height;
          var base=hsv2rgb(hue,1,1);
          svCtx.fillStyle='rgb('+base.r+','+base.g+','+base.b+')'; svCtx.fillRect(0,0,w,h);
          var g1=svCtx.createLinearGradient(0,0,w,0);
          g1.addColorStop(0,'#fff'); g1.addColorStop(1,'rgba(255,255,255,0)');
          svCtx.fillStyle=g1; svCtx.fillRect(0,0,w,h);
          var g2=svCtx.createLinearGradient(0,0,0,h);
          g2.addColorStop(0,'rgba(0,0,0,0)'); g2.addColorStop(1,'#000');
          svCtx.fillStyle=g2; svCtx.fillRect(0,0,w,h);
          rIn.value=rgb.r; gIn.value=rgb.g; bIn.value=rgb.b;
          var x = clamp(sat,0,1)*w, y = (1-clamp(val,0,1))*h;
          svCtx.beginPath(); svCtx.arc(x,y,6,0,Math.PI*2); svCtx.lineWidth=2; svCtx.strokeStyle='#fff'; svCtx.stroke();
          svCtx.beginPath(); svCtx.arc(x,y,5,0,Math.PI*2); svCtx.strokeStyle='#000'; svCtx.stroke();
        })();
      }

      function intercept(input){
        function handler(ev){ try { ev.preventDefault(); ev.stopPropagation(); input.blur(); openPickerFor(input); } catch(_){ } return false; }
        input.addEventListener('mousedown', handler, true);
        input.addEventListener('focus', function(ev){ handler(ev); }, true);
        input.addEventListener('click', handler, true);
      }
      intercept(hairInp); intercept(skinInp); intercept(clothesInp);
    })();
    // --- end custom color palette ---
// Floating 'Valider' overlay near native color picker (cannot inject inside OS picker)
    var __colorOverlay;
    function hideColorOverlay(){ try { if(__colorOverlay) __colorOverlay.style.display='none'; } catch(_){}}
    function showColorOverlay(target){
      var T = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang]||TRANSLATIONS['en'])) || {};
       try {
      if(!__colorOverlay){
        __colorOverlay = document.createElement('div');
        __colorOverlay.id = 'colorValidateOverlay';
        __colorOverlay.style.position = 'fixed';
        __colorOverlay.style.zIndex = '999999';
        __colorOverlay.style.padding = '6px';
        __colorOverlay.style.background = '#111';
        __colorOverlay.style.border = '1px solid #333';
        __colorOverlay.style.borderRadius = '8px';
        __colorOverlay.style.boxShadow = '0 6px 18px rgba(0,0,0,.35)';
        var __btn = document.createElement('button');
        __btn.id = 'skinApplyAllInline';
        __btn.textContent = ((T.validate||'Apply'));
        __btn.style.background = '#2a6aff';
        __btn.style.color = '#fff';
        __btn.style.border = 'none';
        __btn.style.borderRadius = '6px';
        __btn.style.padding = '8px 12px';
        __btn.style.cursor = 'pointer';
        __btn.onclick = function(){ try { applied.hair = hairInp.value; applied.skin = skinInp.value; applied.clothes = clothesInp.value; drawPreview(); } catch(_){ } hideColorOverlay(); };
        __colorOverlay.appendChild(__btn);
        document.body.appendChild(__colorOverlay);
      }
      var r = target.getBoundingClientRect();
      var left = Math.min(window.innerWidth - 160, Math.max(8, r.right + 8));
      var top = Math.min(window.innerHeight - 48, Math.max(8, r.top));
      __colorOverlay.style.left = left + 'px';
      __colorOverlay.style.top = top + 'px';
      __colorOverlay.style.display = 'block';
    } catch(_){}}
    ;[hairInp, skinInp, clothesInp].forEach(function(inp){
      try {
        inp.addEventListener('focus', function(){ showColorOverlay(inp); }, {passive:true});
        inp.addEventListener('click', async function(){ showColorOverlay(inp); }, {passive:true});
        inp.addEventListener('blur', function(){ setTimeout(hideColorOverlay, 150); }, {passive:true});
      } catch(_){ }
    });
// Throttled live preview bookkeeping
    var previewToken = 0;
    var _rafPending = false;
    function schedulePreview(){
      if (_rafPending) return;
      _rafPending = true;
      requestAnimationFrame(function(){
        _rafPending = false;
        drawPreview();
      });
    }


    // Applied colors state (validated by the user)
    var applied = { hair: hairInp.value, skin: skinInp.value, clothes: clothesInp.value };
    try {
      if (__mySkin) {
        if (__mySkin.hair) { applied.hair = __mySkin.hair; hairInp.value = __mySkin.hair; }
        if (__mySkin.skin) { applied.skin = __mySkin.skin; skinInp.value = __mySkin.skin; }
        if (__mySkin.clothes) { applied.clothes = __mySkin.clothes; clothesInp.value = __mySkin.clothes; }
      }
    } catch(_){}


    
function drawPreview(){
      if (!__basePlayerImg || !__basePlayerImg.complete) { 
        ctx.clearRect(0,0,canvas.width,canvas.height);
        return;
      }
      // Token to drop stale async renders
      previewToken++;
      var myToken = previewToken;
      recolorPlayerImage(__basePlayerImg, applied, function(img){
        // drop outdated renders that finished later
        if (myToken !== previewToken) return;
        try {
          ctx.clearRect(0,0,canvas.width,canvas.height);
          var s = Math.min(canvas.width / (__basePlayerImg.width||64), canvas.height / (__basePlayerImg.height||64));
          var w = (__basePlayerImg.width||64) * s;
          var h = (__basePlayerImg.height||64) * s;
          var x = (canvas.width - w)/2, y = (canvas.height - h)/2;
          ctx.drawImage(img||__basePlayerImg, x, y, w, h);
        } catch(_){}
      });
    }


    // Prefill from saved skin if any
    if (__mySkin){
      try { if (__mySkin.hair) hairInp.value = __mySkin.hair; }catch(_){}
      try { if (__mySkin.skin) skinInp.value = __mySkin.skin; }catch(_){}
      try { if (__mySkin.clothes) clothesInp.value = __mySkin.clothes; }catch(_){}
    }
    // Live preview while picking (even before clicking “Valider”)
    hairInp.oninput = function(){ hairInp.value = window.__sanitizeHex(hairInp.value); applied.hair = hairInp.value; schedulePreview(); };
    skinInp.oninput = function(){ skinInp.value = window.__sanitizeHex(skinInp.value); applied.skin = skinInp.value; schedulePreview(); };
    clothesInp.oninput = function(){ clothesInp.value = window.__sanitizeHex(clothesInp.value); applied.clothes = clothesInp.value; schedulePreview(); };

    function buyNow(){
      msg.textContent = '';
      fetch('/api/skin/buy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ hair: applied.hair, skin: applied.skin, clothes: applied.clothes })
      }).then(function(r){ return r.json(); })
        .then(function(j){
          if (j && j.ok){
            __mySkin = j.skin || { hair: hairInp.value, skin: skinInp.value, clothes: clothesInp.value };
            // Bust my cached sprite
            try { if (__myUser) __spriteCache[String(__myUser).toLowerCase()] = null; } catch(_){}
            // Update shop gold value if present
            try { var gv = document.getElementById('shopGoldVal'); if (gv) gv.textContent = String(j.gold|0); } catch(_){}
            msg.style.color = '#9f9';
            msg.textContent = (T.saved||'Saved!');
            setTimeout(function(){ try { document.getElementById('skinModal').style.display='none'; }catch(_){ } }, 500);
          } else {
            msg.style.color = '#f99';
            if (j && j.code === 'not_enough_gold') msg.textContent = 'Not enough gold.';
            else if (j && j.code === 'bad_colors') msg.textContent = 'Pick valid colors.';
            else msg.textContent = 'Action impossible.';
          }
        }).catch(function(){
          msg.style.color = '#f99'; msg.textContent = 'Server unavailable.';
        });
    }
document.getElementById('skinBuy').onclick = buyNow;

    
// Style Buy button based on Gold
(function(){
  var btn = document.getElementById('skinBuy');
  if (!btn) return;
  var PRICE = 20;
  function getGold(){ try{ var t = document.getElementById('shopGoldVal'); return t ? (+t.textContent||0) : 0; }catch(_){ return 0; } }
  function applyStyle(){ var g = getGold(); if (g >= PRICE){ btn.disabled=false; btn.style.background='#ff8800'; btn.style.opacity='1'; btn.style.cursor='pointer'; } else { btn.disabled=true; btn.style.background='#ff8800'; btn.style.opacity='0.6'; btn.style.cursor='not-allowed'; } }
  applyStyle();
  try{ var gv=document.getElementById('shopGoldVal'); if (gv && window.MutationObserver){ var mo=new MutationObserver(applyStyle); mo.observe(gv,{childList:true,characterData:true,subtree:true}); } }catch(_){}
  // Also re-apply style after any click in modal (safety)
  try{ var modal=document.getElementById('skinModal'); if (modal){ modal.addEventListener('click', async function(){ setTimeout(applyStyle,0); }, {passive:true}); } }catch(_){ }
})();
// Ensure base image ready
    if (!__basePlayerImg) { __basePlayerImg = new Image(); try{ __basePlayerImg.onerror=function(){ try{ this.onerror=null; this.src='/sprites/player.png'; }catch(_){}}; }catch(_){} __basePlayerImg.src='public/sprites/player.png'; }
    if (__basePlayerImg.complete) { drawPreview(); } else { __basePlayerImg.onload = drawPreview; }

    modal.style.display = 'flex';
  }
  try { window.openSkinModal = openSkinModal; } catch(_){}
  try { if (!window.fetchMe) window.fetchMe = fetchMe; } catch(_){}


  function injectSkinItem(){
    // also handle account modal variant
    try{
      var wrap = document.getElementById('shopUpgradesLobby');
      if (wrap && !wrap.querySelector('[data-skin-item="1"]')){
        // Always ensure any existing Customize buttons are bound
        try{ Array.prototype.slice.call(wrap.querySelectorAll('.skinOpenBtn')).forEach(function(b){ if (!b.__bound){ b.__bound=true; b.addEventListener('click', async function(){ try{ (window.__openCharacterSkin||window.openSkinModal||openSkinModal||function(){})();; }catch(_){ } }, { passive:true }); } }); }catch(_){}

        var div = document.createElement('div');
        div.setAttribute('data-skin-item','1');
        div.style.cssText = 'display:flex;align-items:center;gap:12px;border:1px solid #344;padding:12px;border-radius:12px;margin:8px 0;';
        div.innerHTML = ''
          + '  <div style="width:40px;height:40px;border-radius:10px;border:2px solid #66c;display:flex;align-items:center;justify-content:center;overflow:hidden;background:#223;">'
          + '    <img src="/sprites/player.png" alt="player" style="width:100%;height:100%;image-rendering:pixelated;object-fit:contain;">'
          + '  </div>'
          + '  <div style="flex:1;">'
          + '    <div style="font-size:17px;font-weight:700;">' + ((T.characterSkin||'Character skin')) + '</div>'
          + '    <div style="color:#9ab;font-size:13px;">' + ((T.characterSkinDesc||'Customize hair, skin and clothes colors.')) + '</div>'
          + '  </div>'
          + '  <div style="display:flex;flex-direction:column;align-items:center;gap:6px;min-width:180px;width:180px;">'
          + '    <div style="font-size:14px;">' + ((T.price||'Price')) + ': <b>20</b> ' + ((T.gold||'Gold')) + '</div>'
          + '    <button class="skinOpenBtn" type="button" style="pointer-events:auto; onclick="try{window.__openCharacterSkin && window.__openCharacterSkin();}catch(e){}" style="pointer-events:auto; padding:7px 14px;background:#4aa3ff;color:#fff;border:none;border-radius:8px;cursor:pointer;">' + ((T.customize||'Customize')) + '</button>'
          + '    <div style="min-height:16px;"></div>'
          + '  </div>';
        wrap.appendChild(div);
        var b = div.querySelector('.skinOpenBtn'); if (b && !b.__bound){ b.__bound=true;
        try { if (b) { b.removeAttribute('style'); b.classList.add('skinOpenBtn'); } } catch(_){}
 b.addEventListener('click', async function(){ try{ (window.__openCharacterSkin||window.openSkinModal||openSkinModal||function(){})();; }catch(_){ } }, { passive:true }); }
      }
    }catch(_){ }

    try{
      var cont = document.getElementById('shopPanelContent');
      if (!cont) return;
      if (cont.querySelector('[data-skin-item="1"]')) return;

      // Always ensure any existing Customize buttons are bound
      try{ Array.prototype.slice.call(cont.querySelectorAll('.skinOpenBtn')).forEach(function(b){ if (!b.__bound){ b.__bound=true; b.addEventListener('click', async function(){ try{ (window.__openCharacterSkin||window.openSkinModal||openSkinModal||function(){})();; }catch(_){ } }, { passive:true }); } }); }catch(_){}

      var item = document.createElement('div');
      item.setAttribute('data-skin-item', '1');
      item.style.cssText = 'display:flex;align-items:center;gap:12px;border:1px solid #344;padding:12px;border-radius:12px;margin:8px 0;';
      item.innerHTML = ''
        + '  <div style="width:40px;height:40px;border-radius:10px;border:2px solid #66c;display:flex;align-items:center;justify-content:center;overflow:hidden;background:#223;">'
        + '    <img src="/sprites/player.png" alt="player" style="width:100%;height:100%;image-rendering:pixelated;object-fit:contain;">'
        + '  </div>'
        + '  <div style="flex:1;">'
        + '    <div style="font-size:17px;font-weight:700;">' + ((T.characterSkin||'Character skin')) + '</div>'
        + '    <div style="color:#9ab;font-size:13px;">' + ((T.characterSkinDesc||'Customize hair, skin and clothes colors.')) + '</div>'
        + '  </div>'
        + '  <div style="display:flex;flex-direction:column;align-items:center;gap:6px;min-width:180px;width:180px;">'
        + '    <div style="font-size:14px;">' + ((T.price||'Price')) + ': <b>20</b> ' + ((T.gold||'Gold')) + '</div>'
        + '    <button id="btnOpenSkin" type="button" style="pointer-events:auto; onclick="try{window.__openCharacterSkin && window.__openCharacterSkin();}catch(e){}" style="pointer-events:auto; padding:7px 14px;background:#4aa3ff;color:#fff;border:none;border-radius:8px;cursor:pointer;">' + ((T.customize||'Customize')) + '</button>'
        + '    <div style="min-height:16px;"></div>'
        + '  </div>';
      cont.appendChild(item);
      var o = document.getElementById('btnOpenSkin');
      if (o && !o.__bound){ o.__bound=true;
      try { if (o) { o.removeAttribute('style'); o.classList.add('skinOpenBtn'); } } catch(_){}
 o.addEventListener('click', async function(){ try{ (window.__openCharacterSkin||window.openSkinModal||openSkinModal||function(){})();; }catch(_){ } }, { passive:true }); }
    }catch(_){}
  }

  // Hook into refreshShopPanel to insert the item after default upgrades are rendered
  (function hook(){
    try{
      var orig = window.refreshShopPanel;
      window.refreshShopPanel = function(){
        try{ if (typeof orig==='function') orig.apply(this, arguments); }catch(_){}
        try{ injectSkinItem(); }catch(_){}
      };
    }catch(_){
      // If not yet defined, retry
      setTimeout(hook, 80);
      return;
    }
  })();

  // Initial fetch (lazy) to learn username + saved skin
  try { setTimeout(fetchMe, 0); } catch(_){}

  // Ensure injection even if shop is already open at startup
  try {
    var __obs = new MutationObserver(function(){ try{ injectSkinItem(); }catch(_){} });
    __obs.observe(document.body, { childList:true, subtree:true });
    // Also attempt a few times on a timer (idempotent)
    var __tries=0; var __tm = setInterval(function(){ try{ injectSkinItem(); }catch(_){} if(++__tries>20) clearInterval(__tm); }, 250);
  } catch(_){}


  // Global, resilient opener (works even if openSkinModal not yet defined)
  try {
    if (typeof window.__openCharacterSkin !== 'function') {
      window.__openCharacterSkin = function(){
        try {
          if (typeof window.fetchMe === 'function') { try{ window.fetchMe(); }catch(_){} }
          if (typeof window.openSkinModal === 'function') return window.openSkinModal();
          if (typeof openSkinModal === 'function') return openSkinModal();
          var tries = 0;
          var id = setInterval(function(){
            tries++;
            try {
              if (typeof window.openSkinModal === 'function') { clearInterval(id); window.openSkinModal(); return; }
              if (typeof openSkinModal === 'function')         { clearInterval(id); openSkinModal(); return; }
            } catch(_){}
            if (tries > 40) clearInterval(id);
          }, 50);
        } catch(_){}
      };
    }
    // Document-level capture listener (works even if inner containers stop propagation)
    document.addEventListener('click', function(ev){
      try {
        var t = ev.target;
        if (!t) return;
        var btn = t.closest ? t.closest('.skinOpenBtn') : null;
        if (!btn) return;
        ev.preventDefault();
        window.__openCharacterSkin();
      } catch(_){}
    }, true);
  } catch(_){}

})();
</script>
<!-- /[PATCH] character-skin shop & recolor v1 -->

<!-- In‑game Bottom Menu (auto‑injected by patch) -->
<!-- In-game Bottom Menu (updated patch) -->
<!-- In-game Bottom Menu (updated patch v2) -->
<style id="igMenuStyle">
  #inGameMenu {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 12px;
    z-index: 10050;
    display: none;
    gap: 8px;
    padding: 8px;
    border-radius: 14px;
    background: rgba(12,14,18,0.68);
    box-shadow: 0 8px 28px rgba(0,0,0,0.45), inset 0 0 0 1px rgba(255,255,255,0.06);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    pointer-events: auto;
  }
.ig-btn {
    appearance: none;
    border: 1px solid rgba(255,255,255,0.12);
    background: linear-gradient(#1b2027, #13161b);
    color: #f2f6ff;
    border-radius: 10px;
    padding: 8px 12px;
    font: 600 14px/1 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif;
    letter-spacing: .2px;
    cursor: pointer;
    /* Prevent text selection and focus outline on in‑game buttons. The
       global form-focus override sets user-select:text on all buttons, so
       we override it here with !important flags. This also removes the
       default focus outline to avoid the white border when using keyboard
       navigation. */
    -webkit-user-select: none !important;
    user-select: none !important;
    outline: none !important;
    transition: transform .06s ease, background .12s ease, box-shadow .12s ease, border-color .12s ease, color .12s ease;
    box-shadow: 0 2px 10px rgba(0,0,0,0.25);
    min-width: 76px;
  
    position: relative;
  }
  .ig-btn:active { transform: translateY(1px) scale(0.99); filter: brightness(1.15); }
  .ig-btn.notify::after{
    content:''; position:absolute; right:-4px; top:-4px; width:10px; height:10px; border-radius:50%;
    background:#e33; border:2px solid rgba(18,18,18,0.8);
  }
  .ig-btn.active {
    background: linear-gradient(#2b3a52, #1a2230);
    border-color: #4b6aa9;
    box-shadow: 0 0 0 2px rgba(82,136,255,0.25) inset, 0 4px 14px rgba(0,0,0,0.35);
    color: #dfe9ff;
  }
  .ig-btn.danger { border-color: rgba(255,68,68,0.35); }
  .ig-btn.danger.active, .ig-btn.danger:active { background: linear-gradient(#612226, #3e1518); border-color: #b3363c; color: #fff; }

  /* Stats = reuse legacy #hudStats, but float it like a bubble */
  #hudStats.ig-floating {
    position: fixed !important;
    /* Place stats bubble near the bottom‑left of the screen instead of centered */
    left: 12px !important;
    transform: none !important;
    bottom: 8px !important; bottom: calc(env(safe-area-inset-bottom, 0px) + 8px) !important;
    z-index: 10051 !important;
    display: none;
    padding: 10px 12px;
    border-radius: 12px;
    background: rgba(14,16,20,0.88);
    color: #fff;
    box-shadow: 0 8px 28px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
    font: 600 14px/1.25 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif;
    white-space: nowrap;
   width: -moz-fit-content; width: fit-content; max-width: min(96vw, 520px);}

  /* Chat floating above menu (narrower) */
  #chatPanel.ig-floating {
    position: fixed !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    bottom: 66px !important;
    z-index: 10051 !important;
    display: none;
    max-height: min(50vh, 480px);
    width: min(84vw, 520px);
    box-shadow: 0 8px 28px rgba(0,0,0,.6);
    border-radius: 12px;
    overflow: hidden auto;
  }

  /* Build mini panel (larger; fixed hint) */
  #igBuildPanel {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 66px;
    z-index: 10051;
    display: none;
    padding: 12px 14px;
    border-radius: 12px;
    background: rgba(14,16,20,0.88);
    color: #fff;
    box-shadow: 0 8px 28px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
    min-width: unset;
    width: -moz-fit-content;
    width: fit-content;
    max-width: min(96vw, 720px);
  }
  #igBuildTiles { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; justify-content: center; }
  #igBuildTiles .build-tile { outline: none; }
  #igBuildHint { margin-top: 6px; text-align: center; font: 600 13px/1.1 ui-sans-serif,system-ui; color:#cfe2ff; opacity:.92; height: 18px; overflow: hidden; text-overflow: ellipsis; }

  /* Tooltip bubble outside panel to avoid resizing */
  #buildTooltip { position:absolute; display:none; left:0; top:0; background:#121418ee; color:#fff; border-radius:10px; padding:8px 10px; font:600 13px ui-sans-serif,system-ui; box-shadow:0 6px 24px #000c; pointer-events:none; white-space:nowrap; z-index:11000; }

  /* Confirm modal (login-like) */
  #igConfirmOverlay { position: fixed; inset: 0; background: rgba(0,0,0,.55); z-index: 12000; display: none; align-items: center; justify-content: center; }
  #igConfirmBox { width: min(440px, 92vw); background: rgba(27,29,34,.96); border-radius: 16px; box-shadow: 0 12px 48px #000c; padding: 18px; color:#eef3ff; }
  #igConfirmBox h3 { margin: 0 0 8px; font: 800 22px/1 ui-sans-serif,system-ui; }
  #igConfirmBox p { margin: 0 0 14px; color:#b9c5d9; }
  #igConfirmBtns { display:flex; gap:10px; justify-content:flex-end; }
  #igConfirmBtns .ig-btn { min-width: 96px; }

  /* Upgrades panel: remove green outline */
  #shopModal { border: none !important; outline: none !important; box-shadow: 0 8px 28px rgba(0,0,0,.7) !important; }

  @media (hover: none) and (pointer: coarse){
    #inGameMenu{ gap:6px; padding:6px; bottom: 10px; }
    .ig-btn{ padding:10px 12px; font-size:15px; min-width:72px; }
    #chatPanel.ig-floating{ bottom: 70px; font-size:15px; }
    #igBuildPanel{ bottom: 70px; }
  }
</style>

<script id="igMenuPatch">
(function(){
  try{
    // ---------- tiny utils
    function $(id){ return document.getElementById(id); }
    function show(el){ if (el) el.style.display='block'; }
    function hide(el){ if (el) el.style.display='none'; }
    function isShown(el){
      if (!el) return false;
      var cs = window.getComputedStyle(el);
      return !!(cs && cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0');
    }
    function toggle(el){ if (!el) return; isShown(el) ? hide(el) : show(el); }
    function setActive(btn, on){ if (!btn) return; btn.classList[on?'add':'remove']('active'); }
    function vibr(ms){ try{ if (navigator && navigator.vibrate) navigator.vibrate(ms||6); }catch(_){} }

    // ---------- menu container
    var menu = $('inGameMenu');
    if (!menu){
      menu = document.createElement('div');
      menu.id = 'inGameMenu';
      menu.setAttribute('aria-label','In-game quick menu');
      document.body.appendChild(menu);
    }

    function mkBtn(key, label){
      var b = document.createElement('button');
      b.className = 'ig-btn';
      b.type = 'button';
      b.dataset.action = key;
      b.textContent = label;
  // Remove the button from the tab order to prevent keyboard focus and
  // accidental arrow‑key selection. This also helps avoid the white
  // outline that appears when a button receives focus via the keyboard.
  b.tabIndex = -1;
      return b;
    }

    var T = (window.TRANSLATIONS && (window.TRANSLATIONS[window.currentLang] || window.TRANSLATIONS.en)) || {};
    var L = {
      stats   : T.stats     || 'Stats',
      chat    : T.chat      || 'Chat',
      autofire: (T.autoFire||T.autofire||'Auto fire'),
      build   : T.build     || 'Build',
      upgrade : (T.upgradeLabel || T.shop || (T.upgrades && (T.upgrades.title || T.upgrades.button)) || 'Upgrades'),
      leave   : T.leaveGame || 'Leave'
    };

    var btnStats = mkBtn('stats', L.stats);
    var btnChat  = mkBtn('chat',  L.chat);
    var btnAuto  = mkBtn('autofire', L.autofire);
    var btnBuild = mkBtn('build', L.build);
    var btnShop  = mkBtn('upgrade', L.upgrade);
    var btnLeave = mkBtn('leave', L.leave); btnLeave.classList.add('danger');

    if (!menu.__filled){
      menu.__filled = true;
      menu.appendChild(btnStats);
      menu.appendChild(btnChat);
      menu.appendChild(btnAuto);
      menu.appendChild(btnBuild);
      menu.appendChild(btnShop);
      
menu.appendChild(btnLeave);
// --- Ensure mutual exclusivity of panels + chat notify clear ---
try{
  btnStats.addEventListener('click', function(){
    try{
      if (chat) hide(chat);
      if (buildPanel) hide(buildPanel);
      try{ if (typeof closeUpgrades==='function') closeUpgrades(); }catch(_){}
      setActive(btnChat,false); setActive(btnBuild,false); setActive(btnShop,false);
    }catch(_){}
  }, true);
  btnChat.addEventListener('click', function(){
    try{
      // Do not hide stats or deselect it when toggling chat; just remove notification.
      try{ if (btnChat) btnChat.classList.remove('notify'); }catch(_){}
    }catch(_){}
  }, true);
  btnBuild.addEventListener('click', function(){
    try{
      // Opening the build panel should not close the stats bubble or deselect the stats button.
    }catch(_){}
  }, true);
  btnShop.addEventListener('click', function(){
    try{
      // Opening the upgrades panel should not close the stats bubble or deselect the stats button.
    }catch(_){}
  }, true);
}catch(_){}
// Chat notification helpers (used by chat module)
try{
  if (!window.__igChatNotify) window.__igChatNotify = function(){
    try{ if (btnChat && chat && chat.style && chat.style.display==='none'){ btnChat.classList.add('notify'); } }catch(_){}
  };
  if (!window.__igChatClearNotify) window.__igChatClearNotify = function(){
    try{ if (btnChat) btnChat.classList.remove('notify'); }catch(_){}
  };
}catch(_){}

    // --- Ensure mutual exclusivity of panels + chat notify clear ---
    try{
      btnStats.addEventListener('click', function(){
        try{
          if (chat) hide(chat);
          if (buildPanel) hide(buildPanel);
          try{ if (typeof closeUpgrades==='function') closeUpgrades(); }catch(_){}
          setActive(btnChat,false); setActive(btnBuild,false); setActive(btnShop,false);
        }catch(_){}
      }, true);
      btnChat.addEventListener('click', function(){
        try{
          // Do not hide stats or deselect it; just remove the notification badge
          try{ if (btnChat) btnChat.classList.remove('notify'); }catch(_){}
        }catch(_){}
      }, true);
      btnBuild.addEventListener('click', function(){
        try{
          // Opening the build or upgrades panel should not close the stats bubble or deselect the stats button.
        }catch(_){ }
      }, true);
      btnShop.addEventListener('click', function(){
        try{
          // Opening the build or upgrades panel should not close the stats bubble or deselect the stats button.
        }catch(_){ }
      }, true);
    }catch(_){}
    // Chat notification helpers (used by chat module)
    try{
      if (!window.__igChatNotify) window.__igChatNotify = function(){
        try{ if (btnChat && !(chat && chat.style && chat.style.display!== 'none')){ /* reserved */ } }catch(_){}
        try{ if (btnChat && chat && chat.style && chat.style.display==='none'){ btnChat.classList.add('notify'); } }catch(_){}
      };
      if (!window.__igChatClearNotify) window.__igChatClearNotify = function(){
        try{ if (btnChat) btnChat.classList.remove('notify'); }catch(_){}
      };
    }catch(_){}

    }

    // ---------- floating panels
    var hudStats = $('hudStats'); if (hudStats){ hudStats.classList.add('ig-floating'); hide(hudStats); }
    var chat = $('chatPanel');

    // ---------- Build panel and tooltips
    var buildPanel = $('igBuildPanel');
    if (!buildPanel){
      buildPanel = document.createElement('div');
      buildPanel.id = 'igBuildPanel';
      buildPanel.innerHTML = '<div id="igBuildTiles"></div><div id="igBuildHint" aria-live="polite"></div>';
      document.body.appendChild(buildPanel);
    }
    var igTiles = $('igBuildTiles');

    function tipForType(dt){
      try { if (typeof computeTipForType === 'function') { var t = computeTipForType(dt); if (t) return t; } } catch(_){}
      try {
        var origWrap = $('buildTiles');
        if (origWrap){
          var orig = origWrap.querySelector('.build-tile[data-type="'+dt+'"]');
          if (orig) return orig.getAttribute('data-tip') || orig.getAttribute('title') || orig.getAttribute('aria-label') || '';
        }
      } catch(_){}
      return '';
    }
    function ensureTooltip(){
      try { if (window.getBuildTooltipBox) { return window.getBuildTooltipBox(); } } catch(_){}
      var box = document.getElementById('buildTooltip') || document.getElementById('buildTooltipStable');
      if (!box || box.id === 'buildTooltipStable') {
        if (box && box.id === 'buildTooltipStable') return box;
        box = document.createElement('div');
        box.id = 'buildTooltip';
        box.style.cssText = 'position:absolute;display:none;left:0;top:0;background:#111c;color:#fff;font-size:13px;padding:8px 10px;border-radius:8px;box-shadow:0 4px 18px #000c;pointer-events:none;white-space:nowrap;z-index:11000;';
        document.body.appendChild(box);
      }
      return box;
    }

    function positionTooltipNear(el, box){
      var r = el.getBoundingClientRect();
      var x = r.left + r.width/2, y = r.top - 10;
      box.style.left = Math.max(8, Math.min(window.innerWidth - 8, x)) + 'px';
      box.style.top  = Math.max(8, y) + 'px';
    }

    function bindTileClone(clone, dt){
      // prevent native tooltip flicker on clones
      if (clone.hasAttribute('title')) clone.setAttribute('title','');
      clone.addEventListener('click', function(){
        try { var orig = $('buildTiles').querySelector('.build-tile[data-type="'+dt+'"]'); if (orig) orig.click(); } catch(_){}
      }, { passive:true });
      clone.addEventListener('mouseenter', function(){
        try {
          var tip = tipForType(dt);
          var box = ensureTooltip();
          box.textContent = tip || '';
          positionTooltipNear(clone, box);
          box.style.display = 'block';
        } catch(_){}
      }, { passive:true });
      clone.addEventListener('mousemove', function(){
        try { var box = $('buildTooltip'); if (box && box.style.display==='block') positionTooltipNear(clone, box); } catch(_){}
      }, { passive:true });
      clone.addEventListener('mouseleave', function(){ try{ var box=$('buildTooltip'); if (box) box.style.display='none'; }catch(_){} }, { passive:true });
    }

    function cloneTiles(){
      if (!igTiles) return;
      igTiles.innerHTML = ''; // always rebuild for safety
      var src = $('buildTiles');
      if (src){
        var tiles = src.querySelectorAll('.build-tile[data-type]');
        tiles.forEach(function(t){
          var dt = t.getAttribute('data-type');
          var clone = t.cloneNode(true);
          clone.classList.add('build-tile');
          bindTileClone(clone, dt);
          igTiles.appendChild(clone);
        });
        igTiles.__filled = true;
      } else {
        // if not available yet, observe and fill when it appears
        if (window.MutationObserver && !igTiles.__observing){
          igTiles.__observing = true;
          var obs = new MutationObserver(function(){
            if ($('buildTiles')){ try{ cloneTiles(); obs.disconnect(); }catch(_){ } }
          });
          obs.observe(document.body, { childList:true, subtree:true });
        }
      }
    }
    cloneTiles();

    // ---------- Confirm modal for Leave
    var confirmOverlay = $('igConfirmOverlay');
    if (!confirmOverlay){
      confirmOverlay = document.createElement('div');
      confirmOverlay.id = 'igConfirmOverlay';
      confirmOverlay.innerHTML = (function(){var tr=(window.TRANSLATIONS&&(TRANSLATIONS[window.currentLang]||TRANSLATIONS['en']))||{};var title=tr.confirmTitle||tr.confirm||'Confirm';var text=tr.leaveConfirm||tr.leaveConfirmText||'Leave the game and return to the lobby?';var cancel=tr.cancel||'Cancel';var leave=tr.leaveGame||tr.leave||'Leave';return '<div id="igConfirmBox"><h3>'+title+'</h3><p>'+text+'</p><div id="igConfirmBtns"><button id="igCancel" class="ig-btn">'+cancel+'</button><button id="igDoLeave" class="ig-btn danger">'+leave+'</button></div></div>';})();
      document.body.appendChild(confirmOverlay);
    }
    var btnCancel = $('igCancel');
    var btnDoLeave = $('igDoLeave');

    // ---------- Upgrades panel: ULTRA-robust toggle
    function getShopModal(){
      return $('shopModal') || document.querySelector('.shop-modal, #upgradesPanel, .upgrades-panel');
    }
    function openUpgrades(){
      var sm = getShopModal();
      try { if (typeof renderShopUpgrades === 'function') renderShopUpgrades(); } catch(_){}
      if (!sm){
        try { if (typeof showShopPanel === 'function') showShopPanel(); } catch(_){}
        sm = getShopModal();
      }
      if (sm){
        // clean hide classes & show
        ['open','visible','active','show','hidden'].forEach(function(c){ sm.classList.remove(c); });
        sm.removeAttribute('aria-hidden');
        show(sm);
        sm.dataset.igOpen = '1';
      }
      setActive(btnShop, true);
      // second render after paint in case of late data
      setTimeout(function(){ try { if (typeof renderShopUpgrades === 'function') renderShopUpgrades(); } catch(_){} }, 50);
    }
    function closeUpgrades(){
      var sm = getShopModal();
      if (sm){
        // use native hide API if present
        try { if (typeof hideShopPanel === 'function') { hideShopPanel(); } } catch(_){}
        // click on any close control if exists
        try {
          var closeBtn = sm.querySelector('[data-close], .close, .btn-close, .x, .close-btn');
          if (closeBtn) closeBtn.click();
        } catch(_){}
        // hard hide
        hide(sm);
        ['open','visible','active','show'].forEach(function(c){ sm.classList.remove(c); });
        sm.setAttribute('aria-hidden','true');
        delete sm.dataset.igOpen;
      }
      setActive(btnShop, false);
    }
    function upgradesOpen(){
      var sm = getShopModal();
      if (!sm) return false;
      if (sm.dataset && sm.dataset.igOpen === '1') return true;
      return isShown(sm);
    }

    // ---------- Actions
    btnStats.addEventListener('click', function(){
      if (!hudStats) return;
      var willShow = !isShown(hudStats);
      toggle(hudStats);
      setActive(btnStats, willShow);
      vibr(6);
    }, { passive:true });

    btnChat.addEventListener('click', function(){
      if (!chat) return;
      var willShow = !isShown(chat);
      toggle(chat);
      setActive(btnChat, willShow);
      if (willShow) {
        // Close Build & Upgrades when opening Chat
        try { hide(buildPanel); setActive(btnBuild, false); } catch(_){}
        try { if (typeof upgradesOpen==='function' && typeof closeUpgrades==='function' && upgradesOpen()) { closeUpgrades(); } } catch(_){}
        try { setActive(btnShop, false); } catch(_){}
      }
      try { var inp = $('chatInput'); if (willShow && inp) inp.focus({ preventScroll:true }); } catch(_){}
    }, { passive:true });

    btnAuto.addEventListener('click', function(){
      try { var ab = $('autoFireBtn'); if (ab) { ab.click(); } } catch(_){}
      setTimeout(syncAutoBtn, 20);
    }, { passive:true });

    btnBuild.addEventListener('click', function(){
      cloneTiles();
      var willShow = !isShown(buildPanel);
      toggle(buildPanel);
      setActive(btnBuild, willShow);
      if (willShow) {
        // Close Chat & Upgrades when opening Build
        try { hide(chat); setActive(btnChat, false); } catch(_){}
        try { if (typeof upgradesOpen==='function' && typeof closeUpgrades==='function' && upgradesOpen()) { closeUpgrades(); } } catch(_){}
        try { setActive(btnShop, false); } catch(_){}
      }
      vibr(6);
    }, { passive:true });

    btnShop.addEventListener('click', function(){
      try {
        var wasOpen = (typeof upgradesOpen==='function') ? upgradesOpen() : false;
        if (wasOpen) {
          if (typeof closeUpgrades==='function') closeUpgrades();
          setActive(btnShop, false);
        } else {
          // Close Chat & Build before opening Upgrades
          try { hide(chat); setActive(btnChat, false); } catch(_){}
          try { hide(buildPanel); setActive(btnBuild, false); } catch(_){}
          if (typeof openUpgrades==='function') openUpgrades();
          setActive(btnShop, true);
        }
      } catch(_){}
    }, { passive:true });

    btnLeave.addEventListener('click', function(){
      try { confirmOverlay.style.display = 'flex'; } catch(_){}
    }, { passive:true });

    if (btnCancel) btnCancel.addEventListener('click', function(){ try{ confirmOverlay.style.display='none'; }catch(_){} }, { passive:true });
    if (btnDoLeave) btnDoLeave.addEventListener('click', function(){
      try { confirmOverlay.style.display='none'; } catch(_){}
      try { if (window.socket && socket.emit) socket.emit('leaveLobby'); } catch(_){}
      // Full refresh to guarantee clean lobby state
      setTimeout(function(){
        try { window.location.reload(); } catch(e){ try{ window.location.href = window.location.href; }catch(_){ } }
      }, 50);
    }, { passive:true });

    // --- Apply i18n to bottom menu + confirm modal ---
    function applyIgMenuI18n(){
      try{
        var T = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
        if (btnStats) btnStats.textContent = T.stats || 'Stats';
        if (btnChat)  btnChat.textContent  = T.chat || 'Chat';
        if (btnAuto)  btnAuto.textContent  = (T.autoFire || T.autofire || 'Auto fire');
        if (btnBuild) btnBuild.textContent = T.build || 'Build';
        if (btnShop)  btnShop.textContent  = (T.upgradeLabel || T.shop || (T.upgrades && (T.upgrades.title||T.upgrades.button)) || 'Upgrades');
        if (btnLeave) btnLeave.textContent = T.leaveGame || 'Leave';
        // Refresh confirm box contents in-place
        var title = T.confirmTitle || T.confirm || 'Confirm';
        var text  = T.leaveConfirm || T.leaveConfirmText || 'Leave the game and return to the lobby?';
        var cancel= T.cancel || 'Cancel';
        var leave = T.leaveGame || T.leave || 'Leave';
        var box = document.getElementById('igConfirmBox');
        if (confirmOverlay && box){
          box.innerHTML = '<h3>'+title+'</h3><p>'+text+'</p><div id="igConfirmBtns"><button id="igCancel" class="ig-btn">'+cancel+'</button><button id="igDoLeave" class="ig-btn danger">'+leave+'</button></div>';
          btnCancel = document.getElementById('igCancel');
          btnDoLeave = document.getElementById('igDoLeave');
          if (btnCancel) btnCancel.addEventListener('click', function(){ try{ confirmOverlay.style.display='none'; }catch(_){ } }, {passive:true});
          if (btnDoLeave) btnDoLeave.addEventListener('click', function(){
            try { confirmOverlay.style.display='none'; } catch(_){}
            try { if (window.socket && socket.emit) socket.emit('leaveLobby'); } catch(_){}
            setTimeout(function(){ try{ window.location.reload(); } catch(e){ try{ window.location.href = window.location.href; }catch(_){ } } }, 50);
          }, {passive:true});
        }
      }catch(_){}
    }
    // initial call; will be called again on language changes
    applyIgMenuI18n();

    // Prevent arrow or WASD keys from focusing in‑game buttons and causing a focus outline.
    // When a navigation key is pressed while a bottom menu button has focus, we blur the button
    // so that the browser does not draw a white outline. We do not prevent the default action
    // to ensure that the keys still control the player.
    try {
      document.addEventListener('keydown', function(e){
        try {
          var k = e.key ? e.key.toLowerCase() : '';
          if (k === 'arrowup' || k === 'arrowdown' || k === 'arrowleft' || k === 'arrowright' || k === 'w' || k === 'a' || k === 's' || k === 'd') {
            var ae = document.activeElement;
            if (ae && ae.classList && ae.classList.contains('ig-btn')) {
              ae.blur();
            }
          }
        } catch(_) { }
      }, true);
    } catch(_){ }
    if (typeof window.updateUITexts === 'function'){
      try{
        var __prev = window.updateUITexts;
        window.updateUITexts = function(){ try{ __prev.apply(this, arguments); }catch(_){ } applyIgMenuI18n(); };
      }catch(_){}
    }

    // ---------- Sync toggles
    function syncAutoBtn(){
      try {
        var enabled = false;
        try { enabled = !!window.AUTO_FIRE_ENABLED || !!(typeof AUTO_FIRE_ENABLED!=='undefined' && AUTO_FIRE_ENABLED); } catch(_){}
        if (!enabled) {
          var lbl = $('autoFireLabel');
          enabled = !!(lbl && /on/i.test(String(lbl.textContent||'')));
        }
        setActive(btnAuto, enabled);
      } catch(_){}
    }
    function syncShopBtn(){ try { setActive(btnShop, upgradesOpen()); } catch(_){} }

    // ---------- In-game visibility
    function showInGameUI(){
      try {
        if (menu) menu.style.display = 'flex';
        // Place the chat panel into floating mode and hide it by default
        var c = document.getElementById('chatPanel');
        if (c){ c.classList.add('ig-floating'); c.style.display='none'; }
        // Automatically show the stats bubble and mark its button as active when entering the game
        if (typeof hudStats !== 'undefined' && hudStats){
          hudStats.style.display = 'block';
          try { setActive(btnStats, true); } catch(_){}
        }
      } catch(_){ }
    }
    function hideInGameUI(){
      try {
        hide(hudStats); setActive(btnStats,false);
        hide(buildPanel); setActive(btnBuild,false);
        setActive(btnChat,false);
        var c=document.getElementById('chatPanel'); if (c){ c.classList.remove('ig-floating'); c.style.display='flex'; }
        closeUpgrades();
        if (menu) menu.style.display='none';
        var tip = $('buildTooltip'); if (tip) tip.style.display='none';
      } catch(_){ }
    }

    try {
      if (window.socket && socket.on) {
        socket.on('gameStarted', function(){ showInGameUI(); });
        socket.on('lobbyUpdate', function(data){ try { if (!data || !data.started) hideInGameUI(); } catch(_){ } });
      }
    } catch(_){}

    try {
      var lobby = $('lobbyScreen');
      if (lobby && window.MutationObserver) {
        var obs = new MutationObserver(function(){
          var inLobby = (lobby.style.display !== 'none');
          if (inLobby) hideInGameUI(); else showInGameUI();
        });
        obs.observe(lobby, { attributes:true, attributeFilter:['style','class'] });
      }
    } catch(_){}

    try { var lobby = $('lobbyScreen'); if (!lobby || lobby.style.display === 'none') showInGameUI(); } catch(_){}

    setInterval(function(){ syncAutoBtn(); syncShopBtn(); }, 500);

  }catch(e){ console.error('[igMenuPatch] init failed', e); }
})();
</script>


<script id="build-tooltip-guard">
(function(){
  try{
    function getBox(){
      try{ if (window.getBuildTooltipBox) return window.getBuildTooltipBox(); }catch(_){}
      return document.getElementById('buildTooltipStable') || document.getElementById('buildTooltip');
    }
    function hideTooltip(){
      try{
        var b = getBox();
        if (b) b.style.display = 'none';
      }catch(_){}
    }
    function isOverTile(target){
      try{
        if (!target) return false;
        if (target.closest && target.closest('.build-tile')) return true;
      }catch(_){}
      return false;
    }

    // Hide when moving and not over any tile
    document.addEventListener('pointermove', function(ev){
      try{
        if (!isOverTile(ev.target)) hideTooltip();
      }catch(_){}
    }, {passive:true});

    // Hide on leave of containers
    function bindContainer(id){
      var c = document.getElementById(id);
      if (!c) return;
      var fn = function(){ hideTooltip(); };
      c.addEventListener('pointerleave', fn, {passive:true});
      c.addEventListener('mouseleave', fn, {passive:true});
      c.addEventListener('pointerout', function(ev){
        try{
          var rel = ev.relatedTarget;
          // When pointer moves to an element outside this container, hide
          if (!rel || !c.contains(rel)) hideTooltip();
        }catch(_){ hideTooltip(); }
      }, {passive:true});
    }
    function bind(){
      ['buildTiles','igBuildTiles'].forEach(bindContainer);
    }
    bind();

    // Observe DOM to (re)bind when containers appear later
    if (window.MutationObserver){
      var mo = new MutationObserver(function(){ bind(); });
      mo.observe(document.documentElement || document.body, {childList:true, subtree:true});
    }

    // Hide when page loses focus or becomes hidden
    window.addEventListener('blur', hideTooltip);
    document.addEventListener('visibilitychange', function(){ if (document.hidden) hideTooltip(); });

    // Safety: hide when scrolling and nothing hovered
    window.addEventListener('scroll', function(){
      try{
        var b = getBox();
        if (!b || b.style.display === 'none') return;
        if (!document.querySelector('.build-tile:hover')) hideTooltip();
      }catch(_){}
    }, {passive:true});
  } catch(e){
    try{ console.warn('[build-tooltip-guard] failed', e); }catch(__){}
  }
})();
</script>


