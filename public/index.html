<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Zombination.io</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #222; color: white; font-family: Arial, sans-serif; }
    #gameCanvas {
  display: block;
  background: #222;
  position: absolute;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  touch-action: none;
}

	.joystick-base, .joystick-stick { touch-action: none; }
	html, body { overscroll-behavior: none; }
    #hudStats { position: fixed; left: 10px; bottom: 10px; background: rgba(0,0,0,0.7); border-radius: 7px; padding: 10px 20px 10px 15px; font-size: 18px; user-select: none; min-width: 210px; }
    #hudAlive { font-weight: bold; color: #fd7; }
    #deathScreen { display: none; position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; background: rgba(30,0,0,0.8); z-index: 3; justify-content: center; align-items: center; flex-direction: column; }
    #deathScreenInner { background: #181818; border-radius: 20px; padding: 35px 45px; color: #fff; box-shadow: 0 6px 30px #000c; text-align: center; min-width: 320px; }
    #deathScreen h2 { margin: 0 0 15px 0; color: #fc2c3c; }
    #deathStats { margin-bottom: 15px; font-size: 20px; }
    #btnReplay { background: #222; color: #fff; padding: 10px 32px; border: none; border-radius: 10px; font-size: 20px; cursor: pointer; transition: background 0.16s; }
    #btnReplay:hover { background: #393; color: #fff; }
    /* --- LOBBY --- */
    #lobbyScreen { display: flex; flex-direction: column; align-items: center; justify-content: center; position: fixed; left:0;top:0;width:100vw;height:100vh;z-index:10; background: #181c; }
    #lobbyBox { background: #19191e; border-radius: 20px; padding: 36px 42px; box-shadow: 0 6px 30px #000c; min-width: 350px; min-height: 190px; text-align: center; }
    #lobbyBox input[type=text] { font-size: 20px; padding: 7px 12px; border-radius: 7px; border: 1px solid #444; outline: none; margin-bottom: 10px; width: 175px; }
    #lobbyJoin { padding: 7px 32px; border-radius: 8px; border:none; font-size: 20px; background:#49c749; color: #fff; cursor: pointer; margin-top: 7px; }
    #lobbyJoin[disabled] { opacity: 0.6; cursor: not-allowed; }
    #lobbyPlayers { margin: 18px 0 12px 0; color: #9fd; }
    #lobbyTimer { font-size: 17px; margin-bottom: 9px; }
    #lobbyStatus { margin: 4px 0 0 0; color: #ccc; font-size: 14px; }

    /* --- LANG SELECT --- */
    #langSelectRow {
      margin-top: 18px;
      display: flex;
      justify-content: center;
      gap: 13px;
      user-select: none;
    }
    .langFlag {
      width: 38px;
      height: 26px;
      border-radius: 6px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: border 0.14s, transform 0.12s;
      background: #fff2;
      object-fit: cover;
      box-shadow: 0 2px 10px #0003;
    }
    .langFlag.selected {
      border: 2.5px solid #33fc69;
      transform: scale(1.07);
      box-shadow: 0 2px 16px #33fc6930;
    }

    /* --- WAVE MESSAGE --- */
    #waveMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #f2f263;
      font-size: 48px;
      font-weight: bold;
      text-shadow: 2px 2px 6px #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease-in-out;
      z-index: 20;
      user-select: none;
    }
    /* Version */
    #versionBox {
      position: fixed;
      right: 20px;
      bottom: 14px;
      color: #ccc;
      font-size: 14px;
      opacity: 0.8;
      z-index: 20;
      user-select: none;
    }
    /* Ajout des joysticks mobile */
	.joystick-container {
	  position: fixed;
	  z-index: 10000;
	  touch-action: none;
	  pointer-events: auto; /* <-- IMPORTANT : le conteneur doit capter les events */
	}
    .joystick-base, .joystick-stick {
      pointer-events: auto;
      user-select: none;
    }
	#shopModal {
	  animation: shopPopIn 0.22s;
	  backdrop-filter: blur(0.5px);
	  -webkit-overflow-scrolling: touch; /* ‚Üê Ajout ici */
	}
	#shopModal { z-index: 10010 !important; }
	#shopModal:focus-within { outline: 2px solid #4dfc82; }
	#shopModal::-webkit-scrollbar { width: 6px; }
	#shopModal::-webkit-scrollbar-thumb { background: #2a5; border-radius: 4px; }

	/* √âtape 1 ‚Äî structure interne du panneau (scroll propre) */
	#shopModal {
	  display: flex;
	  flex-direction: column;
	}

	#shopUpgrades {
	  overflow-y: auto;
	  /* prend toute la hauteur restante du panneau */
	  max-height: 100%;
	}


		
@media (hover: none) and (pointer: coarse) {
  /* Contraintes + anim sp√©cifiques mobile */
  #shopModal {
    box-sizing: border-box;

    /* dimensions qui tiennent toujours dans l'√©cran */
    width: auto;
    max-width: min(92vw, 420px) !important;
    max-height: calc(100dvh - 24px) !important;

    overflow-y: auto;
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;

    /* apparition mobile + easing voulu */
    transform: scale(0.5);
    transform-origin: bottom right;
    animation: shopPopInMobile 0.22s ease-out;
  }

  /* Le bouton doit passer sous le panneau */
  #shopBtn { z-index: 10005 !important; }
}



@keyframes shopPopInMobile {
  0%   { opacity: 0; transform: translateY(80px) scale(0.5); }
  100% { opacity: 1; transform: scale(0.5); }
}




	@keyframes shopPopIn {
	  0% { opacity: 0; transform: translateY(80px) scale(0.97);}
	  100% { opacity: 1; transform: none; }
	}
	#shopClose:hover { color: #ff6464; transform: scale(1.13); }
	.bought-flash {
	  animation: flashBtn 0.22s;
	}
	@keyframes flashBtn {
	  0% { box-shadow: 0 0 0px #67fa62, 0 0 0px #fff; background: #34c24c;}
	  55% { box-shadow: 0 0 11px #67fa62, 0 0 22px #fff9;}
	  100% { box-shadow: 0 0 0px #67fa62, 0 0 0px #fff; }
	}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="hudStats">
    <div id="hudAlive"></div>
	<div id="hudMoney"></div>
    <div id="hudZombies"></div>
    <div id="hudKills"></div>
    <div id="hudRound"></div>
    <div id="hudHP"></div>
  </div>

  <div id="deathScreen">
    <div id="deathScreenInner">
      <h2 id="deathTitle"></h2>
      <div id="deathStats"></div>
      <button id="btnReplay"></button>
    </div>
  </div>
  <div id="lobbyScreen">
    <div id="lobbyBox">
      <div id="lobbyTitle" style="font-size: 28px; margin-bottom: 18px;"><b>Zombination.io</b></div>
      <div id="lobbyPlayers"></div>
      <div id="lobbyTimer"></div>
      <div id="lobbyStatus"></div>
      <input type="text" id="pseudoInput" maxlength="15" placeholder="" />
      <br>
      <button id="lobbyJoin"></button>
      <div id="langSelectRow"></div>
    </div>
  </div>
	 <button id="shopBtn" title="Boutique" style="display: flex; align-items: center; position: fixed; right: 20px; bottom: 52px; z-index: 21; background: #232; color: #fff; border-radius: 13px; border: none; font-size: 22px; padding: 10px 26px 10px 19px; box-shadow: 0 2px 14px #0006; cursor: pointer; gap: 13px; transition: background 0.17s;">
	  <img src="/icons/cart.svg" alt="Shop" style="width: 27px; height: 27px; margin-right: 8px; filter: brightness(1.25) drop-shadow(0 2px 5px #0006);" />
	  SHOP
	</button>
	
	
	

<!-- ==== BARRE D'ACHATS STRUCTURES (au-dessus du SHOP) ==== -->
<div id="buildBar" style="position:fixed; right:20px; bottom:122px; z-index:10006; display:flex; gap:10px; flex-direction:column; align-items:flex-end;">
  <!-- Conteneur horizontal des 4 tuiles -->
  <div id="buildTiles" style="display:flex; gap:10px;">
    <!-- Grande tourelle (avec petit canon) -->
    <button class="build-tile" data-type="T" data-tip="Tourelle (HP: 500, D√©g√¢ts: 5, Cadence: ~6.7/s)" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
      <div style="width:42px;height:42px;background:#d33;border:2px solid #3a0b0b;box-shadow:0 2px 8px #0007; position:relative;">
        <!-- petit canon -->
        <div style="position:absolute; left:50%; top:50%; width:16px; height:3px; background:#3a0b0b; transform:translate(0,-50%); border-radius:2px;"></div>
      </div>
      <div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$1000</div>
    </button>

    <!-- Mini-tourelle (avec petit canon) -->
    <button class="build-tile" data-type="t" data-tip="Mini-tourelle (HP: 200, D√©g√¢ts: 5, Cadence: 1/s)" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
      <div style="width:42px;height:42px;background:#3aa6ff;border:2px solid #0b1b2a;box-shadow:0 2px 8px #0007; position:relative;">
        <!-- petit canon -->
        <div style="position:absolute; left:50%; top:50%; width:14px; height:3px; background:#0b1b2a; transform:translate(0,-50%); border-radius:2px;"></div>
      </div>
      <div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$250</div>
    </button>

    <!-- Mur (barricade) -->
    <button class="build-tile" data-type="B" data-tip="Mur (HP: 200)" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
      <div style="width:42px;height:42px;background:#7b4b2a;border:2px solid #000;box-shadow:0 2px 8px #0007;"></div>
      <div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$100</div>
    </button>

    <!-- Porte -->
    <button class="build-tile" data-type="D" data-tip="Porte (HP: 200)" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
      <div style="width:42px;height:42px;background:#a57b4a;border:2px solid #000;box-shadow:0 2px 8px #0007;"></div>
      <div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$200</div>
    </button>
  </div>

  <!-- Tooltip hover -->
  <div id="buildTooltip" style="display:none; position:absolute; right:0; bottom:70px; max-width:260px; background:#111c; color:#fff; font-size:13px; padding:8px 10px; border-radius:8px; box-shadow:0 4px 18px #000a; pointer-events:none; white-space:nowrap;"></div>
</div>


	
	
	<div id="shopModal" style="display:none; position:fixed; right:34px; bottom:90px; background:#181e19ee; border-radius:18px; box-shadow:0 8px 28px #000c; min-width:340px; min-height:280px; padding:32px 26px 22px 26px;">
	  <button id="shopClose" style="position:absolute; right:17px; top:10px; background:none; border:none; color:#fff; font-size:26px; cursor:pointer; filter:drop-shadow(0 2px 6px #0009);">‚úï</button>
	  <div style="font-size:26px; margin-bottom:15px; display:flex; align-items:center; gap:10px;">
		<img src="/icons/cart.svg" alt="Shop" style="width:30px; filter:brightness(1.2); vertical-align:middle;">
		<span>SHOP</span>
	  </div>
	  <div id="shopUpgrades">
		<!-- Ici viendront les lignes d‚Äôam√©liorations √† l‚Äô√©tape suivante -->
		<div style="color:#fff6; font-size:17px; margin-top:18px;">Boutique √† venir¬†: <i>Affichage des am√©liorations ici √† l‚Äô√©tape 3</i></div>
	  </div>
	</div>
  <div id="versionBox">Version 1.0.0 par Myg</div>
  <div id="waveMessage"></div>
  <script src="/translations.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  
  
    <!-- === Mobile Build Buttons === -->
<div id="mobile-build" class="mobile-build">
  <button class="mb-btn" data-type="B" aria-label="Construire Mur (B)">Mur</button>
  <button class="mb-btn" data-type="D" aria-label="Construire Porte (D)">Porte</button>
  <button class="mb-btn" data-type="t" aria-label="Construire Mini-Tourelle (t)">Mini-T</button>
  <button class="mb-btn" data-type="T" aria-label="Construire Grande Tourelle (T)">Tourelle</button>
</div>

<style>
  /* Mobile only */
  
	 @media (max-width: 768px) and (orientation: portrait) {
	  .mobile-build { 
		display: none !important; 
	  }
	}
  @media (max-width: 768px) {
	.mobile-build {
	  position: fixed;
	  left: 50%;
	  bottom: calc(env(safe-area-inset-bottom, 0px) + 96px); /* marge iOS + au-dessus du Shop */
	  transform: translateX(-50%);
	  display: grid;
	  grid-template-columns: repeat(4, auto);
	  gap: 10px;
	  padding: 10px 12px;
	  background: rgba(0,0,0,0.35);
	  backdrop-filter: blur(6px);
	  border-radius: 14px;
	  z-index: 10007; /* sup√©rieur au Shop */
	  user-select: none;
	}
 .mb-btn {
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      background: #222;
      color: #fff;
    }
    .mobile-build .mb-btn:active {
      transform: translateY(1px);
    }
  }

  /* Desktop: hide */
  @media (min-width: 769px) {
    .mobile-build { display: none; }
  }
</style>
<!-- === /Mobile Build Buttons === -->
  
  
  
  <script>
  



  window.addEventListener('contextmenu', e => e.preventDefault(), { passive: false });
    // --- LANG/LOBBY ---
    const LANGS = [
      { code: 'en', flag: 'gb.png', label: 'English' },
      { code: 'cn', flag: 'cn.png', label: '‰∏≠Êñá' },
      { code: 'ru', flag: 'ru.png', label: '–†—É—Å—Å–∫–∏–π' },
      { code: 'es', flag: 'es.png', label: 'Espa√±ol' },
      { code: 'pt', flag: 'pt.png', label: 'Portugu√™s' },
      { code: 'de', flag: 'de.png', label: 'Deutsch' },
      { code: 'jp', flag: 'jp.png', label: 'Êó•Êú¨Ë™û' },
      { code: 'fr', flag: 'fr.png', label: 'Fran√ßais' },
      { code: 'pl', flag: 'pl.png', label: 'Polski' },
      { code: 'kr', flag: 'kr.png', label: 'ÌïúÍµ≠Ïñ¥' }
    ];
    function getDefaultLang() { return "en"; }
    let currentLang = getDefaultLang();
    let lobbyData = { started: false, count: 0, max: 10, timeLeft: 30, players: {} };
    let lobbyJoined = false, lobbyStarted = false;
    function initLobbyTexts() {
      updateLobbyTexts();
      pseudoInput.placeholder = TRANSLATIONS[currentLang].enterPseudo;
      lobbyJoin.textContent = TRANSLATIONS[currentLang].join;
    }
    function updateLobbyTexts() {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      lobbyPlayers.textContent = `${tr.playersInGame} : ${lobbyData.count}/${lobbyData.max}`;
      lobbyTimer.textContent = `${tr.timeLeft} : ${lobbyData.timeLeft}s`;
      const readyCount = Object.values(lobbyData.players).filter(p=>p.ready).length;
      lobbyStatus.textContent = `${tr.waitingStart} (${readyCount} ${tr.playersReady}${readyCount>1?'s':''})`;
    }
    function updateUITexts() {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      document.getElementById('lobbyTitle').innerHTML = `<b>${tr.zombination}</b>`;
      pseudoInput.placeholder = tr.enterPseudo;
      lobbyJoin.textContent = lobbyJoined ? tr.waiting : tr.join;
      document.getElementById('deathTitle').textContent = tr.youDied;
      btnReplay.textContent = tr.replay;
      if (!lobbyStarted) { updateLobbyTexts(); }
    }
    const langSelectRow = document.getElementById('langSelectRow');
    function renderLangFlags() {
      langSelectRow.innerHTML = '';
      LANGS.forEach(lang => {
        const img = document.createElement('img');
        img.src = `/flags/${lang.flag}`;
        img.alt = lang.label;
        img.title = lang.label;
        img.className = 'langFlag' + (lang.code === currentLang ? ' selected' : '');
        img.onclick = () => {
          if (currentLang !== lang.code) {
            currentLang = lang.code;
            renderLangFlags(); updateUITexts(); drawHUD();
          }
        };
        langSelectRow.appendChild(img);
      });
    }
    const pseudoInput = document.getElementById('pseudoInput');
	pseudoInput.addEventListener('input', function() {
	  this.value = this.value.replace(/[^a-zA-Z0-9]/g, '');
	});

    const lobbyJoin = document.getElementById('lobbyJoin');
    const lobbyPlayers = document.getElementById('lobbyPlayers');
    const lobbyTimer = document.getElementById('lobbyTimer');
    const lobbyStatus = document.getElementById('lobbyStatus');
    const deathTitle = document.getElementById('deathTitle');
    const deathStats = document.getElementById('deathStats');
    const btnReplay = document.getElementById('btnReplay');
	const deathScreen = document.getElementById('deathScreen');
    renderLangFlags(); initLobbyTexts();

    // --- JEU ---
    const socket = io();
	setInterval(() => {
	  if (socket && socket.connected) {
		socket.emit('clientPing');
	  }
	}, 10000);
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const hudAlive = document.getElementById('hudAlive');
    const hudZombies = document.getElementById('hudZombies');
    const hudKills = document.getElementById('hudKills');
    const hudRound = document.getElementById('hudRound');
    const hudHP = document.getElementById('hudHP');
	const hudMoney = document.getElementById('hudMoney');
	let myMoney = 0;
	

const UPGRADES = [
  {
    id: "maxHp",
    label: "+10% Vie max",
    desc: "Augmente les PV max.",
    icon: "/icons/heart.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 100,
    statLabel: "PV max",
    format: v => v + " PV"
  },
  {
    id: "speed",
    label: "+10% Vitesse",
    desc: "D√©place-toi plus vite.",
    icon: "/icons/speed.svg",
    getValue: (base, level) => +(base * Math.pow(1.1, level)).toFixed(1),
    baseValue: 50,
    statLabel: "Vitesse",
    format: v => v + " px/s"
  },
  {
    id: "regen",
    label: "R√©g√©n√©ration PV",
    desc: "Reg√©n√®re tes PV.",
    icon: "/icons/regen.svg",
    getValue: (base, level) => {
      if (level <= 10) return level;                 // 0..10 lin√©aire
      return +(10 * Math.pow(1.1, level - 10)).toFixed(2); // >10 : +10%/niv
    },
    baseValue: 0,
    statLabel: "R√©g√©n.",
    format: v => v + " PV/s"
  },
  {
    id: "damage",
    label: "+10% D√©g√¢ts",
    desc: "Tire plus fort.",
    icon: "/icons/bullet.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 5,
    statLabel: "D√©g√¢ts",
    format: v => v
  },
  {
    id: "goldGain",
    label: "+10% d'or gagn√©",
    desc: "Gagne plus d‚Äôor sur les zombies.",
    icon: "/icons/gold.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 10, // goldGain commence √† 10 c√¥t√© serveur
    statLabel: "$/zombie",
    format: (v) => {
      const min = Math.round(10 * (v / 10));
      const max = Math.round(20 * (v / 10));
      return `$${min}‚Äì${max}`;
    }
  }
];


	// Niveau des upgrades du joueur local (simul√© pour l‚Äôinstant)
	let myUpgrades = {
	  maxHp: 0,
	  speed: 0,
	  regen: 0,
	  damage: 0,
	  goldGain: 0
	};

    const waveMessage = document.getElementById('waveMessage');
    let currentRound = 1, playersHealth = {}, zombies = {}, bullets = {};
// --- Interpolation helpers (client smoothing) ---
const SMOOTH_MS_ZB = 80;   // zombies/bullets ~80ms
const SMOOTH_MS_P   = 220; // autres joueurs ~140ms

function lerp(a, b, t) { return a + (b - a) * t; }
function clamp01(v) { return Math.max(0, Math.min(1, v)); }

// pr√©pare (si absent) le state d'interpolation
function ensureSmoothState(obj, now) {
  if (!obj) return;
  if (obj.t0 == null) {
    obj.sx = obj.x; obj.sy = obj.y;
    obj.tx = obj.x; obj.ty = obj.y;
    obj.t0 = now;   obj.td = 1;
  }
}

// enregistre une nouvelle cible d'interpolation
function setSmoothTarget(obj, nx, ny, durMs, now) {
  ensureSmoothState(obj, now);
  // point de d√©part = derni√®re position rendue si connue
  const rx = (obj.renderX != null) ? obj.renderX : obj.x;
  const ry = (obj.renderY != null) ? obj.renderY : obj.y;
  obj.sx = rx; obj.sy = ry;
  obj.tx = nx; obj.ty = ny;
  obj.t0 = now; obj.td = Math.max(1, durMs);
}


function getSmoothPos(obj, now) {
  ensureSmoothState(obj, now);
  const t = clamp01((now - obj.t0) / obj.td);
  const rx = lerp(obj.sx, obj.tx, t);
  const ry = lerp(obj.sy, obj.ty, t);
  obj.renderX = rx; obj.renderY = ry;
  // r√©utilise un unique objet partag√© (√©vite une alloc par appel)
  _TMP_POS.x = rx;
  _TMP_POS.y = ry;
  return _TMP_POS;
}





    let myId = null, playerHealth = 100, isDead = false, myKills = 0, myPseudo = "";
	let shootBlocked = false;
	let moneyFloatingTexts = []; // Pour stocker les "+$" √† afficher
	let buildMode = null;         // 'T' | 't' | 'B' | 'D' | null
	let buildHover = { tx: -1, ty: -1 }; // tuile survol√©e pendant le placement

	function curve(v) {
	  // 0.55 = plus sensible au centre (augmente si tu trouves encore trop mou)
	  const e = 0.55;
	  const s = Math.sign(v);
	  return s * Math.pow(Math.abs(v), e);
	}

    // D√©tection mobile
    function isMobile() { return /android|iphone|ipad|ipod|opera mini|iemobile|mobile/i.test(navigator.userAgent); }
    const isMobileDevice = isMobile();
	const HAS_POINTER = ('PointerEvent' in window);


	// === [ZOOM MOBILE PAYSAGE] ===
	let renderScale = 1;
	function updateRenderScale() {
	  if (!isMobileDevice) {
		renderScale = 1;
		return;
	  }
	  const isLandscape = window.matchMedia('(orientation: landscape)').matches;
	  // x2 en paysage => 0.5 ; x3 en portrait => ~0.333
	  renderScale = isLandscape ? 0.5 : 1/3;
	}


	updateRenderScale();
    const TILE_SIZE = 40;
    const PLAYER_RADIUS = 10;
    const ZOMBIE_RADIUS = 10;
	
// Caches de paths (dessin sans recalculer l'arc √† chaque fois)
const PLAYER_CIRCLE = new Path2D();
PLAYER_CIRCLE.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);

const ZOMBIE_CIRCLE = new Path2D();
ZOMBIE_CIRCLE.arc(0, 0, ZOMBIE_RADIUS, 0, Math.PI * 2);

// Temp object pour √©viter d'allocer {x,y} √† chaque getSmoothPos()
const _TMP_POS = { x: 0, y: 0 };

	
	
    let map = [], MAP_ROWS = 0, MAP_COLS = 0;
	let structures = null;

// === Helpers map/structures (client) ===
function worldToTile(x, y) {
  return { tx: Math.floor(x / TILE_SIZE), ty: Math.floor(y / TILE_SIZE) };
}
function isWallAt(tx, ty) {
  if (!map || ty < 0 || ty >= MAP_ROWS || tx < 0 || tx >= MAP_COLS) return true;
  return map[ty][tx] === 1;
}
function structAtWorld(x, y) {
  if (!structures) return null;
  const { tx, ty } = worldToTile(x, y);
  if (ty < 0 || ty >= MAP_ROWS || tx < 0 || tx >= MAP_COLS) return null;
  return structures[ty]?.[tx] || null;
}
function isSolidForZombieClient(struct) {
  // pour la ligne de vue c√¥t√© client : tout ce qui a des PV bloque
  return struct && struct.hp > 0; // B, D, T‚Ä¶
}
function losBlockedForZombieClient(x0, y0, x1, y1) {
  const dx = x1 - x0, dy = y1 - y0;
  const dist = Math.hypot(dx, dy);
  if (dist < 1) return false;
  const steps = Math.ceil(dist / 8);
  for (let s = 1; s < steps; s++) {
    const ix = x0 + (dx * s / steps);
    const iy = y0 + (dy * s / steps);
    const { tx, ty } = worldToTile(ix, iy);
    if (isWallAt(tx, ty)) return true;
    const st = structures?.[ty]?.[tx];
    if (isSolidForZombieClient(st)) return true;
  }
  return false;
}




function findTurretTargetAngle(cxWorld, cyWorld) {
  let best = null, bestDist = Infinity, bdx = 1, bdy = 0;
  for (const z of Object.values(zombies)) {
    const dx = z.x - cxWorld;
    const dy = z.y - cyWorld;
    const d = Math.hypot(dx, dy);
    if (d < bestDist && !losBlockedForZombieClient(cxWorld, cyWorld, z.x, z.y)) {
      best = z; bestDist = d; bdx = dx; bdy = dy;
    }
  }
  return Math.atan2(bdy, bdx); // d√©faut: 0 rad (vers la droite)
}


    let cameraX = 0, cameraY = 0;
    const keys = {};
    let mouseDown = false, mousePos = { x: 0, y: 0 };
    let aimDir = { x: 1, y: 0 }; // direction de vis√©e par d√©faut (droite)
	let lastAimDir = { x: 1, y: 0 };
	
	window.addEventListener('keydown', e => {
	  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
		e.preventDefault(); // √©vite le scroll de la page !
	  }
	  keys[e.key.toLowerCase()] = true;
	});
	window.addEventListener('keyup', e => {
	  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
		e.preventDefault();
	  }
	  keys[e.key.toLowerCase()] = false;
	});
	
window.addEventListener('mousedown', e => {
  if (buildMode) { e.preventDefault(); return; }   // ‚Üê ajoute √ßa
  const sm = document.getElementById('shopModal');
  if (sm && sm.style.display === 'block') return;
  mouseDown = e.button === 0;
});


    window.addEventListener('mouseup', e => { if (e.button === 0) mouseDown = false; });
    window.addEventListener('mousemove', e => {
  mousePos = { x: e.clientX, y: e.clientY };
  if (!isMobileDevice && myId && playersHealth[myId]) {
    const p = playersHealth[myId];
    const px = (p.renderX != null ? p.renderX : p.x);
    const py = (p.renderY != null ? p.renderY : p.y);

    aimDir = {
      x: (cameraX + mousePos.x / renderScale) - px,
      y: (cameraY + mousePos.y / renderScale) - py
    };
    let len = Math.hypot(aimDir.x, aimDir.y);
    if (len > 0) {
      aimDir.x /= len;
      aimDir.y /= len;
    }
  }

    });
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // JOYSTICK PATCH MOBILE
    let moveJoy = null, aimJoy = null;
	let moveJoyVal = {x:0, y:0}, aimJoyVal = {x:0, y:0}; // valeurs normalis√©es [-1..1]
	
function createJoystick(container, baseX, baseY, id) {
  const size = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.23);
  const joyDiv = document.createElement('div');
  joyDiv.className = 'joystick-container';
  joyDiv.style.left = baseX + 'px';
  joyDiv.style.top = baseY + 'px';
  joyDiv.style.width = size + 'px';
  joyDiv.style.height = size + 'px';
  joyDiv.id = id;
  joyDiv.style.pointerEvents = 'auto';
  document.body.appendChild(joyDiv);

  const base = document.createElement('div');
  base.className = 'joystick-base';
  base.style.width = size + 'px';
  base.style.height = size + 'px';
  base.style.background = 'rgba(255,255,255,0.12)';
  base.style.borderRadius = '50%';
  base.style.position = 'absolute';
  base.style.left = '0px';
  base.style.top = '0px';
  base.style.pointerEvents = 'auto';
  joyDiv.appendChild(base);

  const stick = document.createElement('div');
  stick.className = 'joystick-stick';
  stick.style.width = (size * 0.52) + 'px';
  stick.style.height = (size * 0.52) + 'px';
  stick.style.background = 'rgba(160,255,240,0.45)';
  stick.style.borderRadius = '50%';
  stick.style.position = 'absolute';
  stick.style.left = (size * 0.24) + 'px';
  stick.style.top = (size * 0.24) + 'px';
  stick.style.pointerEvents = 'auto';
  joyDiv.appendChild(stick);

  return { joyDiv, base, stick, size };
}


function addJoystickHandlers(joy, which) {
  const size = joy.size;
  const radius = size / 2;
  const stickRadius = (size * 0.52) / 2;
  const center = { x: radius, y: radius };

  // pointeur actif POUR CE JOYSTICK UNIQUEMENT
  joy._pid = null;

  function setVec(dx, dy) {
    const max = radius - stickRadius;
    const len = Math.hypot(dx, dy);
    let nx = dx, ny = dy;
    if (len > max && len > 0) {
      nx = dx * (max / len);
      ny = dy * (max / len);
    }

    // rendu visuel
    joy.stick.style.left = (center.x - stickRadius + nx) + "px";
    joy.stick.style.top  = (center.y - stickRadius + ny) + "px";

    // vecteur normalis√© [-1..1] vers les valeurs globales
    const out = (max > 0) ? { x: nx / max, y: ny / max } : { x: 0, y: 0 };
    if (which === "move") moveJoyVal = out;
    else aimJoyVal = out;
  }

  function onPointerDown(e) {
    // ce joystick peut √™tre pris m√™me si l‚Äôautre l‚Äôest d√©j√†
    if (joy._pid !== null) return; // d√©j√† actif
    joy._pid = e.pointerId;
    try { joy.joyDiv.setPointerCapture(joy._pid); } catch {}

    const r = joy.joyDiv.getBoundingClientRect();
    const px = e.clientX - r.left;
    const py = e.clientY - r.top;
    setVec(px - center.x, py - center.y);
    e.preventDefault();
  }

  function onPointerMove(e) {
    if (e.pointerId !== joy._pid) return;
    const r = joy.joyDiv.getBoundingClientRect();
    const px = e.clientX - r.left;
    const py = e.clientY - r.top;
    setVec(px - center.x, py - center.y);
    e.preventDefault();
  }

  function onPointerUp(e) {
    if (e.pointerId !== joy._pid) return;
    try { joy.joyDiv.releasePointerCapture(joy._pid); } catch {}
    joy._pid = null;
    setVec(0, 0);
    e.preventDefault();
  }

  // down sur toute la zone du joystick
  joy.joyDiv.addEventListener('pointerdown', onPointerDown, { passive: false });
  joy.base.addEventListener('pointerdown', onPointerDown, { passive: false });
  joy.stick.addEventListener('pointerdown', onPointerDown, { passive: false });

  // listeners globaux (fonctionnent en parall√®le pour les 2 joysticks)
  window.addEventListener('pointermove', onPointerMove, { passive: false });
  window.addEventListener('pointerup', onPointerUp, { passive: false });
  window.addEventListener('pointercancel', onPointerUp, { passive: false });

  // position neutre par d√©faut
  setVec(0, 0);
}




	function addJoystickTouchHandlers(joy, which) {
	  const size = joy.size;
	  const radius = size / 2;
	  const stickRadius = (size * 0.52) / 2;
	  const center = { x: radius, y: radius };

	  let active = false;
	  let lastId = null;

	  function setVec(dx, dy) {
		const max = radius - stickRadius;
		const len = Math.hypot(dx, dy);
		let nx = dx, ny = dy;
		if (len > max && len > 0) {
		  nx = dx * (max / len);
		  ny = dy * (max / len);
		}
		joy.stick.style.left = (center.x - stickRadius + nx) + "px";
		joy.stick.style.top  = (center.y - stickRadius + ny) + "px";
		const out = (max > 0) ? { x: nx / max, y: ny / max } : { x: 0, y: 0 };
		if (which === "move") moveJoyVal = out;
		else aimJoyVal = out;
	  }

	  function reset() {
		active = false;
		lastId = null;
		setVec(0, 0);
	  }

	  function localCoords(clientX, clientY) {
		const r = joy.joyDiv.getBoundingClientRect();
		return { x: clientX - r.left, y: clientY - r.top };
	  }

	  function onStart(e) {
		if (active) return;
		const t = e.changedTouches ? e.changedTouches[0] : null;
		if (!t) return;
		active = true;
		lastId = t.identifier;
		const p = localCoords(t.clientX, t.clientY);
		setVec(p.x - center.x, p.y - center.y);
		e.preventDefault();
	  }

	  function onMove(e) {
		if (!active) return;
		const touches = e.changedTouches;
		for (let i = 0; i < touches.length; i++) {
		  const t = touches[i];
		  if (t.identifier !== lastId) continue;
		  const p = localCoords(t.clientX, t.clientY);
		  setVec(p.x - center.x, p.y - center.y);
		  e.preventDefault();
		  break;
		}
	  }

	  function onEnd(e) {
		if (!active) return;
		const touches = e.changedTouches;
		for (let i = 0; i < touches.length; i++) {
		  const t = touches[i];
		  if (t.identifier !== lastId) continue;
		  reset();
		  e.preventDefault();
		  break;
		}
	  }

	  // down sur toute la zone
	  joy.joyDiv.addEventListener('touchstart', onStart, { passive: false });
	  joy.base.addEventListener('touchstart', onStart, { passive: false });
	  joy.stick.addEventListener('touchstart', onStart, { passive: false });

	  // move/up globaux
	  window.addEventListener('touchmove', onMove, { passive: false });
	  window.addEventListener('touchend', onEnd, { passive: false });
	  window.addEventListener('touchcancel', onEnd, { passive: false });

	  reset();
	}




function setupJoysticks() {
  if (!isMobileDevice) return;

  // Nettoyage
  if (moveJoy && moveJoy.joyDiv) moveJoy.joyDiv.remove();
  if (aimJoy && aimJoy.joyDiv) aimJoy.joyDiv.remove();

  const padding = 36;
  const joySize = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.23);
  let joyY = window.innerHeight - joySize - padding;
  if (joyY < padding) joyY = padding;

  // Cr√©e les deux joysticks
  moveJoy = createJoystick(document.body, padding, joyY, "moveJoy");
  aimJoy  = createJoystick(document.body, window.innerWidth - joySize - padding, joyY, "aimJoy");

  // üëâ branchement selon le support
  if (HAS_POINTER) {
    addJoystickHandlers(moveJoy, "move");
    addJoystickHandlers(aimJoy,  "aim");
  } else {
    addJoystickTouchHandlers(moveJoy, "move");
    addJoystickTouchHandlers(aimJoy,  "aim");
  }

  // Repositionne l‚ÄôUI shop
  positionShopUI();
}


// ===== remplace enti√®rement cette fonction =====
function positionShopUI() {
  if (!isMobileDevice) return;
  const shopBtnEl   = document.getElementById('shopBtn');
  const shopModalEl = document.getElementById('shopModal');
  const buildBarEl  = document.getElementById('buildBar');
  if (!aimJoy || !aimJoy.joyDiv || !shopBtnEl) return;

  const isPortrait = window.matchMedia("(orientation: portrait)").matches;
  const joyRect = aimJoy.joyDiv.getBoundingClientRect();

  // --- Bouton SHOP au-dessus du joystick droit ---
  const btnGap = 20; // espace entre bouton et joystick
  shopBtnEl.style.position = "fixed";
  shopBtnEl.style.zIndex   = "10005";
  shopBtnEl.style.right    = (window.innerWidth - joyRect.right) + "px";
  shopBtnEl.style.bottom   = (window.innerHeight - joyRect.top) + btnGap + "px";

  // --- Panneau SHOP : align√© √† droite du joystick, et assez haut pour ne pas chevaucher ---
  if (shopModalEl) {
    const gap = isPortrait ? 28 : 12;
    const availableHeightAboveJoystick = Math.max(0, joyRect.top - gap);
    const margin = 10;

    const maxH = Math.max(180, Math.min(availableHeightAboveJoystick - margin, window.innerHeight - 2*margin));
    shopModalEl.style.maxHeight = maxH + "px";
    shopModalEl.style.overflowY = "auto";

    if (!isPortrait) {
      shopModalEl.style.minWidth = "300px";
      shopModalEl.style.maxWidth = Math.min(360, window.innerWidth - 20) + "px";
    }

    // ancrage horizontal √† droite du joystick
    shopModalEl.style.right = (window.innerWidth - joyRect.right + 14) + "px";

    // recalage vertical au-dessus du joystick
    let computedBottom = (window.innerHeight - joyRect.top) + gap;
    const minBottom = 8;
    const maxBottom = window.innerHeight - 120;
    if (computedBottom < minBottom) computedBottom = minBottom;
    if (computedBottom > maxBottom) computedBottom = maxBottom;
    shopModalEl.style.bottom = computedBottom + "px";
  }

  // --- ‚ù∂ NOUVEAU : positionner la barre de construction juste au-dessus du bouton SHOP ---
  if (buildBarEl) {
    // aligne horizontalement avec le bouton SHOP
    buildBarEl.style.position = "fixed";
    buildBarEl.style.right = shopBtnEl.style.right;

    // place la barre juste au-dessus du bouton SHOP (√©cart 12px)
    const btnBottomPx = parseFloat(shopBtnEl.style.bottom) || 0;
    const btnHeight   = shopBtnEl.offsetHeight || 56; // fallback si non rendu
    const gapAboveBtn = 12;
    buildBarEl.style.bottom = (btnBottomPx + btnHeight + gapAboveBtn) + "px";

    // priorit√© d‚Äôaffichage au-dessus du SHOP
    buildBarEl.style.zIndex = "10006";
  }
}





	function drawMap() {
	  if (!map.length) return;

	  // ‚úÖ tenir compte du zoom
	  const viewW = canvas.width / renderScale;
	  const viewH = canvas.height / renderScale;

	  const startCol = Math.floor(cameraX / TILE_SIZE);
	  const startRow = Math.floor(cameraY / TILE_SIZE);
	  const visibleCols = Math.ceil(viewW / TILE_SIZE) + 2;
	  const visibleRows = Math.ceil(viewH / TILE_SIZE) + 2;

	  for (let row = startRow; row < startRow + visibleRows; row++) {
		if (row < 0 || row >= MAP_ROWS) continue;
		for (let col = startCol; col < startCol + visibleCols; col++) {
		  if (col < 0 || col >= MAP_COLS) continue;
		  if (map[row][col] === 1) {
			ctx.fillStyle = '#363636';
			ctx.fillRect(
			  col * TILE_SIZE - cameraX,
			  row * TILE_SIZE - cameraY,
			  TILE_SIZE,
			  TILE_SIZE
			);
		  }
		}
	  }
	}


function drawStructures() {
  if (!structures) return;

  // 1) Pr√©-calcul : angle le plus r√©cent par tourelle (depuis les bullets)
  const latestTurretAngles = {};
  for (const bid in bullets) {
    const b = bullets[bid];
    if (!b || typeof b.owner !== 'string') continue;
    if (!b.owner.startsWith('turret_')) continue; // seulement balles de tourelles
    const key = b.owner; // ex: "turret_12_8"
    const t = b.createdAt || 0;
    if (!latestTurretAngles[key] || t > latestTurretAngles[key].t) {
      latestTurretAngles[key] = {
        t,
        ang: Math.atan2(b.dy, b.dx)
      };
    }
  }

  // 2) Bornes d'affichage (cam√©ra/viewport)
  const viewW = canvas.width / renderScale;
  const viewH = canvas.height / renderScale;

  const startCol = Math.floor(cameraX / TILE_SIZE);
  const startRow = Math.floor(cameraY / TILE_SIZE);
  const visibleCols = Math.ceil(viewW / TILE_SIZE) + 2;
  const visibleRows = Math.ceil(viewH / TILE_SIZE) + 2;

  // 3) Parcours des structures visibles
  for (let row = startRow; row < startRow + visibleRows; row++) {
    if (row < 0 || row >= MAP_ROWS) continue;
    for (let col = startCol; col < startCol + visibleCols; col++) {
      if (col < 0 || col >= MAP_COLS) continue;
      const s = structures[row]?.[col];
      if (!s) continue;

      const x = col * TILE_SIZE - cameraX;
      const y = row * TILE_SIZE - cameraY;

      if (s.type === 'B') {
        // Barricade
        ctx.fillStyle = '#7b4b2a';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

      } else if (s.type === 'D') {
        // Porte
        ctx.fillStyle = '#a57b4a';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

      } else if (s.type === 'T' || s.type === 't') {
        // Tourelle (T = grande/rouge, t = mini/bleue)
        const isBig = s.type === 'T';
        ctx.fillStyle = isBig ? '#d33' : '#3aa6ff';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = isBig ? '#3a0b0b' : '#0b1b2a';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

        // Centre √©cran et monde
        const cx = x + TILE_SIZE / 2;
        const cy = y + TILE_SIZE / 2;
        const cxW = col * TILE_SIZE + TILE_SIZE / 2;
        const cyW = row * TILE_SIZE + TILE_SIZE / 2;

        // Angle du canon (derni√®re balle tir√©e, sinon target visible la plus proche)
        const turretKey = `turret_${col}_${row}`;
        let ang = latestTurretAngles[turretKey]?.ang;
        if (ang == null) ang = findTurretTargetAngle(cxW, cyW);

        // Canon
        const L = TILE_SIZE * 0.38;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(ang) * L, cy + Math.sin(ang) * L);
        ctx.stroke();

        // ‚úÖ Barre de vie (au-dessus de la tuile)
        const maxHp = isBig ? 500 : 200;
        // x = centre, y = l√©g√®rement au-dessus de la case
        drawHealthBar(cx, y - 8, s.hp, maxHp, TILE_SIZE - 6, 5);
      }
    }
  }
}




function drawPlayers() {
  const now = performance.now();

  for (const id in playersHealth) {
    const p = playersHealth[id];
    if (!p.alive) continue;

    const pos = getSmoothPos(p, now);
    const screenX = pos.x - cameraX;
    const screenY = pos.y - cameraY;

    // Couleur en fonction de moi/les autres
    ctx.fillStyle = (id === myId) ? 'lime' : '#cfc';

    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.fill(PLAYER_CIRCLE);
    ctx.restore();

    // Pseudo
    ctx.font = "bold 17px Arial";
    ctx.textAlign = "center";
    ctx.fillStyle = "#aad8ff";
    ctx.fillText(p.pseudo || "Joueur", screenX, screenY - PLAYER_RADIUS - 22);

    // Barre de vie (largeur fixe 30)
    drawHealthBar(
      screenX,
      screenY - PLAYER_RADIUS - 13,
      p.health,
      p.maxHealth || 100,
      30
    );
  }
}


function drawZombies() {
  const now = performance.now();

  for (const id in zombies) {
    const z = zombies[id];
    const pos = getSmoothPos(z, now);

    const screenX = pos.x - cameraX;
    const screenY = pos.y - cameraY;

    // Couleur zombie : toujours rouge
    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.fillStyle = 'red';
    ctx.fill(ZOMBIE_CIRCLE);
    ctx.restore();

    // Barre de PV au-dessus du zombie
    drawHealthBar(screenX, screenY - ZOMBIE_RADIUS - 10, z.hp, z.maxHp);
  }
}




function drawBullets() {
  const now = performance.now();

  ctx.lineWidth = 3;

  for (const id in bullets) {
    const b = bullets[id];
    const pos = getSmoothPos(b, now);

    // couleur par appartenance
    ctx.strokeStyle = (b.owner === myId) ? 'yellow' : '#ff0';

    const x1 = pos.x - cameraX;
    const y1 = pos.y - cameraY;
    const x2 = x1 - (b.dx || 0) * 8;
    const y2 = y1 - (b.dy || 0) * 8;

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
}




	function drawMoneyFloatingTexts() {
	  const now = Date.now();
	  for (let i = moneyFloatingTexts.length - 1; i >= 0; i--) {
		const f = moneyFloatingTexts[i];
		const t = (now - f.time);
		if (t > f.duration) {
		  moneyFloatingTexts.splice(i, 1); // On le retire
		  continue;
		}
		// Position √©cran
		const screenX = f.x - cameraX;
		const screenY = f.y - cameraY + f.vy * t;

		ctx.save();
		ctx.globalAlpha = 1 - (t / f.duration); // Fade out progressif
		ctx.font = "bold 28px Arial";
		ctx.textAlign = "center";
		ctx.lineWidth = 3;
		ctx.strokeStyle = "#222";
		ctx.strokeText(`+${f.amount}$`, screenX, screenY);
		ctx.fillStyle = "#32ff72";
		ctx.fillText(`+${f.amount}$`, screenX, screenY);
		ctx.restore();
	  }
	}

	function drawHealthBar(x, y, current, max, width = null, height = 5) {
	  let w;
	  if (width !== null) {
		w = width;  // largeur fix√©e explicitement
	  } else {
		// largeur variable pour zombies, par exemple
		w = Math.max(30, Math.min(70, 30 + (max - 10) * 0.7));
	  }
	  const ratio = Math.max(0, Math.min(1, current / max));
	  ctx.fillStyle = '#111';
	  ctx.fillRect(x - w / 2, y, w, height);
	  ctx.fillStyle = (ratio < 0.4) ? "#e66" : "#8f8";
	  ctx.fillRect(x - w / 2, y, w * ratio, height);
	  ctx.strokeStyle = '#fff';
	  ctx.strokeRect(x - w / 2, y, w, height);
	}

function drawAimLine() {
  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  const p = playersHealth[myId];
  const px = (p.renderX != null ? p.renderX : p.x);
  const py = (p.renderY != null ? p.renderY : p.y);

  let dir = { x: 1, y: 0 };
  let show = false;

  if (isMobileDevice) {
    let len = Math.hypot(aimJoyVal.x, aimJoyVal.y);
    if (len > 0.06) {
      let ax = aimJoyVal.x / (len || 1);
      let ay = aimJoyVal.y / (len || 1);
      ax = curve(ax);
      ay = curve(ay);
      const n = Math.hypot(ax, ay);
      if (n > 0.0001) dir = { x: ax / n, y: ay / n };
      show = true;
    }
  } else {
    if (mouseDown) {
      let dx = (cameraX + mousePos.x / renderScale) - px;
      let dy = (cameraY + mousePos.y / renderScale) - py;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 3) {
        dir = { x: dx / dist, y: dy / dist };
        show = true;
      }
    }
  }

  if (!show) return;

  const length = 440;
  const screenX = px - cameraX;
  const screenY = py - cameraY;

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(screenX, screenY);
  ctx.lineTo(screenX + dir.x * length, screenY + dir.y * length);
  ctx.strokeStyle = 'rgba(255,255,0,0.66)';
  ctx.lineWidth = 2;
  ctx.shadowColor = 'yellow';
  ctx.shadowBlur = 7;
  ctx.stroke();
  ctx.restore();
}

	






if (isMobileDevice) {
  canvas.addEventListener('pointerdown', (e) => {
    if (buildMode) return;
    if (e.clientX <= window.innerWidth * 0.5) return;
    if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;

    const p = playersHealth[myId];
    const px = (p.renderX != null ? p.renderX : p.x);
    const py = (p.renderY != null ? p.renderY : p.y);

    const dx = (cameraX + e.clientX / renderScale) - px;
    const dy = (cameraY + e.clientY / renderScale) - py;
    const d  = Math.hypot(dx, dy);
    const dir = d > 4 ? { x: dx / d, y: dy / d } : lastAimDir;

    if (!shootBlocked) {
      shootBlocked = true;
      socket.emit('shoot', {
        targetX: px + dir.x * 120,
        targetY: py + dir.y * 120
      });
      setTimeout(() => { shootBlocked = false; }, 300);
    }
  }, { passive: true });
}



// ---- Aide : √©cran -> monde -> tuile ----
function screenToWorldTile(clientX, clientY) {
  const wx = cameraX + clientX / renderScale;
  const wy = cameraY + clientY / renderScale;
  return {
    tx: Math.floor(wx / TILE_SIZE),
    ty: Math.floor(wy / TILE_SIZE)
  };
}

// Survol pour l'aper√ßu de placement
canvas.addEventListener('mousemove', (e) => {
  if (!buildMode) return;
  const { tx, ty } = screenToWorldTile(e.clientX, e.clientY);
  buildHover.tx = tx; buildHover.ty = ty;
}, { passive: true });

canvas.addEventListener('pointermove', (e) => {
  if (!buildMode) return;
  const { tx, ty } = screenToWorldTile(e.clientX, e.clientY);
  buildHover.tx = tx; buildHover.ty = ty;
}, { passive: true });


// Survol mobile pour l‚Äôaper√ßu de placement
canvas.addEventListener('touchmove', (e) => {
  if (!buildMode) return;
  const t = e.changedTouches && e.changedTouches[0];
  if (!t) return;
  const { tx, ty } = screenToWorldTile(t.clientX, t.clientY);
  buildHover.tx = tx; 
  buildHover.ty = ty;
}, { passive: true });



// ---- Placement sur mobile (touch) ----
canvas.addEventListener('touchstart', (e) => {
  if (!buildMode) return;
  const t = e.changedTouches && e.changedTouches[0];
  if (!t) return;
  e.preventDefault();
  e.stopPropagation();
  tryPlaceStructureAtCursor(t.clientX, t.clientY);
  mouseDown = false;
}, { passive: false });



canvas.addEventListener('pointerdown', (e) => {
  if (!buildMode) return;
  e.preventDefault();
  e.stopPropagation();
  tryPlaceStructureAtCursor(e.clientX, e.clientY);
  mouseDown = false;
});



function drawBuildPreview() {
  if (!buildMode || buildHover.tx < 0 || buildHover.ty < 0) return;

  const tx = buildHover.tx, ty = buildHover.ty;
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) return;

  // rouge si bloqu√©, vert si OK
  const blocked = isWallAt(tx, ty) || (structures?.[ty]?.[tx]);
  const x = tx * TILE_SIZE - cameraX;
  const y = ty * TILE_SIZE - cameraY;

  ctx.save();
  ctx.globalAlpha = 0.5;
  // couleur selon le type
  if (buildMode === 'T') ctx.fillStyle = '#d33';
  else if (buildMode === 't') ctx.fillStyle = '#3aa6ff';
  else if (buildMode === 'B') ctx.fillStyle = '#7b4b2a';
  else if (buildMode === 'D') ctx.fillStyle = '#a57b4a';
  else ctx.fillStyle = '#888';

  ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

  // liser√© rouge si bloqu√© / vert sinon
  ctx.globalAlpha = 1;
  ctx.lineWidth = 2;
  ctx.strokeStyle = blocked ? '#ff3b3b' : '#34e05a';
  ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
  ctx.restore();
}




function tryPlaceStructureAtCursor(clientX, clientY) {
  const { tx, ty } = screenToWorldTile(clientX, clientY);

  // bornes / murs
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) return;
  if (isWallAt(tx, ty)) return;

  // bloc d√©j√† occup√© par une structure ?
  if (structures?.[ty]?.[tx]) return;

  // envoie au serveur
  socket.emit('buyStructure', { type: buildMode, tx, ty });

  // on sort du mode placement (une seule pose par clic)
  buildMode = null;
  buildHover = { tx: -1, ty: -1 };
}





function updateCamera() {
  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  const p = playersHealth[myId];

  const px = (p.renderX != null ? p.renderX : p.x);
  const py = (p.renderY != null ? p.renderY : p.y);

  const viewW = canvas.width / renderScale;
  const viewH = canvas.height / renderScale;

  cameraX = px - viewW / 2;
  cameraY = py - viewH / 2;

  cameraX = Math.max(0, Math.min(cameraX, MAP_COLS * TILE_SIZE - viewW));
  cameraY = Math.max(0, Math.min(cameraY, MAP_ROWS * TILE_SIZE - viewH));
}



function update(deltaTime) {
  if (isDead || !myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  const player = playersHealth[myId];

  // üëâ Utiliser la position liss√©e pour coh√©rence visuelle/vis√©e
  const px = (player.renderX != null ? player.renderX : player.x);
  const py = (player.renderY != null ? player.renderY : player.y);

  let move = { x:0, y:0 };

  // ---- MOUVEMENT ----
  if (!isMobileDevice) {
    if (keys['arrowup'] || keys['w']) move.y -= 1;
    if (keys['arrowdown'] || keys['s']) move.y += 1;
    if (keys['arrowleft'] || keys['a']) move.x -= 1;
    if (keys['arrowright'] || keys['d']) move.x += 1;
  } else {
    const len = Math.hypot(moveJoyVal.x, moveJoyVal.y);
    if (len > 0.06) {
      let mx = moveJoyVal.x / (len || 1);
      let my = moveJoyVal.y / (len || 1);
      move.x = curve(mx);
      move.y = curve(my);
    }
  }

  socket.emit('moveDir', move);

  // ---- TIR ----
  let shooting = false;
  let shootDir = { x:1, y:0 };

  if (!isMobileDevice) {
    let dx = (cameraX + mousePos.x / renderScale) - px;
    let dy = (cameraY + mousePos.y / renderScale) - py;
    let len = Math.hypot(dx, dy);
    if (len > 3) shootDir = { x: dx/len, y: dy/len };
    shooting = mouseDown;
  } else {
    const len = Math.hypot(aimJoyVal.x, aimJoyVal.y);
    if (len > 0.06) {
      let ax = aimJoyVal.x / (len || 1);
      let ay = aimJoyVal.y / (len || 1);
      ax = curve(ax);
      ay = curve(ay);
      shootDir = { x: ax, y: ay };
      shooting = true;
    }
  }

  if (shooting) {
    const n = Math.hypot(shootDir.x, shootDir.y);
    if (n > 0.0001) lastAimDir = { x: shootDir.x, y: shootDir.y };
  }

  if (shooting && !shootBlocked) {
    shootBlocked = true;
    socket.emit('shoot', {
      targetX: px + shootDir.x * 120,
      targetY: py + shootDir.y * 120
    });
    setTimeout(() => { shootBlocked = false; }, 300);
  }
}



	function drawHUD() {
	  const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
	  const aliveCount = Object.values(playersHealth).filter(p => p.alive).length;
	  hudAlive.textContent = `${tr.alive} : ${aliveCount}`;
	  hudMoney.textContent = `Money : $${myMoney}`; // <-- AJOUT ICI
	  hudZombies.textContent = `${tr.zombiesLeft}: ${Object.keys(zombies).length}`;
	  hudKills.textContent = `${tr.kills}: ${myKills}`;
	  hudRound.textContent = `${tr.round}: ${currentRound}`;
		const me = playersHealth[myId];
		hudHP.textContent = me && me.maxHealth
		  ? `${tr.health}: ${Math.round(me.health)} / ${me.maxHealth}`
		  : `${tr.health}: ${Math.round(me ? me.health : 0)}`;
	}


    function showDeathScreen(kills = myKills, round = currentRound) {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      deathStats.innerHTML = `${tr.zombiesKilled}: <b>${kills}</b><br>${tr.roundReached}: <b>${round}</b>`;
      deathScreen.style.display = 'flex';
    }
    btnReplay.onclick = () => { location.reload(); };



let lastTime = 0;
function gameLoop(timestamp = 0) {
  const deltaTime = Math.max(0.008, Math.min(0.05, (timestamp - lastTime) / 1000));
  lastTime = timestamp;

  update(deltaTime);
  updateCamera();

  // Reset transform, clear, puis scale (zoom)
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);

  // Ordre de dessin
  drawMap();
  drawBuildPreview();
  drawStructures();
  drawBullets();
  drawZombies();
  drawMoneyFloatingTexts();
  drawPlayers();
  drawAimLine();

  // ‚ùå plus de drawHUD() ici (gard√© via setInterval)

  if (!isDead) requestAnimationFrame(gameLoop);
}





    socket.on('connect', () => { myId = socket.id; });
    socket.on('lobbyUpdate', (data) => {
      lobbyData = {
        ...data,
        players: {...data.players}
      };
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      if (data.started) {
        lobbyScreen.style.display = 'none';
        lobbyStarted = true;
        return;
      }
      lobbyScreen.style.display = 'flex';
      updateLobbyTexts();
      lobbyJoin.disabled = lobbyJoined;
      pseudoInput.disabled = lobbyJoined;
      if (lobbyJoined) lobbyJoin.textContent = tr.waiting;
      else lobbyJoin.textContent = tr.join;
    });

    lobbyJoin.onclick = () => {
      if (!pseudoInput.value.trim()) {
        pseudoInput.focus();
        pseudoInput.style.background = "#fdd";
        setTimeout(() => pseudoInput.style.background = "", 600);
        return;
      }
      socket.emit('setPseudoAndReady', pseudoInput.value.trim());
      myPseudo = pseudoInput.value.trim();
      lobbyJoined = true;
      lobbyJoin.disabled = true;
      pseudoInput.disabled = true;
      lobbyJoin.textContent = TRANSLATIONS[currentLang].waiting;
    };

    pseudoInput.onkeydown = (e) => {
      if (e.key === "Enter") lobbyJoin.click();
    };

    socket.on('gameStarted', (data) => {
      map = data.map;
      MAP_ROWS = map.length;
      MAP_COLS = map[0].length;
      playersHealth = data.players;
      currentRound = data.round;
      lobbyScreen.style.display = 'none';
      isDead = false; playerHealth = 100; myKills = 0;
      if (isMobileDevice) setTimeout(setupJoysticks, 300);
      setTimeout(()=>{ gameLoop(); }, 400);
	  structures = data.structures || null;
	if (data.structurePrices) {
	  STRUCTURE_PRICES = { ...STRUCTURE_PRICES, ...data.structurePrices };
	}
	updateBuildTilesState(); // rafra√Æchir les √©tiquettes + disabled
    });

	socket.on('structuresUpdate', (grid) => {
	  structures = grid;
	});

socket.on('structurePricesUpdate', (prices) => {
  STRUCTURE_PRICES = { ...STRUCTURE_PRICES, ...prices };
  updateBuildTilesState();
});


socket.on('zombiesUpdate', (zNew) => {
  const now = performance.now();

  // conserve / met √† jour existants
  for (const id in zNew) {
    const nz = zNew[id];
    const oz = zombies[id] || { };
    // copie champs non-pos (hp, maxHp) + set cible interp
    oz.hp = nz.hp; oz.maxHp = nz.maxHp;
    oz.x = (oz.x == null) ? nz.x : oz.x;
    oz.y = (oz.y == null) ? nz.y : oz.y;
    setSmoothTarget(oz, nz.x, nz.y, SMOOTH_MS_ZB, now);
    zombies[id] = oz;
  }

  // supprime ceux qui n‚Äôexistent plus
  for (const id in zombies) {
    if (!zNew[id]) delete zombies[id];
  }
});

socket.on('bulletsUpdate', (bNew) => {
  const now = performance.now();

  for (const id in bNew) {
    const nb = bNew[id];
    const ob = bullets[id] || { };
    // copie m√©tadonn√©es utiles
    ob.owner = nb.owner;
    ob.dx = nb.dx; ob.dy = nb.dy;
    ob.createdAt = nb.createdAt;
    ob.originTx = nb.originTx; ob.originTy = nb.originTy;

    ob.x = (ob.x == null) ? nb.x : ob.x;
    ob.y = (ob.y == null) ? nb.y : ob.y;
    setSmoothTarget(ob, nb.x, nb.y, SMOOTH_MS_ZB, now);
    bullets[id] = ob;
  }

  for (const id in bullets) {
    if (!bNew[id]) delete bullets[id];
  }
});

    socket.on('killsUpdate', (kills) => { myKills = kills; drawHUD(); });
    socket.on('currentRound', (round) => { currentRound = round; drawHUD(); });


socket.on('playersHealthUpdate', (players) => {
  const now = performance.now();

  for (const id in players) {
    const src = players[id];
    if (!playersHealth[id]) playersHealth[id] = {};
    const dst = playersHealth[id];

    // √©tat
    dst.health = src.health;
    dst.alive  = src.alive;
    dst.pseudo = src.pseudo || "Joueur";
    dst.money  = src.money || 0;
    dst.maxHealth = src.maxHealth || 100;

    // init position si premi√®re fois
    if (dst.x == null) {
      dst.x = src.x; dst.y = src.y;
      dst.renderX = src.x; dst.renderY = src.y;
      dst.t0 = now; dst.td = 1;
      dst.sx = src.x; dst.sy = src.y; dst.tx = src.x; dst.ty = src.y;
    }

    // üëâ TOUJOURS lisser, m√™me pour mon joueur
    setSmoothTarget(dst, src.x, src.y, SMOOTH_MS_P, now);
  }

  const me = players[socket.id];
  if (me) {
    playerHealth = me.health;
    myMoney = me.money || 0;
    if (!playersHealth[myId]) playersHealth[myId] = {};
    playersHealth[myId].maxHealth = me.maxHealth || 100;
  }

  updateBuildTilesState();
});





    socket.on('youDied', (data) => {
      isDead = true;
      playerHealth = 0;
      showDeathScreen(data.kills, data.round);
    });

	socket.on('moneyEarned', ({ amount, x, y }) => {
	  // Position sur la map, converti en coordonn√©es √©cran pour affichage temporaire
	  moneyFloatingTexts.push({
		amount,
		x,
		y,
		time: Date.now(),
		duration: 1200, // ms
		vy: -0.14 // pixels/ms (vitesse vers le haut)
	  });
	  myMoney += amount;          // <--- ajoute
	  drawHUD();                  // <--- ajoute
	  updateBuildTilesState();    // <--- ajoute
	});


socket.on('upgradeUpdate', ({ myUpgrades: u, myMoney: m }) => {
  if (u) myUpgrades = { ...myUpgrades, ...u };
  if (typeof m === 'number') myMoney = m;
  renderShopUpgrades();
  drawHUD();
  updateBuildTilesState();
});





    socket.on('waveMessage', (msg) => {
      waveMessage.textContent = msg;
      waveMessage.style.opacity = '1';
      setTimeout(() => { waveMessage.style.opacity = '0'; }, 2500);
    });

	socket.on('upgradeBought', ({ upgId, newLevel, newMoney }) => {
	  if (!upgId) return;
	  myUpgrades[upgId] = newLevel;
	  myMoney = newMoney;
	  renderShopUpgrades();
	  drawHUD();
	  updateBuildTilesState();

	  // Trouve le bouton correspondant et applique l'animation
	  setTimeout(() => {
		const btn = document.querySelector(`#shopUpgrades button[data-upgid="${upgId}"]`);
		if (btn) {
		  btn.classList.remove('bought-flash'); // Si jamais d√©j√† pr√©sente
		  // Force reflow pour relancer l'anim m√™me si le bouton venait d'√™tre upgrad√©
		  void btn.offsetWidth;
		  btn.classList.add('bought-flash');
		  setTimeout(() => btn.classList.remove('bought-flash'), 280);
		}
	  }, 60); // petit d√©lai pour que le bouton existe apr√®s le render
	});

    setInterval(drawHUD, 150);
    setInterval(() => { if(lobbyStarted) socket.emit('requestZombies'); }, 1000);

	// --- SHOP BTN LOGIC ---
	const shopBtn = document.getElementById('shopBtn');
	const shopModal = document.getElementById('shopModal');
	const shopClose = document.getElementById('shopClose');


// ====== UI Achat Structures (au-dessus du SHOP) ======
const buildBar = document.getElementById('buildBar');
const buildTiles = document.querySelectorAll('#buildTiles .build-tile');
const buildTooltip = document.getElementById('buildTooltip');
let STRUCTURE_PRICES = { T: 1000, t: 250, B: 100, D: 200 };

// Hover ‚Üí tooltip
buildTiles.forEach(btn => {
  const tip = btn.getAttribute('data-tip') || '';
  btn.addEventListener('mouseenter', () => {
    buildTooltip.textContent = tip;
    buildTooltip.style.display = 'block';
  }, { passive: true });
  btn.addEventListener('mouseleave', () => {
    buildTooltip.style.display = 'none';
  }, { passive: true });
});



// Click ‚Üí entrer/sortir du mode placement (toggle)
let buildClickCooldown = false;
buildTiles.forEach(btn => {
  btn.addEventListener('click', () => {
    if (buildClickCooldown) return;
    buildClickCooldown = true;
    setTimeout(() => (buildClickCooldown = false), 250);

    const type = btn.getAttribute('data-type');

    // Si on reclique sur le m√™me type ‚Üí on annule le placement
    if (buildMode === type) {
      buildMode = null;
      buildHover = { tx: -1, ty: -1 };
      try { console.log(`[build] Mode placement annul√© pour '${type}'.`); } catch {}
      return;
    }

    // Sinon, on entre en mode placement pour ce type
    buildMode = type;
    try { console.log(`[build] Mode placement pour '${type}'. Clique/tape une case vide.`); } catch {}
  });
});




updateBuildTilesState();

// Ajuster la position quand on bouge le shop (mobile)
function positionBuildBar() {
  // Sur mobile, on se base sur la position recalcul√©e du SHOP (d√©j√† g√©r√©e par positionShopUI)
  // Ici, on laisse le buildBar accroch√©e en haut du shopBtn (style inline d√©j√† ok).
  // Si besoin d‚Äôajustements fins mobile, on les ferait ici sans toucher au reste.
}
window.addEventListener('resize', positionBuildBar);
window.addEventListener('orientationchange', positionBuildBar);



// R√©ception du r√©sultat d‚Äôachat d‚Äôune structure
socket.on('buildResult', (payload) => {
  const {
    ok,
    reason,
    type,
    tx,
    ty,
    newMoney,
    structurePrices // <-- si le serveur renvoie des prix √† jour
  } = payload || {};

  // Maj argent et √©ventuellement la table des prix
  if (typeof newMoney === 'number') {
    myMoney = newMoney;
  }
  if (structurePrices) {
    STRUCTURE_PRICES = { ...STRUCTURE_PRICES, ...structurePrices };
  }

  // Rafra√Æchir l‚ÄôUI
  drawHUD();
  updateBuildTilesState();

  // Gestion des erreurs + feedback
  if (!ok) {
    let msg = '';
    switch (reason) {
      case 'game_not_running': msg = "Impossible d‚Äôacheter : la partie n‚Äôest pas en cours."; break;
      case 'player_invalid':   msg = "Action impossible : joueur inactif."; break;
      case 'invalid_type':     msg = "Type d‚Äôobjet invalide."; break;
      case 'not_enough_money': msg = "Pas assez d‚Äôargent."; break;
      case 'tile_blocked':     msg = "Case indisponible (mur, structure, autre joueur ou zombie)."; break;
      default:                 msg = "Achat impossible."; break;
    }
    try { console.warn('[buildResult]', msg); } catch {}
    return;
  }

  // Succ√®s
  try { console.log(`[buildResult] Pos√© '${type}' en ${tx},${ty}`); } catch {}
});





	function closeShopIfOutside(evt) {
	  if (shopModal.style.display !== 'block') return;
	  const target = evt.target;
	  // Ne ferme pas si on clique sur le bouton ou dans le panneau
	  if (shopModal.contains(target) || shopBtn.contains(target)) return;
	  shopModal.style.display = 'none';
	}
	document.addEventListener('pointerdown', closeShopIfOutside, { passive: true });



function updateBuildTilesState() {
  document.querySelectorAll('#buildTiles .build-tile').forEach(btn => {
    const type = btn.getAttribute('data-type');
    const price = STRUCTURE_PRICES[type] ?? Infinity;

    // maj de l‚Äô√©tiquette sous la tuile (2e div)
    const priceLabel = btn.querySelector('div:nth-child(2)');
    if (priceLabel) priceLabel.textContent = `$${price}`;

    // √©tat ‚Äúachetable‚Äù
    const afford = myMoney >= price;
    btn.style.opacity = afford ? '1' : '0.55';
    btn.style.cursor  = afford ? 'pointer' : 'not-allowed';
    btn.disabled = !afford;
  });
}




const PRICE_TIERS = [10, 25, 50, 75, 100];
const PRICE_STEP_AFTER_TIER = 50;
function getUpgradePrice(nextLevel) {
  if (nextLevel <= PRICE_TIERS.length) return PRICE_TIERS[nextLevel - 1];
  return PRICE_TIERS[PRICE_TIERS.length - 1] + (nextLevel - PRICE_TIERS.length) * PRICE_STEP_AFTER_TIER;
}

function renderShopUpgrades() {
  const el = document.getElementById('shopUpgrades');
  el.innerHTML = "";
  UPGRADES.forEach(upg => {
    const lvl = myUpgrades[upg.id] || 0;                 // <-- d√©finis d‚Äôabord
    const price = getUpgradePrice(lvl + 1);              // <-- prix synchro serveur
    const value = upg.getValue(upg.baseValue, lvl);
    const nextValue = upg.getValue(upg.baseValue, lvl + 1);
    const disabled = myMoney < price;

    el.innerHTML += `
      <div style="display:flex; align-items:center; gap:14px; margin-bottom:19px; background:#222a; border-radius:10px; padding:12px 14px 10px 7px;">
        <div style="flex:1;">
          <div style="font-size:18px;"><b>${upg.label}</b></div>
          <div style="font-size:14px; color:#fffa; margin-bottom:3px;">${upg.desc}</div>
          <div style="font-size:15px; color:#bcffa8;">
            ${upg.statLabel} : <b>${upg.format(value)}</b>
            <span style="color:#8f8; font-size:14px; margin-left:7px;">‚Üí ${upg.format(nextValue)}</span>
          </div>
        </div>
        <div style="background:#282;color:#fff;font-weight:bold;border-radius:7px;font-size:15px;min-width:30px;text-align:center;padding:2px 0 1px 0;margin-right:10px;box-shadow:0 1.5px 6px #0007;border:2px solid #232;">
          <span style="font-size:15px;">${lvl}</span>
        </div>
        <button
          style="font-size:16px;background:${disabled ? '#444' : '#393'};color:#fff;border:none;border-radius:7px;padding:7px 18px;box-shadow:0 2px 8px #0004;cursor:${disabled ? 'not-allowed' : 'pointer'};opacity:${disabled ? '0.5' : '1'};margin-left:8px;transition: background 0.16s;"
          data-upgid="${upg.id}" ${disabled?'disabled':''}>
          +1<br>$${price}
        </button>
      </div>
    `;
  });

  el.querySelectorAll('button[data-upgid]').forEach(btn => {
    const upgId = btn.getAttribute('data-upgid');
    btn.onclick = () => socket.emit('upgradeBuy', { upgId });
  });
}



	shopBtn.onclick = () => {
	  renderShopUpgrades();
	  shopModal.style.display = 'block';
	  // Recalage √† l‚Äôouverture (tailles DOM connues)
	  positionShopUI();
	};


	shopClose.onclick = () => {
	  shopModal.style.display = 'none';
	};

	// (optionnel, fermer si on clique dehors la fen√™tre)
	shopModal.addEventListener('mousedown', function(e) {
	  if (e.target === shopModal) shopModal.style.display = 'none';
	});

    updateUITexts();
    drawHUD();

    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'p' && myPseudo === 'Myg') {
        socket.emit('killAllZombies');
      }
      if (e.key.toLowerCase() === 'o' && myPseudo === 'Myg') {
        socket.emit('giveMillion');
      }
    });
	
	// --- REAFFICHER LES JOYSTICKS + MAJ ZOOM SUR MOBILE APR√àS CHANGEMENT D'ORIENTATION ---
	if (isMobileDevice) {
	  window.addEventListener('resize', () => {
		updateRenderScale();
		setTimeout(() => { setupJoysticks(); positionShopUI(); }, 200);
	  });
	  window.addEventListener('orientationchange', () => {
		updateRenderScale();
		setTimeout(() => { setupJoysticks(); positionShopUI(); }, 200);
	  });
	}
(() => {
  const container = document.getElementById('mobile-build');
  if (!container) return;

  const buttons = container.querySelectorAll('.mb-btn');

  function setBuildMode(type) {
    // Toggle si on reclique le m√™me type
    if (buildMode === type) {
      buildMode = null;
      buildHover = { tx: -1, ty: -1 };
      return;
    }

    // V√©rif argent (√©vite de passer en mode si pas assez d'argent)
    const price = (STRUCTURE_PRICES && STRUCTURE_PRICES[type]) ?? Infinity;
    if (myMoney < price) {
      if (navigator.vibrate) try { navigator.vibrate(60); } catch {}
      return;
    }

    buildMode = type;
    // reset survol
    buildHover = { tx: -1, ty: -1 };
  }

  function handleTap(type, e) {
    if (e) { e.preventDefault(); e.stopPropagation(); }
    setBuildMode(type);
  }

  buttons.forEach(btn => {
    const type = btn.getAttribute('data-type');
    // Click / Pointer / Touch : on capte tous les cas
    btn.addEventListener('click',       e => handleTap(type, e));
    btn.addEventListener('pointerdown', e => handleTap(type, e), { passive: false });
    btn.addEventListener('touchstart',  e => handleTap(type, e), { passive: false });
  });
})();
	
  </script>
  
  



</body>
</html>