<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Zombination.io</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden; background: #222; color: white; font-family: Arial, sans-serif;
      touch-action: none;
      -webkit-user-select: none; user-select: none;
    }
    #gameCanvas {
      display: block;
      background: #222;
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      touch-action: none;
    }
    #hudStats {
      position: fixed;
      left: 10px;
      bottom: 10px;
      background: rgba(0,0,0,0.7);
      border-radius: 7px;
      padding: 10px 20px 10px 15px;
      font-size: 18px;
      user-select: none;
      min-width: 210px;
    }
    #hudAlive { font-weight: bold; color: #fd7; }
    #deathScreen {
      display: none;
      position: fixed;
      left: 0; top: 0;
      width: 100vw; height: 100vh;
      background: rgba(30,0,0,0.8);
      z-index: 3;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      user-select: none;
    }
    #deathScreenInner {
      background: #181818;
      border-radius: 20px;
      padding: 35px 45px;
      color: #fff;
      box-shadow: 0 6px 30px #000c;
      text-align: center;
      min-width: 320px;
    }
    #deathScreen h2 {
      margin: 0 0 15px 0;
      color: #fc2c3c;
    }
    #deathStats {
      margin-bottom: 15px;
      font-size: 20px;
    }
    #btnReplay {
      background: #222;
      color: #fff;
      padding: 10px 32px;
      border: none;
      border-radius: 10px;
      font-size: 20px;
      cursor: pointer;
      transition: background 0.16s;
    }
    #btnReplay:hover {
      background: #393;
      color: #fff;
    }

    /* LOBBY */
    #lobbyScreen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: fixed;
      left:0; top:0;
      width: 100vw; height: 100vh;
      z-index: 10;
      background: #181c;
      user-select: none;
    }
    #lobbyBox {
      background: #19191e;
      border-radius: 20px;
      padding: 36px 42px;
      box-shadow: 0 6px 30px #000c;
      min-width: 350px;
      min-height: 190px;
      text-align: center;
    }
    #lobbyBox input[type=text] {
      font-size: 20px;
      padding: 7px 12px;
      border-radius: 7px;
      border: 1px solid #444;
      outline: none;
      margin-bottom: 10px;
      width: 175px;
    }
    #lobbyJoin {
      padding: 7px 32px;
      border-radius: 8px;
      border:none;
      font-size: 20px;
      background:#49c749;
      color: #fff;
      cursor: pointer;
      margin-top: 7px;
    }
    #lobbyJoin[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #lobbyPlayers {
      margin: 18px 0 12px 0;
      color: #9fd;
    }
    #lobbyTimer {
      font-size: 17px;
      margin-bottom: 9px;
    }
    #lobbyStatus {
      margin: 4px 0 0 0;
      color: #ccc;
      font-size: 14px;
    }
    #lobbyVersion {
      position: fixed;
      bottom: 8px;
      right: 8px;
      color: #888;
      font-size: 13px;
      user-select: none;
    }

    /* LANG SELECT */
    #langSelectRow {
      margin-top: 18px;
      display: flex;
      justify-content: center;
      gap: 13px;
      user-select: none;
    }
    .langFlag {
      width: 38px;
      height: 26px;
      border-radius: 6px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: border 0.14s, transform 0.12s;
      background: #fff2;
      object-fit: cover;
      box-shadow: 0 2px 10px #0003;
    }
    .langFlag.selected {
      border: 2.5px solid #33fc69;
      transform: scale(1.07);
      box-shadow: 0 2px 16px #33fc6930;
    }

    /* WAVE MESSAGE */
    #waveMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #f2f263;
      font-size: 48px;
      font-weight: bold;
      text-shadow: 2px 2px 6px #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease-in-out;
      z-index: 20;
      user-select: none;
    }

    /* Joysticks Mobile */
    #joystickMove, #joystickAim {
      position: fixed;
      bottom: 160px;
      width: 160px;
      height: 160px;
      opacity: 0.3;
      user-select: none;
      touch-action: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    #joystickMove {
      left: 40px;
    }
    #joystickAim {
      right: 40px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div id="hudStats">
    <div id="hudAlive"></div>
    <div id="hudZombies"></div>
    <div id="hudKills"></div>
    <div id="hudRound"></div>
    <div id="hudHP"></div>
  </div>

  <div id="deathScreen">
    <div id="deathScreenInner">
      <h2 id="deathTitle"></h2>
      <div id="deathStats"></div>
      <button id="btnReplay"></button>
    </div>
  </div>

  <div id="lobbyScreen">
    <div id="lobbyBox">
      <div id="lobbyTitle" style="font-size: 28px; margin-bottom: 18px;"><b>Zombination.io</b></div>
      <div id="lobbyPlayers"></div>
      <div id="lobbyTimer"></div>
      <div id="lobbyStatus"></div>
      <input type="text" id="pseudoInput" maxlength="15" placeholder="" />
      <br>
      <button id="lobbyJoin"></button>
      <div id="langSelectRow"></div>
    </div>
    <div id="lobbyVersion">Version 1.0.0 par Myg</div>
  </div>

  <div id="waveMessage"></div>

  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.7.3/dist/nipplejs.min.js"></script>
  <script src="/translations.js"></script>
  <script src="/socket.io/socket.io.js"></script>
<script>
  const LANGS = [
    { code: 'en', flag: 'gb.png', label: 'English' },
    { code: 'cn', flag: 'cn.png', label: '中文' },
    { code: 'ru', flag: 'ru.png', label: 'Русский' },
    { code: 'es', flag: 'es.png', label: 'Español' },
    { code: 'pt', flag: 'pt.png', label: 'Português' },
    { code: 'de', flag: 'de.png', label: 'Deutsch' },
    { code: 'jp', flag: 'jp.png', label: '日本語' },
    { code: 'fr', flag: 'fr.png', label: 'Français' },
    { code: 'pl', flag: 'pl.png', label: 'Polski' },
    { code: 'kr', flag: 'kr.png', label: '한국어' }
  ];

  function getDefaultLang() {
    return "en";
  }

  let currentLang = getDefaultLang();

  let lobbyData = {
    started: false,
    count: 0,
    max: 8,
    timeLeft: 30,
    players: {}
  };
  let lobbyJoined = false;
  let lobbyStarted = false;

  const pseudoInput = document.getElementById('pseudoInput');
  const lobbyJoin = document.getElementById('lobbyJoin');
  const lobbyPlayers = document.getElementById('lobbyPlayers');
  const lobbyTimer = document.getElementById('lobbyTimer');
  const lobbyStatus = document.getElementById('lobbyStatus');
  const deathTitle = document.getElementById('deathTitle');
  const deathStats = document.getElementById('deathStats');
  const btnReplay = document.getElementById('btnReplay');
  const waveMessage = document.getElementById('waveMessage');

  function initLobbyTexts() {
    updateLobbyTexts();
    pseudoInput.placeholder = TRANSLATIONS[currentLang].enterPseudo;
    lobbyJoin.textContent = TRANSLATIONS[currentLang].join;
  }

  function updateLobbyTexts() {
    const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
    lobbyPlayers.textContent = `${tr.playersInGame} : ${lobbyData.count}/${lobbyData.max}`;
    lobbyTimer.textContent = `${tr.timeLeft} : ${lobbyData.timeLeft}s`;
    const readyCount = Object.values(lobbyData.players).filter(p=>p.ready).length;
    lobbyStatus.textContent = `${tr.waitingStart} (${readyCount} ${tr.playersReady}${readyCount>1?'s':''})`;
  }

  function updateUITexts() {
    const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
    document.getElementById('lobbyTitle').innerHTML = `<b>${tr.zombination}</b>`;
    pseudoInput.placeholder = tr.enterPseudo;
    lobbyJoin.textContent = lobbyJoined ? tr.waiting : tr.join;
    deathTitle.textContent = tr.youDied;
    btnReplay.textContent = tr.replay;
    if (!lobbyStarted) updateLobbyTexts();
  }

  const langSelectRow = document.getElementById('langSelectRow');
  function renderLangFlags() {
    langSelectRow.innerHTML = '';
    LANGS.forEach(lang => {
      const img = document.createElement('img');
      img.src = `/flags/${lang.flag}`;
      img.alt = lang.label;
      img.title = lang.label;
      img.className = 'langFlag' + (lang.code === currentLang ? ' selected' : '');
      img.onclick = () => {
        if (currentLang !== lang.code) {
          currentLang = lang.code;
          renderLangFlags();
          updateUITexts();
          drawHUD();
        }
      };
      langSelectRow.appendChild(img);
    });
  }

  renderLangFlags();
  initLobbyTexts();

  const socket = io();

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  let players = {};
  let zombies = {};
  let bullets = {};
  let myId = null;
  let playerHealth = 100;
  let isDead = false;
  let myKills = 0;
  let myPseudo = "";

  const PLAYER_RADIUS = 10;
  const ZOMBIE_RADIUS = 10;
  const TILE_SIZE = 40;

  let cameraX = 0;
  let cameraY = 0;

  let aimDir = { x: 0, y: 0 };
  let moveDir = { x: 0, y: 0 };

  // Joysticks
  let joystickMove = null;
  let joystickAim = null;

  function setupJoysticks() {
    if (joystickMove) joystickMove.destroy();
    if (joystickAim) joystickAim.destroy();

    joystickMove = nipplejs.create({
      zone: document.body,
      mode: 'static',
      position: { left: 120, bottom: 160 },
      color: 'white',
      size: 160,
      restOpacity: 0.3
    });

    joystickAim = nipplejs.create({
      zone: document.body,
      mode: 'static',
      position: { right: 120, bottom: 160 },
      color: 'yellow',
      size: 160,
      restOpacity: 0.3
    });

    joystickMove.on('move', (evt, data) => {
      if (!data.vector) return;
      moveDir = { x: data.vector.x, y: data.vector.y };
      sendMoveInput(moveDir);
    });
    joystickMove.on('end', () => {
      moveDir = { x: 0, y: 0 };
      sendMoveInput(moveDir);
    });

    joystickAim.on('move', (evt, data) => {
      if (!data.vector) return;
      aimDir = { x: data.vector.x, y: data.vector.y };
      sendShootInput(aimDir);
    });
    joystickAim.on('end', () => {
      aimDir = { x: 0, y: 0 };
      sendShootInput(aimDir);
    });
  }

  function sendMoveInput(dir) {
    if (!socket.connected) return;
    socket.emit('playerInput', dir);
  }

  function sendShootInput(dir) {
    if (!socket.connected) return;
    socket.emit('playerShoot', dir);
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function drawHealthBar(x, y, current, max, width = 30, height = 5) {
    const ratio = Math.max(0, Math.min(1, current / max));
    ctx.fillStyle = '#111';
    ctx.fillRect(x - width/2, y, width, height);
    ctx.fillStyle = (ratio < 0.4) ? "#e66" : "#8f8";
    ctx.fillRect(x - width/2, y, width * ratio, height);
    ctx.strokeStyle = '#fff';
    ctx.strokeRect(x - width/2, y, width, height);
  }

  function drawAimLine(x, y, dx, dy) {
    const length = 200; // 200% length
    const angle = Math.atan2(dy, dx);
    ctx.save();
    ctx.strokeStyle = 'yellow';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
    ctx.stroke();
    ctx.restore();
  }

  function drawMap() {
    if (!map || !map.length) return;
    const startCol = Math.floor(cameraX / TILE_SIZE);
    const startRow = Math.floor(cameraY / TILE_SIZE);
    const visibleCols = Math.ceil(canvas.width / TILE_SIZE) + 2;
    const visibleRows = Math.ceil(canvas.height / TILE_SIZE) + 2;
    for (let row = startRow; row < startRow + visibleRows; row++) {
      if (row < 0 || row >= map.length) continue;
      for (let col = startCol; col < startCol + visibleCols; col++) {
        if (col < 0 || col >= map[0].length) continue;
        if (map[row][col] === 1) {
          ctx.fillStyle = '#363636';
          ctx.fillRect(
            col * TILE_SIZE - cameraX,
            row * TILE_SIZE - cameraY,
            TILE_SIZE,
            TILE_SIZE
          );
        }
      }
    }
  }

  function drawPlayers() {
    for (const id in players) {
      const p = players[id];
      if (!p.alive) continue;
      const screenX = p.x - cameraX;
      const screenY = p.y - cameraY;
      ctx.beginPath();
      ctx.fillStyle = (id === myId) ? 'lime' : '#cfc';
      ctx.arc(screenX, screenY, PLAYER_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = "bold 17px Arial";
      ctx.textAlign = "center";
      ctx.fillStyle = "#aad8ff";
      ctx.fillText(p.pseudo || "Joueur", screenX, screenY - PLAYER_RADIUS - 22);
      drawHealthBar(screenX, screenY - PLAYER_RADIUS - 13, p.health, 100, 32, 6);
      if (id === myId && (Math.abs(aimDir.x) > 0.1 || Math.abs(aimDir.y) > 0.1)) {
        drawAimLine(screenX, screenY, aimDir.x, aimDir.y);
      }
    }
  }

  function drawZombies() {
    for (const id in zombies) {
      const z = zombies[id];
      const screenX = z.x - cameraX;
      const screenY = z.y - cameraY;
      ctx.beginPath();
      ctx.fillStyle = 'red';
      ctx.arc(screenX, screenY, ZOMBIE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      drawHealthBar(screenX, screenY - ZOMBIE_RADIUS - 10, z.hp, z.maxHp || 10);
    }
  }

  function drawBullets() {
    for (const id in bullets) {
      const b = bullets[id];
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = (b.owner === myId) ? 'yellow' : '#ff0';
      ctx.lineWidth = 3;
      ctx.moveTo(b.x - cameraX, b.y - cameraY);
      ctx.lineTo(
        b.x - cameraX - b.dx * 8,
        b.y - cameraY - b.dy * 8
      );
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawHUD() {
    const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
    const aliveCount = Object.values(players).filter(p => p.alive).length;
    document.getElementById('hudAlive').textContent = `${tr.alive} : ${aliveCount}`;
    document.getElementById('hudZombies').textContent = `${tr.zombiesLeft}: ${Object.keys(zombies).length}`;
    document.getElementById('hudKills').textContent = `${tr.kills}: ${myKills}`;
    document.getElementById('hudRound').textContent = `${tr.round}: ${currentRound}`;
    document.getElementById('hudHP').textContent = `${tr.health}: ${playerHealth}`;
  }

  let currentRound = 1;
  let map = null;

  function gameTick() {
    if (!players[myId]) return;
    const p = players[myId];
    cameraX = p.x - canvas.width / 2;
    cameraY = p.y - canvas.height / 2;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMap();
    drawZombies();
    drawPlayers();
    drawBullets();
    drawHUD();
  }

  let tickInterval = null;
  function startGameLoop() {
    if (tickInterval) clearInterval(tickInterval);
    tickInterval = setInterval(gameTick, 1000 / 30);
  }

  function showDeathScreen(kills, round) {
    isDead = true;
    deathTitle.textContent = TRANSLATIONS[currentLang]?.youDied || "You Died";
    deathStats.textContent = `${TRANSLATIONS[currentLang]?.kills || "Kills"}: ${kills} — ${TRANSLATIONS[currentLang]?.round || "Round"}: ${round}`;
    document.getElementById('deathScreen').style.display = 'flex';
  }

  btnReplay.onclick = () => {
    isDead = false;
    document.getElementById('deathScreen').style.display = 'none';
    socket.emit('leaveLobby');
    location.reload();
  };

  lobbyJoin.onclick = () => {
    if (lobbyJoined) return;
    const pseudo = pseudoInput.value.trim();
    if (!pseudo || !/^[A-Za-z0-9]{1,15}$/.test(pseudo)) {
      alert(TRANSLATIONS[currentLang]?.pseudoInvalid || "Pseudo invalide");
      return;
    }
    myPseudo = pseudo;
    socket.emit('setPseudoAndReady', pseudo);
    lobbyJoined = true;
    lobbyJoin.textContent = TRANSLATIONS[currentLang]?.waiting || "Waiting...";
  };

  // Socket events

  socket.on('connect', () => {
    myId = socket.id;
  });

  socket.on('lobbyUpdate', (data) => {
    lobbyData = data;
    updateLobbyTexts();
    if (data.started) {
      lobbyStarted = true;
      document.getElementById('lobbyScreen').style.display = 'none';
    }
  });

  socket.on('gameStarted', (data) => {
    players = data.players;
    map = data.map;
    currentRound = data.round || 1;
    lobbyStarted = true;
    document.getElementById('lobbyScreen').style.display = 'none';
    playerHealth = players[myId]?.health || 100;
    isDead = false;
    setupJoysticks();
    startGameLoop();
  });

  socket.on('playersHealthUpdate', (data) => {
    players = data;
    if (players[myId]) playerHealth = players[myId].health;
    drawHUD();
  });

  socket.on('zombiesUpdate', (data) => {
    zombies = data;
  });

  socket.on('bulletsUpdate', (data) => {
    bullets = data;
  });

  socket.on('killsUpdate', (kills) => {
    myKills = kills;
  });

  socket.on('youDied', (data) => {
    showDeathScreen(data.kills, data.round);
  });

  socket.on('waveMessage', (msg) => {
    waveMessage.textContent = msg;
    waveMessage.style.opacity = '1';
    setTimeout(() => {
      waveMessage.style.opacity = '0';
    }, 2500);
  });

  // Input with keyboard for PC players
  let keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  function updatePCInputs() {
    if (!lobbyStarted || isDead) return;
    let dx = 0, dy = 0;
    if (keys['w'] || keys['z']) dy -= 1;
    if (keys['s']) dy += 1;
    if (keys['a']) dx -= 1;
    if (keys['d']) dx += 1;
    let len = Math.sqrt(dx*dx + dy*dy);
    if (len > 0) {
      dx /= len; dy /= len;
    }
    sendMoveInput({ x: dx, y: dy });

    // Aim with mouse position
    if (mousePos && players[myId]) {
      const p = players[myId];
      const cx = p.x - cameraX;
      const cy = p.y - cameraY;
      let aimX = mousePos.x - cx;
      let aimY = mousePos.y - cy;
      let dist = Math.sqrt(aimX*aimX + aimY*aimY);
      if (dist > 0) {
        aimX /= dist; aimY /= dist;
        sendShootInput({ x: aimX, y: aimY });
      }
    }
  }

  let mousePos = null;
  canvas.addEventListener('mousemove', (e) => {
    mousePos = { x: e.clientX, y: e.clientY };
  });
  canvas.addEventListener('mouseleave', () => {
    mousePos = null;
    sendShootInput({ x: 0, y: 0 });
  });

  setInterval(updatePCInputs, 40);

</script>
</body>
</html>
