<!DOCTYPE html>

<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport"/>
<title>Zombination.io</title>
<style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #222; color: white; font-family: Arial, sans-serif; }
    #gameCanvas { display: block; background: #222; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
	#gameCanvas { touch-action: none; }
	.joystick-base, .joystick-stick { touch-action: none; }
	html, body { overscroll-behavior: none; }
    #hudStats { position: fixed; left: 10px; bottom: 10px; background: rgba(0,0,0,0.7); border-radius: 7px; padding: 10px 20px 10px 15px; font-size: 18px; user-select: none; min-width: 210px; }
    #hudAlive { font-weight: bold; color: #fd7; }
    #deathScreen { display: none; position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; background: rgba(30,0,0,0.8); z-index: 3; justify-content: center; align-items: center; flex-direction: column; }
    #deathScreenInner { background: #181818; border-radius: 20px; padding: 35px 45px; color: #fff; box-shadow: 0 6px 30px #000c; text-align: center; min-width: 320px; }
    #deathScreen h2 { margin: 0 0 15px 0; color: #fc2c3c; }
    #deathStats { margin-bottom: 15px; font-size: 20px; }
    #btnReplay { background: #222; color: #fff; padding: 10px 32px; border: none; border-radius: 10px; font-size: 20px; cursor: pointer; transition: background 0.16s; }
    #btnSpectate { background: #222; color: #fff; padding: 10px 18px; border: 0; border-radius: 10px; font-size: 20px; cursor: pointer; transition: background 0.16s; margin-left: 10px; }
    #btnSpectate:hover { background: #339; color: #fff; }
    #spectateReplayBtn { display:none; position: fixed; left: 50%; transform: translateX(-50%); bottom: 20px; background: #222; color:#fff; border:0; border-radius: 10px; padding:10px 18px; font-size:18px; cursor:pointer; box-shadow:0 4px 16px #0008; }
    #btnReplay:hover { background: #393; color: #fff; }
    /* --- LOBBY --- */
    #lobbyScreen { display: flex; flex-direction: column; align-items: center; justify-content: center; position: fixed; left:0;top:0;width:100vw;height:100vh;z-index:10; background: #181c; }
    #lobbyBox { background: #19191e; border-radius: 20px; padding: 36px 42px; box-shadow: 0 6px 30px #000c; min-width: 350px; min-height: 190px; text-align: center; }
    #lobbyBox input[type=text] { font-size: 20px; padding: 7px 12px; border-radius: 7px; border: 1px solid #444; outline: none; margin-bottom: 10px; width: 175px; background:#fff; color:#000; text-align:center; }
    #pseudoInput::placeholder { text-align: center; }

    #lobbyJoin { padding: 7px 32px; border-radius: 8px; border:none; font-size: 20px; background:#49c749; color: #fff; cursor: pointer; margin-top: 7px; }
    #lobbyJoin[disabled] { opacity: 0.6; cursor: not-allowed; }
    #btnJoinLobbyList[disabled], #btnCreateLobby[disabled] { opacity: 0.6; cursor: not-allowed; }
    
    #btnLadder[disabled], #btnLogin[disabled], #btnSignup[disabled], #btnLogout[disabled], #btnSettings[disabled] { opacity: 0.6; cursor: not-allowed; }
#lobbyPlayers { margin: 18px 0 12px 0; color: #9fd; }
    #lobbyTimer { font-size: 17px; margin-bottom: 9px; }
    #lobbyStatus { margin: 4px 0 0 0; color: #ccc; font-size: 14px; }

    /* --- LANG SELECT --- */
    #langSelectRow {
      margin-top: 18px;
      display: flex;
      justify-content: center;
      gap: 13px;
      user-select: none;
    }
    .langFlag {
      width: 38px;
      height: 26px;
      border-radius: 6px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: border 0.14s, transform 0.12s;
      background: #fff2;
      object-fit: cover;
      box-shadow: 0 2px 10px #0003;
    }
    .langFlag.selected {
      border: 2.5px solid #33fc69;
      transform: scale(1.07);
      box-shadow: 0 2px 16px #33fc6930;
    }

    
    /* --- MOBILE: LANG FLAGS on 2 rows (5 + 5) --- */
    @media (max-width: 768px) {
      #langSelectRow {
        display: grid;
        grid-template-columns: repeat(5, 38px);
        justify-content: center;
        gap: 12px;
      }
    }
/* --- WAVE MESSAGE --- */
    #waveMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #f2f263;
      font-size: 48px;
      font-weight: bold;
      text-shadow: 2px 2px 6px #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease-in-out;
      z-index: 20;
      user-select: none;
    }
    /* Version */
    #versionBox {
      position: fixed;
      right: 20px;
      bottom: 14px;
      color: #ccc;
      font-size: 14px;
      opacity: 0.8;
      z-index: 20;
      user-select: none;
    }
    /* Ajout des joysticks mobile */
	.joystick-container {
	  position: fixed;
	  z-index: 10000;
	  touch-action: none;
	  pointer-events: auto; /* <-- IMPORTANT : le conteneur doit capter les events */
	}
    .joystick-base, .joystick-stick {
      pointer-events: auto;
      user-select: none;
    }
	#shopModal {
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  max-height: min(78vh, 640px);
  overflow: hidden;
}

	#shopModal { z-index: 10010 !important; }
	#shopModal:focus-within { outline: 2px solid #4dfc82; }
	#shopModal::-webkit-scrollbar { width: 6px; }
	#shopModal::-webkit-scrollbar-thumb { background: #2a5; border-radius: 4px; }

	/* √âtape 1 ‚Äî structure interne du panneau (scroll propre) */
	#shopModal {
	  display: flex;
	  flex-direction: column;
	}

	#shopUpgrades {
  overflow-y: auto;
  flex: 1 1 auto;
  min-height: 0;
  max-height: 100%;
  -webkit-overflow-scrolling: touch;
  height:auto;
  max-height: calc(100dvh - 180px);
  padding-right:6px;
}

		
@media (hover: none) and (pointer: coarse) {
  /* Contraintes + anim sp√©cifiques mobile */
  #shopModal {
    box-sizing: border-box;

    /* dimensions qui tiennent toujours dans l'√©cran */
    width: auto;
    max-width: min(92vw, 420px) !important;
    max-height: calc(100dvh - 24px) !important;

    overflow-y: auto;
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;

    /* apparition mobile + easing voulu */
    transform: scale(0.5);
    transform-origin: bottom right;
    animation: shopPopInMobile 0.22s ease-out;
  }

  /* Le bouton doit passer sous le panneau */
  #shopBtn { z-index: 10005 !important; }
}

@keyframes shopPopInMobile {
  0%   { opacity: 0; transform: translateY(80px) scale(0.5); }
  100% { opacity: 1; transform: scale(0.5); }
}

	@keyframes shopPopIn {
	  0% { opacity: 0; transform: translateY(80px) scale(0.97);}
	  100% { opacity: 1; transform: none; }
	}
	#shopClose:hover { color: #ff6464; transform: scale(1.13); }
	.bought-flash {
	  animation: flashBtn 0.22s;
	}
	@keyframes flashBtn {
	  0% { box-shadow: 0 0 0px #67fa62, 0 0 0px #fff; background: #34c24c;}
	  55% { box-shadow: 0 0 11px #67fa62, 0 0 22px #fff9;}
	  100% { box-shadow: 0 0 0px #67fa62, 0 0 0px #fff; }
	}
  
/* Hide clutter while in main menu */
body.menu-hide-ui #fpsCounter,
  body.menu-hide-ui #shopBtn,
  body.menu-hide-ui #buildBar,
  body.menu-hide-ui #hudStats,
  body.menu-hide-ui .mobile-build { display: none !important; }

  /* Patch: Keep only the "Zombination.io" panel visible in the main menu
     and place the lobby background above all other UI elements without deleting them. */
  #lobbyScreen {
    z-index: 20050 !important; /* above shop, build bar, mobile UI, joysticks */
    pointer-events: auto !important; /* block clicks to underlying UI */
    background: #181c; /* keep existing lobby feel while covering elements beneath */
  }

/* === Mobile build confirm UI === */
.mobile-build-confirm {
  position: fixed;
  z-index: 10050;
  pointer-events: none;
}
.mobile-build-confirm .btn {
  position: absolute;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: none;
  font-size: 22px;
  line-height: 44px;
  text-align: center;
  box-shadow: 0 2px 10px rgba(0,0,0,0.5);
  pointer-events: auto;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
}
.mobile-build-confirm .btn-confirm { background: #22c55e; color: #fff; }
.mobile-build-confirm .btn-cancel  { background: #ef4444; color: #fff; }

</style>

<style>
/* === CHAT WIDGET (World + Lobby) === */
#chatPanel {
  position: fixed;
  left: 12px;
  bottom: 12px;
  width: min(420px, 94vw);
  max-height: 46vh;
  display: flex;
  flex-direction: column;
  background: rgba(18,18,18,0.86);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  box-shadow: 0 6px 26px #000c;
  z-index: 2147483647 !important;
  overflow: hidden;
  backdrop-filter: blur(6px);
  color: #fff;

  pointer-events: auto !important;
}
#chatHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 8px 10px;
  background: rgba(255,255,255,0.06);
  user-select: none;
}
#chatTitle { font-weight: 700; letter-spacing: .3px; }
#chatToggle {
  border: none;
  background: transparent;
  color: #fff;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  padding: 4px 8px;
  border-radius: 8px;
}
#chatToggle:hover { background: rgba(255,255,255,0.08); }
#chatTabs { display: flex; gap: 6px; padding: 6px 10px 0 10px; }
.chatTab { position: relative; font-size: 12px; padding: 4px 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.06); cursor: pointer; }
.chatTab.active { background: rgba(46,160,67,0.35); }
.chatTab.notify::after {
  content: '';
  position: absolute;
  right: -4px;
  top: -4px;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #e33;
  border: 2px solid rgba(18,18,18,0.86);
  box-shadow: 0 0 8px rgba(227,51,51,.8);
}
#chatMessages {
  flex: 1 1 auto;
  overflow-y: auto;
  padding: 8px 10px;
  font-size: 14px;
  color: #fff;
}
.chatLine { margin: 3px 0; word-break: break-word; color:#fff; }
.chatName { color: #9fd; font-weight: 600; margin-right: 6px; }
#chatInputRow {
  display: flex;
  gap: 6px;
  padding: 8px 10px 10px 10px;
  border-top: 1px solid rgba(255,255,255,0.08);
}
#chatInput {
  flex: 1 1 auto;
  min-width: 0;
  border: 1px solid #444;
  background: #111;
  color: #fff;
  border-radius: 8px;
  padding: 8px 10px;
  outline: none;
  font-size: 14px;
}
#chatSend {
  border: none;
  background: #2a5;
  color: #fff;
  border-radius: 8px;
  padding: 8px 12px;
  font-weight: 700;
  cursor: pointer;
}
#chatSend:disabled { opacity: .6; cursor: not-allowed; }
#chatCollapsedBtn {
  position: fixed;
  left: 12px;
  bottom: 12px;
  width: 42px;
  height: 42px;
  border-radius: 12px;
  background: rgba(18,18,18,0.86);
  border: 1px solid rgba(255,255,255,0.1);
  color: #fff;
  display: none;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 2147483647 !important;
  box-shadow: 0 6px 26px #000c;

  pointer-events: auto !important;
}
#chatCollapsedBtn.notify::after {
  content: '';
  position: absolute;
  right: -2px;
  top: -2px;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #e33;
  border: 2px solid rgba(18,18,18,0.86);
  box-shadow: 0 0 8px rgba(227,51,51,.8);
}
@media (max-width: 768px) {
  #chatPanel { max-height: 38vh; width: min(92vw, 420px); }
}
</style>
<style>
/* ensure chat is always clickable above any overlays */
#chatPanel, #chatPanel * { pointer-events: auto !important; }
#chatCollapsedBtn { pointer-events: auto !important; }
</style>

<!-- MOBILE LOBBY RESIZE PATCH (ULTRA ROBUST) -->
<style id="mobile-lobby-resize-patch">
/* Use dynamic viewport units and safe scrolling for the lobby on mobile only */
@media (max-width: 768px) {
  /* Full-screen overlay must match dynamic viewport height even with browser UI/keyboard */
  #lobbyScreen {
    height: calc(var(--vh, 1vh) * 100) !important;
    width: 100vw;
    padding: clamp(6px, 2dvh, 16px) 12px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    overflow: hidden !important; /* internal scroll lives on the box */
  }
  /* Main panel: clamp width, allow internal scroll, respect safe area */
  #lobbyBox {
    width: min(96vw, 520px) !important;
    max-width: 96vw !important;
    max-height: calc(var(--vh, 1vh) * 100 - 24px) !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;
    padding: clamp(16px, 3.6vw, 28px) clamp(14px, 3.2vw, 24px) !important;
    border-radius: 16px !important;
    box-sizing: border-box;
    overscroll-behavior: contain;
  }
  /* Input & buttons sizing tweaks for small screens */
  #pseudoInput { width: 100% !important; max-width: 100% !important; box-sizing: border-box !important; display: block; }
  #lobbyBtnRow button { font-size: 16px !important; padding: 8px 18px !important; }
  #lobbyTitle { font-size: clamp(20px, 5.8vw, 26px) !important; }
  /* Nested lists should also size to remaining space to avoid being cut */
  #lobbiesList {
    max-height: calc(var(--vh, 1vh) * 100 - 260px) !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;
  }
  #manualLobbyPanel { max-height: calc(var(--vh, 1vh) * 100 - 220px); overflow: auto; }
}

/* Tiny phones portrait */
@media (max-width: 380px) and (orientation: portrait) {
  #lobbyBox { border-radius: 14px !important; }
  #lobbyBtnRow { gap: 6px !important; }
}
</style>

<!-- MOBILE CENTERING PATCH: lobbyBox width & centering -->
<style>
@media (max-width: 768px) {
  /* Ensure the main lobby window fits and centers on small screens */
  html, body { overflow-x: hidden; }
  #lobbyBox {
    min-width: 0 !important;
    /* Fallback: keep 12px gutters on each side even on browsers without env() */
    width: calc(100vw - 24px) !important;
    /* Preferred: also cap to 520px and account for safe areas when supported */
    width: min(520px, calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right) - 24px)) !important;
    margin-left: auto !important;
    margin-right: auto !important;
    box-sizing: border-box !important;
    max-width: min(520px, calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right) - 24px)) !important;
  }
  /* Add small horizontal padding on the overlay to avoid touching edges */
  #lobbyScreen {
    box-sizing: border-box;
    padding-left: max(12px, env(safe-area-inset-left));
    padding-right: max(12px, env(safe-area-inset-right));
  }
}</style>
</head>
<body>
<script>
  // Default UI scale: mobile x4, desktop x1 (can be overridden by setting window.__uiScale before)
  (function(){
    try {
      if (typeof window.__uiScale === 'undefined' || window.__uiScale == null) {
        var isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent || '');
        window.__uiScale = isMobile ? 4 : 1;
      }
      try { if (window.debugLog) debugLog('üî≠ uiScale default =', window.__uiScale); } catch(_){}
    } catch(e){}
  })();
</script>

<div id="fpsCounter" style="position:fixed;left:8px;top:8px;background:#0008;color:#0f0;padding:4px 8px;border-radius:6px;font:12px monospace;z-index:9999">FPS: --</div>
<div id="devPerfPanel" style="position:fixed;left:8px;top:30px;background:#000c;color:#fff;padding:6px 10px;border-radius:6px;font:12px monospace;z-index:10000;display:none;max-width:44vw;pointer-events:none;white-space:pre;line-height:1.2"></div>
<canvas id="gameCanvas"></canvas>
<div id="hudStats">
<div id="hudAlive"></div>
<div id="hudMoney"></div>
<div id="hudZombies"></div>
<div id="hudKills"></div>
<div id="hudRound"></div>
<div id="hudHP"></div>
</div>
<div id="deathScreen">
<div id="deathScreenInner">
<h2 id="deathTitle"></h2>
<p id="deathStats"></p><div style="display: flex; justify-content: center; gap: 10px; margin-top: 16px;"><button id="btnReplay">Replay</button><button id="btnSpectate">Spectate</button></div></div>
</div>
<div id="lobbyScreen">
<div id="lobbyBox">
<div id="lobbyTitle" style="font-size: 28px; margin-bottom: 18px;"><b>Zombination.io</b></div>
<div id="lobbyPlayers"></div>
        <!-- Manual lobby panel (hidden by default) -->
        <div id="manualLobbyPanel" style="display:none; margin-top:12px; text-align:center;">
          <div id="manualLobbyTitle" style="font-weight:600; margin-bottom:6px;">Lobby</div>
          <div id="manualLobbyPlayers" style="font-size:14px; margin-bottom:8px;"></div>
          <div style="display:flex; gap:8px; justify-content:center;">
            <button id="btnStartManual" style="padding: 10px 20px; background: #3fa33f; color: white; border: none; border-radius: 6px; cursor: pointer;">Start</button>
            <button id="btnBackFromManual" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 6px; cursor: pointer;">Back</button>
          </div>
          <div id="manualLobbyNote" style="margin-top:6px; color:#ccc; font-size:12px;">Only the creator can start.</div>
        </div>

        <!-- Join lobby list panel (hidden by default) -->
        <div id="joinLobbyPanel" style="display:none; margin-top:12px;">
          <div style="text-align:center; font-weight:600; margin-bottom:6px;"><span id="joinLobbyTitle">Available lobbies</span></div>
          <div id="lobbiesList" style="display:flex; flex-direction:column; gap:6px;overflow-y: auto;-webkit-overflow-scrolling: touch;max-height: calc(60vh - 120px);padding-right: 6px;"></div>
          <div style="display:flex; gap:8px; justify-content:center; margin-top:8px;">
            
            <button id="btnBackFromList" style="padding: 8px 14px; background: #666; color: white; border:none; border-radius:6px; cursor:pointer;">Back</button>
          </div>
        </div>

        <!-- Ladder panel (hidden by default) -->
        <div id="ladderPanel" style="display:none; margin-top:12px;">
          <div style="text-align:center; font-weight:600; margin-bottom:6px;">
            <span id="ladderTitle">Ladder</span>
          </div>
          <div id="ladderList" style="display:block; overflow-y:auto; -webkit-overflow-scrolling:touch; max-height: calc(60vh - 120px); padding-right:6px; border:1px solid rgba(255,255,255,0.1); border-radius:8px;">
            <!-- Table injected by JS -->
          </div>
          <div style="display:flex; gap:8px; justify-content:center; margin-top:8px;">
            <button id="btnBackFromLadder" style="padding: 8px 14px; background: #666; color: white; border:none; border-radius:6px; cursor:pointer;">Back</button>
          </div>
        </div>

        
<div id="lobbyTimer"></div>
<div id="lobbyStatus"></div>
<input id="pseudoInput" maxlength="10" placeholder="" type="text"/>
<br/>
<div id="lobbyBtnRow" style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:10px;">
<button id="lobbyJoin"></button>
<button id="btnJoinLobbyList" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#49c749; color:#fff; cursor:pointer; margin-top:7px;">Join lobby</button>
<button id="btnCreateLobby" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#49c749; color:#fff; cursor:pointer; margin-top:7px;">Create lobby</button>
</div>
<!-- Ladder button (same size as main buttons, violet) -->
<div id="ladderBtnRow" style="display:flex; justify-content:center; margin-top:8px;">
  <button id="btnLadder" style="font-size:18px; padding:7px 32px; border-radius:8px; border:none; background:#7a3df0; color:#fff; cursor:pointer; margin-top:7px;">Ladder</button>
</div>
<br/>
<div id="authBtnRow" style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
  <button id="btnLogin" style="padding:8px 16px; border:none; border-radius:8px; background:#2a6aff; color:#fff; cursor:pointer;">Log in</button>
  <button id="btnSignup" style="padding:8px 16px; border:none; border-radius:8px; background:#4f4; color:#000; cursor:pointer;">Sign up</button>
  <button id="btnLogout" style="display:none; padding:8px 16px; border:none; border-radius:8px; background:#b00020; color:#fff; cursor:pointer;">Sign out</button>
  <button id="btnSettings" style="display:none; padding:8px 16px; border:none; border-radius:8px; background:#666; color:#fff; cursor:pointer;">Settings</button>
</div>

<!-- Auth Modals -->
<div id="authModalOverlay" style="display:none; position:fixed; inset:0; background:#000a; z-index:9998; align-items:center; justify-content:center;"></div>
<div id="authModal" style="display:none; position:fixed; inset:0; z-index:9999; align-items:center; justify-content:center;">
  <div id="authModalBox" style="background:#1b1b20; border-radius:14px; padding:18px 20px; width:min(92vw, 420px); margin:auto; box-shadow:0 10px 40px #000a;">
    <div id="authModalTitle" style="font-weight:700; font-size:20px; margin-bottom:10px;">Auth</div>
    <div id="authModalBody"></div>
    <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:14px;">
      <button id="authCancel" style="padding:8px 14px; border:0; border-radius:8px; background:#555; color:#fff; cursor:pointer;">Cancel</button>
      <button id="authSubmit" style="padding:8px 14px; border:0; border-radius:8px; background:#2a6aff; color:#fff; cursor:pointer;">Submit</button>
    </div>
  </div>
</div>

<div id="langSelectRow"></div>
</div>
</div>
<button id="shopBtn" style="display: flex; align-items: center; position: fixed; right: 20px; bottom: 52px; z-index: 21; background: #232; color: #fff; border-radius: 13px; border: none; font-size: 22px; padding: 10px 26px 10px 19px; box-shadow: 0 2px 14px #0006; cursor: pointer; gap: 13px; transition: background 0.17s;" title="Upgrades">
<img alt="Upgrades" src="/icons/cart.svg" style="width: 27px; height: 27px; margin-right: 8px; filter: brightness(1.25) drop-shadow(0 2px 5px #0006);"/>
	  SHOP
	</button>
<!-- ==== BARRE D'ACHATS STRUCTURES (au-dessus du SHOP) ==== -->
<div id="buildBar" style="position:fixed; right:20px; bottom:122px; z-index:10006; display:flex; gap:10px; flex-direction:column; align-items:flex-end;">
<!-- R√©duction/affichage de la barre de construction + Auto-fire -->
<button id="toggleBuildUI" style="align-self:flex-end; margin-bottom:8px; padding:6px 10px;
           border-radius:10px; border:1px solid #444; background:#1c1c1f;
           color:#ddd; font-weight:700; cursor:pointer; box-shadow:0 2px 8px #0007;" title="R√©duire/Afficher les boutons">
    ‚Äì
  </button>
<!-- === AUTO-FIRE TOGGLE BUTTON (au-dessus des 4 blocs) === -->
<button id="autoFireBtn" style="display:flex; align-items:center; gap:10px;
           padding:8px 14px; border-radius:12px; border:2px solid #4a1111;
           background:#5a2226; color:#f1d6d6; font-weight:700; letter-spacing:0.3px;
           box-shadow:0 2px 10px #0007; cursor:pointer; user-select:none;">
<span style="width:10px;height:10px;border-radius:50%;background:#742f36;box-shadow:0 0 8px #000 inset;"></span>
<span id="autoFireLabel">Auto fire OFF</span>
</button>
<!-- /AUTO-FIRE TOGGLE -->
<!-- Conteneur horizontal des 4 tuiles -->
<div id="buildTiles" style="display:flex; gap:10px; flex-wrap:wrap;">
<!-- Grande tourelle -->
<button class="build-tile" data-tip="Tourelle (HP: 500, D√©g√¢ts: 10, Cadence: 1/s)" data-type="T" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#d33;border:2px solid #3a0b0b;box-shadow:0 2px 8px #0007; position:relative;">
<div style="position:absolute; left:50%; top:50%; width:16px; height:16px; background:#000; transform:translate(-50%,-50%); border-radius:2px;"></div>
</div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$1000 ‚Ä¢ 1/s ‚Ä¢ 10 dmg</div>
</button>
<!-- Big-tourelle -->
<button class="build-tile" data-tip="Big-tourelle (HP: 2500, D√©g√¢ts: 25, Cadence: 2/s)" data-type="G" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#b48cff;border:2px solid #2b1b3a;box-shadow:0 2px 8px #0007; position:relative;">
<div style="position:absolute; left:50%; top:50%; width:16px; height:16px; background:#000; transform:translate(-50%,-50%); border-radius:2px;"></div>
</div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$5000</div>
</button>
<!-- Mini-tourelle -->
<button class="build-tile" data-tip="Mini-tourelle (HP: 200, D√©g√¢ts: 5, Cadence: 1 tir / 2s)" data-type="t" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#3aa6ff;border:2px solid #0b1b2a;box-shadow:0 2px 8px #0007; position:relative;">
<div style="position:absolute; left:50%; top:50%; width:16px; height:16px; background:#000; transform:translate(-50%,-50%); border-radius:2px;"></div>
</div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$250</div>
</button>
<!-- Mur (barricade) -->
<button class="build-tile" data-tip="Mur (HP: 500)" data-type="B" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#7b4b2a;border:2px solid #000;box-shadow:0 2px 8px #0007;"></div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$100</div>
</button>
<!-- Porte -->
<button class="build-tile" data-tip="Porte (HP: 500)" data-type="D" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
<div style="width:42px;height:42px;background:#a57b4a;border:2px solid #000;box-shadow:0 2px 8px #0007;"></div>
<div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$200</div>
</button>
</div>
<!-- Tooltip hover -->
<div id="buildTooltip" style="display:none; position:absolute; right:0; bottom:70px; max-width:260px; background:#111c; color:#fff; font-size:13px; padding:8px 10px; border-radius:8px; box-shadow:0 4px 18px #000a; pointer-events:none; white-space:nowrap;"></div>
</div>
<div id="shopModal" style="display:none; position:fixed; right:34px; bottom:90px; background:#181e19ee; border-radius:18px; box-shadow:0 8px 28px #000c; padding:18px 16px 16px 16px; width:360px; max-height:calc(100dvh - 120px); overflow:hidden;">
<button id="shopClose" style="position:absolute; right:17px; top:10px; background:none; border:none; color:#fff; font-size:26px; cursor:pointer; filter:drop-shadow(0 2px 6px #0009);">‚úï</button>
<div style="font-size:26px; margin-bottom:15px; display:flex; align-items:center; gap:10px;">
<img alt="Upgrades" src="/icons/cart.svg" style="width:30px; filter:brightness(1.2); vertical-align:middle;"/>
<span id="shopTitleText">UPGRADES</span>
</div>
<div id="shopUpgrades">
<!-- Ici viendront les lignes d‚Äôam√©liorations √† l‚Äô√©tape suivante -->
<div style="color:#fff6; font-size:17px; margin-top:18px;">Boutique √† venir¬†: <i>Affichage des am√©liorations ici √† l‚Äô√©tape 3</i></div>
</div>
</div>
<div id="versionBox"></div>
<script>window.GAME_VERSION = "1.0.0";</script>
<div id="waveMessage"></div>
<script src="/socket.io/socket.io.js"></script>
<script>
// === Global orientation caches ===
window.prevPlayerPos = {};
window.lastPlayerAngle = {};
window.prevZombiePos = {};
window.lastZombieAngle = {};

const socket = io({ transports: ['polling','websocket'] });
console.log("üì° Tentative de connexion au serveur Socket.IO");
socket.on("connect", () => {
  console.log("‚úÖ Connect√© au serveur Socket.IO. ID:", socket.id);
  try {
    socket.emit("clientHello", {
      v: (window.GAME_VERSION || "1.0.0"),
      tz: (Intl.DateTimeFormat().resolvedOptions().timeZone || "?")
    });
  } catch (e) {}

  try {
    let __gid = 0, __tok = '';
    try { __gid = Number(localStorage.getItem('zombi_host_game') || '0'); } catch(_) {}
    try { __tok = String(localStorage.getItem('zombi_host_token') || ''); } catch(_) {}
    if (__gid && __tok) {
      socket.emit('reclaimHost', { gameId: __gid, token: __tok }, function(res){
        try { console.log('[reclaimHost]', res); } catch(_) {}
      });
    }

  // Try to reclaim previous lobby seat (non-host) if we have a saved lobby id + pseudo
  try {
    var __last_gid = 0, __last_pseudo = '';
    try { __last_gid = Number(localStorage.getItem('zombi_last_gid') || '0'); } catch(_){}
    try { __last_pseudo = String(localStorage.getItem('zombi_last_pseudo') || localStorage.getItem('zombi_pseudo') || '').trim(); } catch(_){}
    if (__last_gid && __last_pseudo) {
      socket.emit('reclaimPlayer', { gameId: __last_gid, pseudo: __last_pseudo }, function(res){
        try { console.log('[reclaimPlayer]', res); } catch(_){}
      });
    }
  } catch(_) {}
  } catch (_) {}
});
socket.on("disconnect", (reason) => {
  console.warn("‚ùå D√©connect√© du serveur. Raison:", reason);
});
socket.on("connect_error", (err) => {
  console.error("‚ö†Ô∏è Erreur de connexion √† Socket.IO:", err);
});
// Global guards to prevent any crash from bubbling up and blanking the page
window.addEventListener('error', function(e){ try { console.error('Global error:', e && e.message, e); } catch(_){} });
window.addEventListener('unhandledrejection', function(e){ try { console.error('Unhandled rejection:', e && e.reason); } catch(_){} });

// LOBBY STATE LOGS

socket.on("lobbyUpdate", (data) => {
  try {
    console.log("üì• [SOCKET] Re√ßu lobbyUpdate:", data);
    window.lobbyData = data;

      try {
        var pseudoEl = document.getElementById('pseudoInput');
        var mePseudo = pseudoEl ? String(pseudoEl.value || '') : '';
        if (mePseudo && data && data.players) {
          for (var sid in data.players) {
            var p = data.players[sid];
            if (p && String(p.pseudo||'') === mePseudo) {
              window.__candidateSid = sid;
              try { localStorage.setItem('zombi_candidate_sid', sid); } catch(_){}
              break;
            }
          }
        }
      } catch(_){}

    // Persist last known lobby id (only while lobby not yet started)
    if (data && !data.started && typeof data.id !== "undefined") {
      try { localStorage.setItem('zombi_last_gid', String(data.id)); } catch(_){}
    }
  } catch (e) { try { console.error(e); } catch(_){} }
});

socket.emit("requestLobbyState");
console.log("üì§ [SOCKET] Emit requestLobbyState");

// JOIN BUTTON
if (lobbyJoin) {
  lobbyJoin.addEventListener("click", () => {
    const pseudo = pseudoInput.value;
    console.log("üë§ Bouton JOIN cliqu√©. Pseudo saisi:", pseudo);
    try{ var now=Date.now(); if (typeof window.__joinLockTs==='number' && (now-window.__joinLockTs)<1200){ debugWarn('‚õî join re-entry blocked (A)', (now-window.__joinLockTs),'ms'); return; } window.__joinLockTs=now; var btn=document.getElementById('lobbyJoin'); if(btn){ btn.disabled=true; btn.dataset.clicked='1'; setTimeout(function(){ try{btn.disabled=false;}catch(_){}} , 3000);} }catch(_){}
if (!pseudo) return;
  });
}

// TIMER & UI DEBUG
setInterval(() => {
  if (typeof lobbyData !== "undefined") {
    console.log("‚è≥ Lobby Timer:", lobbyData.timeLeft, " | Players:", lobbyData.count);
  }
}, 5000);

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script src="/translations.js">
window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script>
// Safe translation accessor and singleton helper.
// Avoids "Identifier 'trLoc' has already been declared" if scripts reload.
(function(){
  if (!window.trLoc) {
    window.trLoc = function(key, fallback){
      try {
        var lang = (typeof window.currentLang === 'string' && window.currentLang) || (navigator.language||'en').slice(0,2);
        var pack = (window.TRANSLATIONS && window.TRANSLATIONS[lang]) || (window.TRANSLATIONS && window.TRANSLATIONS['en']) || {};
        return (pack && pack[key]) || (fallback || key);
      } catch(e){ return fallback || key; }
    };
  }
})();
</script>

<script>
  if (typeof TRANSLATIONS === "undefined") { window.TRANSLATIONS = { fr: {}, en: {} }; }

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<!-- === Mobile Build Buttons === -->
<div class="mobile-build" id="mobile-build">
<button aria-label="Construire Mur (B)" class="mb-btn" data-type="B">Mur</button>
<button aria-label="Construire Porte (D)" class="mb-btn" data-type="D">Porte</button>
<button aria-label="Construire Mini-Tourelle (t)" class="mb-btn" data-type="t">Mini-T</button>
<button aria-label="Construire Grande Tourelle (T)" class="mb-btn" data-type="T">Tourelle</button>
</div>
<style>
  /* Mobile only */
  
	 @media (max-width: 768px) and (orientation: portrait) {
	  .mobile-build { 
		display: none !important; 
	  }
	}
  @media (max-width: 768px) {
	.mobile-build {
	  position: fixed;
	  left: 50%;
	  bottom: calc(env(safe-area-inset-bottom, 0px) + 96px); /* marge iOS + au-dessus du Shop */
	  transform: translateX(-50%);
	  display: grid;
	  grid-template-columns: repeat(4, auto);
	  gap: 10px;
	  padding: 10px 12px;
	  background: rgba(0,0,0,0.35);
	  backdrop-filter: blur(6px);
	  border-radius: 14px;
	  z-index: 10007; /* sup√©rieur au Shop */
	  user-select: none;
	}
 .mb-btn {
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      background: #222;
      color: #fff;
    }
    .mobile-build .mb-btn:active {
      transform: translateY(1px);
    }
  }

  /* Desktop: hide */
  @media (min-width: 769px) {
    .mobile-build { display: none; }
  }
</style>
<!-- === /Mobile Build Buttons === -->
<script>
// === Toggle (r√©duire/afficher) la barre Auto-Fire + 4 constructions ===
let BUILD_UI_COLLAPSED = (localStorage.getItem('buildUICollapsed') === '1');

function applyBuildUICollapse() {
  const autoBtn = document.getElementById('autoFireBtn');
  const tiles = document.getElementById('buildTiles');
  const tgl = document.getElementById('toggleBuildUI');
  if (!tgl) return;
  if (BUILD_UI_COLLAPSED) {
    if (autoBtn) autoBtn.style.display = 'none';
    if (tiles) tiles.style.display = 'none';
    tgl.textContent = '+';
    tgl.title = 'Afficher les boutons';
  } else {
    if (autoBtn) autoBtn.style.display = 'flex';
    if (tiles) tiles.style.display = 'flex';
    tgl.textContent = '‚Äì';
    tgl.title = 'R√©duire les boutons';
  }
  // repositionne si besoin pour mobile
  if (typeof positionShopUI === 'function') {
    positionShopUI();
  }
}

(function initBuildUIToggle(){
  const tgl = document.getElementById('toggleBuildUI');
  if (!tgl) return;
  tgl.addEventListener('click', () => {
    BUILD_UI_COLLAPSED = !BUILD_UI_COLLAPSED;
    localStorage.setItem('buildUICollapsed', BUILD_UI_COLLAPSED ? '1' : '0');
    applyBuildUICollapse();
  }, {passive:true});
  tgl.addEventListener('touchstart', (e) => {
    e.preventDefault();
    BUILD_UI_COLLAPSED = !BUILD_UI_COLLAPSED;
    localStorage.setItem('buildUICollapsed', BUILD_UI_COLLAPSED ? '1' : '0');
    applyBuildUICollapse();
  }, {passive:false});
  applyBuildUICollapse();
})();
// === /Toggle build UI ===

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script>
/* SWAP_G_T_IN_BUILD */
document.addEventListener('DOMContentLoaded', function(){
  const cont = document.getElementById('buildTiles');
  if (!cont) return;
  const g = cont.querySelector('.build-tile[data-type="G"]');
  const t = cont.querySelector('.build-tile[data-type="T"]');
  if (g && t && g.nextElementSibling !== t) {
    cont.insertBefore(g, t);
  }
});

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script>
/* TURRET_UPGRADE_CLIENT */
let myTurretUp = { t:0, T:0, G:0 };
function turretUpgradeBaseAdd(type){ return type==='t'?5: (type==='T'?10:25); }
function turretBaseDamage(type){ return type==='t'?5: (type==='T'?10:25); }
function turretBonusFromLevels(type, lvl){
  const a = turretUpgradeBaseAdd(type);
  if (lvl<=0) return 0;
  return a * (Math.pow(1.1, lvl) - 1) / 0.1;
}
function computeTurretDamageDisplay(type){
  const base = turretBaseDamage(type);
  const bonus = turretBonusFromLevels(type, myTurretUp[type]||0);
  return Math.round(base + bonus);
}

// Cooldown display
const turretCooldownUntil = { t:0, T:0, G:0 };
socket.on('turretCooldown', (p)=>{
  if (!p || !p.type) return;
  turretCooldownUntil[p.type] = p.until || 0;
});
// Tooltip damage update
// --- Wall/Door place cooldown (shared) ---
let blockCooldownUntil = 0;
socket.on('blockCooldown', (p)=>{
  try { blockCooldownUntil = (p && p.until) ? p.until : 0; } catch(_) { blockCooldownUntil = 0; }
});
const buildTilesCont = document.getElementById('buildTiles');
if (buildTilesCont){
  buildTilesCont.querySelectorAll('.build-tile').forEach(btn=>{
    btn.addEventListener('mouseenter', ()=>{
      const type = btn.getAttribute('data-type');
      const tip0 = btn.getAttribute('data-tip') || '';
      if (['t','T','G','B','D'].includes(type)){
      const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']) || {};
      const names = (tr.turretType || {});
      const hpLabel = tr.hpShort || 'HP';
      const dmgLabel = tr.damage || 'Damage';
      const rateLabel = tr.fireRate || 'Fire rate';
      const baseHP = { T:500, t:200, G:2500, B:500, D:500 };
      let name = (type==='B') ? (tr.buildWall || 'Wall') : (type==='D') ? (tr.buildDoor || 'Door') : (names[type] || 'Turret'); name = upperFirstLocalized(name);
      let tip;
      if (type==='B' || type==='D') {
        tip = name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ')';
      } else {
        const rate = (type==='T') ? '1' : (type==='G') ? '2' : '0.5';
        const dmg = computeTurretDamageDisplay(type);
        tip = name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ', ' + dmgLabel + ': ' + dmg + ', ' + rateLabel + ': ' + rate + ((TRANSLATIONS[currentLang]||TRANSLATIONS['en']).perSec||'/s') + ')';
      }
      const tEl = document.getElementById('buildTooltip'); if (tEl){ tEl.textContent = tip; }
    }
    }, {passive:true});
  });
}
setInterval(()=>{
  document.querySelectorAll('#buildTiles .build-tile').forEach(btn=>{
    const type = btn.getAttribute('data-type');
    const priceLabel = btn.querySelector('div:nth-child(2)');
    let cd = btn.querySelector('.cd-label');
    if (!cd){
      cd = document.createElement('div');
      cd.className = 'cd-label';
      cd.style.fontSize = '11px';
      cd.style.color = '#ff9';
      cd.style.marginTop = '2px';
      btn.appendChild(cd);
    }
    
    if (['t','T','G'].includes(type)){
      const rem = Math.max(0, turretCooldownUntil[type] - Date.now());
      cd.textContent = rem > 0 ? (Math.ceil(rem/1000)+'s') : '';
    }
    else if (type === 'B' || type === 'D') {
      const rem = Math.max(0, blockCooldownUntil - Date.now());
      cd.textContent = rem > 0 ? (Math.ceil(rem/1000)+'s') : '';
    } else {
      cd.textContent = (window.trLoc ? trLoc('rotateToPortrait', 'Rotate your device to portrait.') : 'Rotate your device to portrait.');
    }
  });
}, 500);

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<!-- perf overlay patch: sort by consumption desc and 1s refresh -->
<script>
window.addEventListener('beforeunload', function(){
  try{
    if (window.socket && window.socket.connected && window.lobbyData && window.lobbyData.manual && !window.lobbyData.started && window.lobbyData.hostId === socket.id){
      socket.emit('hostBackManual', function(){});
    }
  }catch(_){}
});
</script>

<script>
(function(){
  if (!window || !window.__DEV_PERF) return;
  const wanted = [
    'CPU/Update',
    'Map','Structures','Bullets','Turrets','Zombies','Players','AimLine','MoneyTexts','BuildPreview','Light','HUD','Other'
  ];
  const DEV = window.__DEV_PERF;
  DEV.intervalMs = 1000;        // refresh every 1s
  DEV._lastRender = DEV._lastRender || 0;
  DEV._forceNext = DEV._forceNext || false;

  DEV.renderOverlay = function(extraCounts){
    const now = (performance && performance.now) ? performance.now() : Date.now();
    const box = document.getElementById('devPerfPanel');
    if (!box) return;
    if (!this.on) { box.style.display='none'; return; }
    if (!this._lastRender) this._lastRender = 0;
    if (!this._forceNext && (now - this._lastRender) < this.intervalMs) return;
    this._forceNext = false;
    this._lastRender = now;

    const total = Math.max(0.001, this.lastFrameMs);
    const lines = [];
    lines.push('‚Äî GPU/CPU profiler ‚Äî');
    lines.push(`Frame ~ ${total.toFixed(1)} ms (${Math.round(1000/total)} FPS)`);
    if (extraCounts) {
      const cls = [
        `Zombies:${extraCounts.z||0}`,
        `Turrets:${extraCounts.t||0}`,
        `Players:${extraCounts.p||0}`,
        `Bots:${extraCounts.b||0}`,
        `Bullets:${extraCounts.bul||0}`,
        `Structures:${extraCounts.s||0}`,
        `Lasers:${extraCounts.l||0}`,
        `Map:${extraCounts.mapw||0}x${extraCounts.maph||0}`,
      ];
      lines.push(cls.join(' ‚Ä¢ '));
    }
    lines.push('');

    // build and sort entries by ms desc
    const entries = wanted.map(k => ({
      k,
      ms: (this.ema && this.ema[k]) ? this.ema[k] : 0,
      tag: (k === 'CPU/Update') ? 'CPU' : 'GPU'
    })).sort((a,b)=> b.ms - a.ms);

    for (const e of entries) {
      const pct = Math.min(999, (e.ms / total) * 100);
      lines.push(`${e.k}: ${e.tag} = ${pct.toFixed(1)}% (${e.ms.toFixed(2)}ms)`);
    }

    box.textContent = lines.join('\n');
    box.style.display='block';
  };
})();

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<!-- dev-perf-restore-patch -->
<script>
(function(){"use strict";
  if (!window.__DEV_PERF) window.__DEV_PERF = {
    on: false,
    ema: Object.create(null),
    lastFrameMs: 16.7,
    add(name, ms){ if(Number.isFinite(ms)) this.ema[name]=(this.ema[name]||0)+0.2*(ms-(this.ema[name]||0)); },
    setFrame(ms){ this.lastFrameMs = this.lastFrameMs + 0.2 * (ms - this.lastFrameMs); }
  };
  const DEV = window.__DEV_PERF;
  DEV.intervalMs = 1000;
  DEV._lastRender = DEV._lastRender || 0;
  DEV._forceNext = !!DEV._forceNext;
  const WANTED = ['CPU/Update','Map','Structures','Bullets','Turrets','Zombies','Players','AimLine','MoneyTexts','BuildPreview','Light','HUD','Other'];
  const orig = typeof DEV.renderOverlay === 'function' ? DEV.renderOverlay.bind(DEV) : null;
  DEV.renderOverlay = function(extraCounts) { 
    const now = (performance && performance.now) ? performance.now() : Date.now();
    const box = document.getElementById('devPerfPanel'); if (!box) return;
    if (!this.on) { box.style.display = 'none'; return; }
    if (!this._lastRender) this._lastRender = 0;
    if (!this._forceNext && (now - this._lastRender) < this.intervalMs) return;
    this._forceNext = false; this._lastRender = now;
    const total = Math.max(0.001, this.lastFrameMs);
    const lines = [];
    lines.push('‚Äî GPU/CPU profiler ‚Äî');
    lines.push(`Frame ~ ${total.toFixed(1)} ms (${Math.round(1000/total)} FPS)`);
    if (extraCounts) {
      const cls = [
        `Zombies:${extraCounts?.z||0}`,
        `Turrets:${extraCounts?.t||0}`,
        `Players:${extraCounts?.p||0}`,
        `Bots:${extraCounts?.b||0}`,
        `Bullets:${extraCounts?.bul||0}`,
        `Structures:${extraCounts?.s||0}`,
        `Lasers:${extraCounts?.l||0}`,
        `Map:${extraCounts?.mapw||0}x${extraCounts?.maph||0}`,
      ];
      lines.push(cls.join(' ‚Ä¢ '));
    }
    lines.push('');
    const entries = WANTED.map(k=>({ k, ms: (this.ema && this.ema[k]) ? this.ema[k] : 0, tag: (k==='CPU/Update')?'CPU':'GPU' })).sort((a,b)=> b.ms - a.ms);
    for (const e of entries) {
      const pct = Math.min(999, (e.ms / total) * 100);
      lines.push(`${e.k}: ${e.tag} = ${pct.toFixed(1)}% (${e.ms.toFixed(2)}ms)`);
    }
    box.textContent = lines.join('\n');
    box.style.display = 'block';
    if (orig) try { orig(extraCounts); } catch(_){}
  };
  if (!window.__DEV_PERF__iBound) {
    window.__DEV_PERF__iBound = true;
    window.addEventListener('keydown', function(e){
      const k = e && (e.key||e.code);
      if ((k==='i' || k==='I') && (typeof myPseudo==='string') && myPseudo==='Myg') {
        DEV.on = !DEV.on;
        DEV._forceNext = true;
        try { DEV.renderOverlay(null); } catch(_){}
      }
    }, {passive:true});
  }
})();

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;
</script>
<script>
  

  
  // === Early globals for sprites & orientation ===
  // Provide globals before any game loop starts to avoid TDZ issues
  window.recentShootDir = window.recentShootDir || new Map();
  // Default sprite base rotation: images face DOWN; we need RIGHT at angle 0 => -90deg
  const SHOOT_DIR_TTL_MS = 650; // keep facing target between bullets (<=500ms gap)
  window.SPRITE_BASE_ROT = (typeof window.SPRITE_BASE_ROT === 'number') ? window.SPRITE_BASE_ROT : -Math.PI/2;
  const recentShootDir = window.recentShootDir;

  if (typeof window.playerImg === 'undefined') {
    window.playerImg = new Image();
    window.playerImg.src = '/stv.png';
  }
  if (typeof window.zombieImg === 'undefined') {
    window.zombieImg = new Image();
    window.zombieImg.src = '/zm.png';
  }
window.addEventListener('contextmenu', e => e.preventDefault(), { passive: false });
    // --- LANG/LOBBY ---
    const LANGS = [
      { code: 'en', flag: 'gb.png', label: 'English' },
      { code: 'cn', flag: 'cn.png', label: '‰∏≠Êñá' },
      { code: 'ru', flag: 'ru.png', label: '–†—É—Å—Å–∫–∏–π' },
      { code: 'es', flag: 'es.png', label: 'Espa√±ol' },
      { code: 'pt', flag: 'pt.png', label: 'Portugu√™s' },
      { code: 'de', flag: 'de.png', label: 'Deutsch' },
      { code: 'jp', flag: 'jp.png', label: 'Êó•Êú¨Ë™û' },
      { code: 'fr', flag: 'fr.png', label: 'Fran√ßais' },
      { code: 'pl', flag: 'pl.png', label: 'Polski' },
      { code: 'kr', flag: 'kr.png', label: 'ÌïúÍµ≠Ïñ¥' }
    ];
    function getDefaultLang() { return "en"; }
    let currentLang = getDefaultLang();
    window.currentLang = currentLang; let lobbyData = { started: false, count: 0, max: 6, timeLeft: 30, players: {} };
    let lobbyJoined = false, lobbyStarted = false;
    function initLobbyTexts() {
      updateLobbyTexts();
      pseudoInput.placeholder = TRANSLATIONS[currentLang].enterPseudo;
      lobbyJoin.textContent = TRANSLATIONS[currentLang].join;
    }
    function updateLobbyTexts() {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
            const _max = Number((lobbyData && lobbyData.max)) || 6;
      let _count = 0;
      try {
        if (lobbyData && typeof lobbyData.players === 'object' && lobbyData.players) {
          _count = Object.keys(lobbyData.players).length;
        } else if (lobbyData && Array.isArray(lobbyData.players)) {
          _count = lobbyData.players.length;
        } else if (typeof lobbyData.count !== 'undefined') {
          _count = Number(lobbyData.count) || 0;
        }
      } catch(_){ _count = Number(lobbyData && lobbyData.count) || 0; }
      lobbyPlayers.textContent = `${tr.playersInGame} : ${_count}/${_max}`;
      lobbyTimer.textContent = `${tr.timeLeft} : ${lobbyData.timeLeft}s`;
      const readyCount = Object.values(lobbyData.players).filter(p=>p.ready).length;
      lobbyStatus.textContent = `${tr.waitingStart} (${readyCount} ${tr.playersReady}${readyCount>1?'s':''})`;
    }
    function updateUITexts() {
  function applyJoinLabel(){
    const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
    const el = document.getElementById('lobbyJoin');
    if (!el) return;
    el.textContent = lobbyJoined ? (tr.waiting || 'Waiting') : (tr.join || 'Join');
  }

  const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];

  // Title and basics
  const lobbyTitleEl = document.getElementById('lobbyTitle');
  if (lobbyTitleEl) lobbyTitleEl.innerHTML = `<b>${tr.zombination}</b>`;
  if (pseudoInput) pseudoInput.placeholder = tr.enterPseudo || '';
  if (lobbyJoin) lobbyJoin.textContent = lobbyJoined ? (tr.waiting || 'Waiting') : (tr.join || 'Join'); applyJoinLabel();

  // Death screen
  const deathTitle = document.getElementById('deathTitle');
  if (deathTitle) deathTitle.textContent = tr.youDied || 'You died!';
  const btnReplay = document.getElementById('btnReplay');
  if (btnReplay) btnReplay.textContent = tr.replay || 'Replay';
  if (typeof updateLobbyTexts === 'function' && !lobbyStarted) { updateLobbyTexts(); }

  // Main menu & lobby buttons / headers
  const btnJoinLobbyList = document.getElementById('btnJoinLobbyList');
  if (btnJoinLobbyList) btnJoinLobbyList.textContent = tr.joinLobby || 'Join lobby';
  const btnCreateLobby = document.getElementById('btnCreateLobby');
  if (btnCreateLobby) btnCreateLobby.textContent = tr.createLobby || 'Create lobby';
  const btnStartManual = document.getElementById('btnStartManual');
  if (btnStartManual) btnStartManual.textContent = tr.start || 'Start';
  const btnBackFromManual = document.getElementById('btnBackFromManual');
  if (btnBackFromManual) btnBackFromManual.textContent = tr.back || 'Back';
  const btnBackFromList = document.getElementById('btnBackFromList');
  if (btnBackFromList) btnBackFromList.textContent = tr.back || 'Back';
  const manualLobbyTitle = document.getElementById('manualLobbyTitle');
  if (manualLobbyTitle) {
    // Keep number if already set "Lobby #X"
    const current = manualLobbyTitle.textContent || '';
    const num = (current.match(/\d+/) || [null])[0];
    manualLobbyTitle.textContent = (tr.lobby || 'Lobby') + (num ? (' #' + num) : '');
  }
  const manualLobbyNote = document.getElementById('manualLobbyNote');
  if (manualLobbyNote) manualLobbyNote.textContent = tr.onlyCreatorStart || 'Only the creator can start.';
  const joinLobbyTitle = document.getElementById('joinLobbyTitle');
  if (joinLobbyTitle) joinLobbyTitle.textContent = tr.availableLobbies || 'Available lobbies';

  // Shop button + modal header
  const shopBtn = document.getElementById('shopBtn');
  if (shopBtn) {
    shopBtn.title = tr.shop || 'Shop';
    // Recompose inner content with cart icon + label
    shopBtn.innerHTML = `<img alt="${tr.shop || 'Shop'}" src="/icons/cart.svg" style="width: 27px; height: 27px; margin-right: 8px; filter: brightness(1.25) drop-shadow(0 2px 5px #0006);"/>` + (tr.shop || 'Shop');
  }
  const shopTitleText = document.getElementById('shopTitleText');
  if (shopTitleText) shopTitleText.textContent = tr.shop || 'Shop';

  try { if (typeof updateAutoFireBtnUI === 'function') updateAutoFireBtnUI(); } catch(e){}

  // Mobile build buttons
  try {
    document.querySelectorAll('.mobile-build .mb-btn').forEach(btn => {
      const type = btn.getAttribute('data-type');
      if (!type) return;
      if (type === 'B') { btn.textContent = tr.buildWall || btn.textContent; btn.setAttribute('aria-label', (tr.buildWall || btn.textContent) + ' (B)'); }
      else if (type === 'D') { btn.textContent = tr.buildDoor || btn.textContent; btn.setAttribute('aria-label', (tr.buildDoor || btn.textContent) + ' (D)'); }
      else if (type === 't') { btn.textContent = tr.buildMiniTurret || btn.textContent; btn.setAttribute('aria-label', (tr.buildMiniTurret || btn.textContent) + ' (t)'); }
      else if (type === 'T') { btn.textContent = tr.buildTurret || btn.textContent; btn.setAttribute('aria-label', (tr.buildTurret || btn.textContent) + ' (T)'); }
    });
  } catch(e){}
    
  try { if (typeof renderManualPlayers === 'function') renderManualPlayers(); } catch(e){}
  try { if (typeof translateEmptySlotsInManualLobby === 'function') translateEmptySlotsInManualLobby(); } catch(e){}

// Ultra-robust: ensure empty placeholders in manual lobby reflect current language instantly
window.translateEmptySlotsInManualLobby = function(){
  try {
    var tr = (window.TRANSLATIONS && (window.TRANSLATIONS[window.currentLang] || window.TRANSLATIONS['en'])) || {};
    var label = tr.emptySlot || 'empty';
    var container = document.getElementById('manualLobbyPlayers');
    if (!container) return;
    // Build a set of all known "empty" labels from the translation packs (cached)
    if (!window.__knownEmptyLabels) {
      var known = new Set(['empty']);
      try {
        var T = window.TRANSLATIONS || {};
        Object.keys(T).forEach(function(k){
          var v = T[k] && T[k].emptySlot;
          if (v) known.add(String(v).trim());
        });
      } catch(_){}
      window.__knownEmptyLabels = known;
    }
    var knownSet = window.__knownEmptyLabels;
    // Replace any cell that currently shows an old empty label
    var cells = container.querySelectorAll('td, div, span, button');
    cells.forEach(function(el){
      var txt = (el.textContent || '').trim();
      if (!txt || knownSet.has(txt)) {
        el.textContent = label;
      }
    });
  } catch(_){}
};;
}
const langSelectRow = document.getElementById('langSelectRow');
    function renderLangFlags() {
      langSelectRow.innerHTML = '';
      LANGS.forEach(lang => {
        const img = document.createElement('img');
        img.src = `/flags/${lang.flag}`;
        img.alt = lang.label;
        img.title = lang.label;
        img.className = 'langFlag' + (lang.code === currentLang ? ' selected' : '');
        img.onclick = () => {
          if (currentLang !== lang.code) {
            currentLang = lang.code;
            window.currentLang = currentLang; renderLangFlags(); updateUITexts(); try { if (typeof translateEmptySlotsInManualLobby === 'function') translateEmptySlotsInManualLobby(); } catch(e){} try { if (typeof renderManualPlayers === 'function') renderManualPlayers(); } catch(e) {}; drawHUD();
          }
        };
        langSelectRow.appendChild(img);
      });
    }
    const pseudoInput = document.getElementById('pseudoInput');
	pseudoInput.addEventListener('input', function() {
	  this.value = this.value.replace(/[^a-zA-Z0-9]/g, '');
	});

    
    // Ensure global access to inputs/buttons for all handlers
    try {
      if (typeof window !== 'undefined') {
        if (typeof pseudoInput !== 'undefined' && pseudoInput) window.pseudoInput = pseudoInput;
        var lobbyJoin = document.getElementById('lobbyJoin');
        if (lobbyJoin) window.lobbyJoin = lobbyJoin;
      }
    } catch(_){}
renderLangFlags(); initLobbyTexts(); updateUITexts(); try { if (typeof translateEmptySlotsInManualLobby === 'function') translateEmptySlotsInManualLobby(); } catch(e){}

    // --- JEU ---
    

window.socket = socket;
window.__reloading = window.__reloading || false;
function hardReload(){
  if (window.__reloading) return;
  window.__reloading = true;
  try { if (socket && socket.connected) socket.disconnect(); } catch(e){}
  try { location.reload(); } catch(e){}
  setTimeout(function(){ try { location.replace(location.href); } catch(e){} }, 60);
}

window.__reloading = false;

// When a manual lobby is closed by its host, simulate Back for everyone
socket.on('lobbyClosed', function(){ try{ showMain(); window.lobbyJoined=false; if (pseudoInput){ pseudoInput.disabled=false; if(window.myPseudo) pseudoInput.value=window.myPseudo; } try{ updateButtonsDisabled(); }catch(_){}}catch(_){} });
socket.on('forceReload', function(){
  if (window.__reloading) return;
  window.__reloading = true;
  try { if (socket && socket.connected) socket.disconnect();
socket.on('playerDisconnected', function(sid){
  try {
    var ld = window.lobbyData || {};
    if (ld && ld.manual && !ld.started && ld.hostId && ld.hostId === sid) {
      try{ showMain(); window.lobbyJoined=false; if (pseudoInput){ pseudoInput.disabled=false; if(window.myPseudo) pseudoInput.value=window.myPseudo; } try{ updateButtonsDisabled(); }catch(_){}}catch(_){}
    }
  } catch(e){}
});
 } catch(e){}
  try { location.reload(); } catch(e){}
  setTimeout(function(){ try { location.replace(location.href); } catch(e){} }, 60);
});

// === Mouvement: envoi c√¥t√© serveur avec limitation de fr√©quence ===
let __lastMoveEmit = 0;
/**
 * @param {{x:number, y:number}} move - vecteur de d√©placement normalis√©
 */
function emitMoveThrottled(move){
  try{
    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    if (!socket || !socket.connected) return;
    if (now - __lastMoveEmit < 40) return; // ~25/s max
    __lastMoveEmit = now;
    socket.emit('moveDir', { x: move.x||0, y: move.y||0 });
  }catch(e){
    // √©vite de casser la boucle de jeu si quelque chose cloche
  }
}

// Listen result from turret upgrade and refresh UI/HUD
socket.on('upgradeTurretResult', function(res){
  const msg = document.getElementById('turretUpgradesMsg');
  if (res && res.ok) {
    if (typeof myTurretUp === 'object' && res.type) { myTurretUp[res.type] = res.level || 0; }
    if (typeof res.newMoney === 'number') { myMoney = res.newMoney; }
    if (msg) {
      const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']);
      const types = (tr.turretType || {});
      const typeLabel = types[res.type] || res.type;
      const tpl = tr.turretUpgradeSuccess || 'Upgrade {type} lvl {level} succeeded. Money: ${money}';
      msg.textContent = tpl.replace('{type}', String(typeLabel)).replace('{level}', String(res.level||0)).replace('{money}', String(res.newMoney||0));
      msg.style.color = '#9f9';
    }
    if (typeof window !== 'undefined' && typeof window.refreshShop === 'function') window.refreshShop();
    if (typeof renderShopUpgrades === 'function') renderShopUpgrades();
    if (typeof drawHUD === 'function') drawHUD();
  } else {
    if (msg) {
      const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']);
      msg.textContent = (res && res.reason === 'not_enough_money') ? (tr.notEnoughMoney || "Not enough money.") : (tr.actionImpossible || "Action impossible.");
      msg.style.color = '#f99';
    }
  }
});
let currentRound = 1;
let playersHealth = {};
let zombies = {};
let bullets = {};
let turretLasers = [];
const turretAngleCache = new Map(); // key: "turret_c_r" -> { ang, t }

// ---- Perf caches (par frame) ----
let FRAME_ID = 0;
let ZOMBIES_FRAME = [];
let ZOMBIES_FRAME_ID = -1;

// port√©e max (monde) √† laquelle une tourelle cherche une cible
const TURRET_TARGET_MAX_DIST = 500;
const TURRET_TARGET_MAX_DIST2 = TURRET_TARGET_MAX_DIST * TURRET_TARGET_MAX_DIST;

// Met √† jour la liste plate des zombies une seule fois par frame
function refreshZombiesFrame() {
  if (ZOMBIES_FRAME_ID !== FRAME_ID) {
    // Array ‚Äúplat‚Äù (√©vite Object.values() X fois)
    ZOMBIES_FRAME = [];
    for (const z of Object.values(zombies)) {
      // on peut ignorer les morts si jamais pr√©sents
      if (!z || z.hp <= 0) continue;
      ZOMBIES_FRAME.push(z);
    }
    ZOMBIES_FRAME_ID = FRAME_ID;
  }
}

const TURRET_ANGLE_TTL_MS = 350;    // (√©tait 180) ‚Äî moins d'oscillation des canons
const TURRET_RECALC_MIN_MS = 120;   // throttle: pas plus d'un recalcul/120 ms par tourelle
const turretAngleNextAt = new Map(); // key: "turret_c_r" -> timestamp autoris√© pour prochain calcul
let zombiesRemaining = 0;
let waveTotalZombies = 0;
let waveKilledThisWave = 0;
let structures = null;
let structHPGrid = null;

socket.on('stateUpdate', (payload) => {
  if (!payload) return;

  if (payload.zombies)        zombies = payload.zombies;
  if (payload.bullets)        bullets = payload.bullets;
  if (payload.playersHealth)  playersHealth = Object.assign({}, playersHealth, payload.playersHealth);
  try {
    if (!__centeredOnPlayerOnce && myId && playersHealth && playersHealth[myId] && isNum(playersHealth[myId].x) && isNum(playersHealth[myId].y)) {
      __centeredOnPlayerOnce = true;
      __lastValidMyPos = {x: playersHealth[myId].x, y: playersHealth[myId].y};
      centerCameraOn(playersHealth[myId].x, playersHealth[myId].y);
      try { debugLog('üéØ centered on first valid myPos from stateUpdate'); } catch(_){}
    }
  } catch(_){}

  if (typeof payload.round === 'number') currentRound = payload.round;

  // Apply destroyed structures
  if (Array.isArray(payload.destroyedStructures)) {
    payload.destroyedStructures.forEach(({ tx, ty }) => {
      if (structures?.[ty]) structures[ty][tx] = null;
      if (structHPGrid?.[ty]) structHPGrid[ty][tx] = 0;
    });
  }

  // Update HP overlay grid
  if (payload.structuresHP) {
    structHPGrid = payload.structuresHP;
  }

  // Replace/merge structures grid
  if (payload.structures) {
    const grid = payload.structures;
    const rows = grid.length || 0;
    const cols = rows ? (grid[0]?.length || 0) : 0;

    structures = Array.from({ length: rows }, (_, y) =>
      Array.from({ length: cols }, (_, x) => {
        const cell = grid[y][x];
        if (!cell || cell === 0) return null;

        const hpFromGrid = structHPGrid?.[y]?.[x];
        const previousHP = structures?.[y]?.[x]?.hp;
        function __baseHP(type){ switch(type){ case 'T': return 500; case 't': return 200; case 'G': return 2500; case 'B': case 'D': return 500; default: return 200; } }

        if (typeof cell === 'object') {
          const type = cell.type;
          let hp = (typeof cell.hp === 'number') ? cell.hp : ((typeof hpFromGrid === 'number' && hpFromGrid > 0) ? hpFromGrid : ((typeof previousHP === 'number' && previousHP > 0) ? previousHP : __baseHP(type)));
          if (hp <= 0) return null;
          return { type, hp, placedBy: cell.placedBy };
        }

        if (typeof cell === 'string') {
          const type = cell;
          let hp = (typeof hpFromGrid === 'number' && hpFromGrid > 0) ? hpFromGrid : ((typeof previousHP === 'number' && previousHP > 0) ? previousHP : __baseHP(type));
          if (hp <= 0) return null;
          return { type, hp };
        }

        return null;
      })
    );
  } else if (structHPGrid && structures) {
    // Apply HP overlay to existing structures
    const rows = Math.min(structHPGrid.length, structures.length);
    for (let y = 0; y < rows; y++) {
      const cols = Math.min(structHPGrid[y]?.length || 0, structures[y]?.length || 0);
      for (let x = 0; x < cols; x++) {
        const cell = structures[y][x];
        if (!cell) continue;
        const hp = structHPGrid[y][x];
        if (typeof hp === 'number') {
          if (hp <= 0) structures[y][x] = null; else cell.hp = hp;
        }
      }
    }
  }

  drawHUD();

  // Lightweight FPS meter
  try {
    if (!window.__fps_last) window.__fps_last = performance.now();
    const now = performance.now();
    const dt = now - window.__fps_last;
    window.__fps_last = now;
    if (!window.__fps_s) { window.__fps_s = 0; window.__fps_n = 0; }
    window.__fps_s += dt; window.__fps_n += 1;
    if (window.__fps_s >= 500) {
      const fps = Math.round(1000 / (window.__fps_s / window.__fps_n));
      const el = document.getElementById('fpsCounter'); if (el) el.textContent = 'FPS: ' + fps;
      window.__fps_s = 0; window.__fps_n = 0;
    }
  } catch(e) {}
});

	
	setInterval(() => {
	  if (socket && socket.connected) {
		socket.emit('clientPing');
	  }
	}, 10000); // Toutes les 8 secondes (tu peux mettre 10000 pour 10s)
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

// --- Pinch-to-zoom (mobile) ---
(function(){
  let pinchActive = false;
  let startDist = 0;
  let startPinchScale = 1;

  function touchInRect(t, rect){
    if (!rect) return false;
    const x = t.clientX, y = t.clientY;
    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
  }
  function touchInAnyJoystick(t){
    try{
      const r1 = (moveJoy && moveJoy.joyDiv) ? moveJoy.joyDiv.getBoundingClientRect() : null;
      const r2 = (aimJoy  && aimJoy.joyDiv)  ? aimJoy.joyDiv.getBoundingClientRect()  : null;
      return touchInRect(t, r1) || touchInRect(t, r2);
    }catch(_){ return false; }
  }
  function computeDistance(t0, t1){
    const dx = t0.clientX - t1.clientX;
    const dy = t0.clientY - t1.clientY;
    return Math.hypot(dx, dy);
  }

  function onTouchStart(e){
    if (!isMobileDevice) return;
    if (e.touches && e.touches.length === 2){
      const t0 = e.touches[0], t1 = e.touches[1];
      // Do not start pinch if any finger is on a joystick
      if (touchInAnyJoystick(t0) || touchInAnyJoystick(t1)) return;
      pinchActive = true;
      startDist = computeDistance(t0, t1);
      startPinchScale = pinchScale;
      e.preventDefault();
    }
  }
  function onTouchMove(e){
    if (!pinchActive) return;
    if (!(e.touches && e.touches.length >= 2)) { pinchActive = false; return; }
    const t0 = e.touches[0], t1 = e.touches[1];
    // Cancel pinch if user moves into joystick
    if (touchInAnyJoystick(t0) || touchInAnyJoystick(t1)) { pinchActive = false; return; }
    const d = computeDistance(t0, t1);
    if (d > 0 && startDist > 0){
      const raw = startPinchScale * (d / startDist);
      pinchScale = Math.max(MIN_PINCH, Math.min(MAX_PINCH, raw));
      // Apply new scale and recentre
      updateRenderScale();
      try { updateCamera && updateCamera(); } catch(_){}
      e.preventDefault();
    }
  }
  function onTouchEnd(e){
    if (!pinchActive) return;
    if (!(e.touches && e.touches.length >= 2)) {
      pinchActive = false;
    }
  }

  // Attach on the canvas to avoid global interference
  try{
    canvas.addEventListener('touchstart', onTouchStart, { passive: false });
    canvas.addEventListener('touchmove', onTouchMove, { passive: false });
    canvas.addEventListener('touchend', onTouchEnd, { passive: false });
    canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });
  }catch(_){}
})();


// --- Debug/robust helpers ---
let __centeredOnPlayerOnce = false;
let __lastValidMyPos = {x:0, y:0};
function isNum(v){ return typeof v === 'number' && isFinite(v); }
function centerCameraOn(x, y){
  try{
    const viewW = canvas.width / renderScale;
    const viewH = canvas.height / renderScale;
    cameraX = Math.max(0, Math.min(x - viewW/2, MAP_COLS*TILE_SIZE - viewW));
    cameraY = Math.max(0, Math.min(y - viewH/2, MAP_ROWS*TILE_SIZE - viewH));
  }catch(e){}
}

// Shots direction cache (owner -> recent aim)
// recentShootDir is provided globally earlier

	let mapBuffer = null, mapBufCtx = null, mapBufW = 0, mapBufH = 0;
    const hudAlive = document.getElementById('hudAlive');
    const hudZombies = document.getElementById('hudZombies');
    const hudKills = document.getElementById('hudKills');
    const hudRound = document.getElementById('hudRound');
    const hudHP = document.getElementById('hudHP');
	const hudMoney = document.getElementById('hudMoney');
	let myMoney = 0;
	

const UPGRADES = [
  {
    id: "maxHp",
    label: "+10% Vie max",
    desc: "Augmente les PV max.",
    icon: "/icons/heart.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 100,
    statLabel: "PV max",
    format: v => v + " PV"
  },
  {
    id: "speed",
    label: "+10% Vitesse",
    desc: "D√©place-toi plus vite.",
    icon: "/icons/speed.svg",
    getValue: (base, level) => +(base * Math.pow(1.1, level)).toFixed(1),
    baseValue: 40,
    statLabel: "Vitesse",
    format: v => v + " px/s"
  },
  {
    id: "regen",
    label: "R√©g√©n√©ration PV",
    desc: "Reg√©n√®re tes PV.",
    icon: "/icons/regen.svg",
    getValue: (base, level) => {
      if (level <= 10) return level;                 // 0..10 lin√©aire
      return +(10 * Math.pow(1.1, level - 10)).toFixed(2); // >10 : +10%/niv
    },
    baseValue: 0,
    statLabel: "R√©g√©n.",
    format: v => v + " PV/s"
  },
  {
    id: "damage",
    label: "+10% D√©g√¢ts",
    desc: "Tire plus fort.",
    icon: "/icons/bullet.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 10,
    statLabel: "D√©g√¢ts",
    format: v => v
  },
  {
    id: "goldGain",
    label: "+10% d'or gagn√©",
    desc: "Gagne plus d‚Äôor sur les zombies.",
    icon: "/icons/gold.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 10, // goldGain commence √† 10 c√¥t√© serveur
    statLabel: "$/zombie",
    format: (v) => {
      const min = Math.round(10 * (v / 10));
      const max = Math.round(20 * (v / 10));
      return `$${min}‚Äì${max}`;
    }
  }
];

	// Niveau des upgrades du joueur local (simul√© pour l‚Äôinstant)
	let myUpgrades = {
	  maxHp: 0,
	  speed: 0,
	  regen: 0,
	  damage: 0,
	  goldGain: 0
	};

const waveMessage = document.getElementById('waveMessage');

function resetWaveCounters(total = 0) {
  waveTotalZombies   = Number(total) || 0;
  waveKilledThisWave = 0;
  zombiesRemaining   = waveTotalZombies; // au d√©part, il reste tout le monde
  drawHUD();
}

    let myId = null, playerHealth = 100, isDead = false, myKills = 0, myPseudo = "";
  let isSpectator = false;
  let spectatorPos = { x: 0, y: 0 };
	let shootBlocked = false;
	let moneyFloatingTexts = []; // Pour stocker les "+$" √† afficher
	let buildMode = null;         // 'T' | 't' | 'B' | 'D' | null
	let buildHover = { tx: -1, ty: -1 }; // tuile survol√©e pendant le placement

	function curve(v) {
	  // 0.55 = plus sensible au centre (augmente si tu trouves encore trop mou)
	  const e = 0.55;
	  const s = Math.sign(v);
	  return s * Math.pow(Math.abs(v), e);
	}

    // D√©tection mobile
    function isMobile() { return /android|iphone|ipad|ipod|opera mini|iemobile|mobile/i.test(navigator.userAgent); }
    const isMobileDevice = isMobile();
	const HAS_POINTER = ('PointerEvent' in window);

	// === [ZOOM MOBILE PAYSAGE] ===
	let renderScale = 1;
// --- Mobile zoom management ---
let baseRenderScale = 1;   // auto-computed scale so halo touches screen edges
let pinchScale = 1;        // user pinch multiplier
const MIN_PINCH = 0.6;
const MAX_PINCH = 1.8;

	function updateRenderScale() {
  try {
    // Compute the 'base' scale that fits the visibility halo to screen edges
    if (!isMobileDevice) {
      baseRenderScale = 1;
      renderScale = baseRenderScale * pinchScale;
      return;
    }
    const VR = (typeof CLIENT_VIEW_RADIUS === 'number' && CLIENT_VIEW_RADIUS > 0) ? CLIENT_VIEW_RADIUS : 420;
    const cw = (canvas && canvas.width) || window.innerWidth || 0;
    const ch = (canvas && canvas.height) || window.innerHeight || 0;
    const minDim = Math.min(cw, ch);
    if (minDim > 0 && VR > 0) {
      baseRenderScale = minDim / (2 * VR);
    } else {
      baseRenderScale = 1;
    }
    renderScale = baseRenderScale * pinchScale;
  } catch(e) {
    try { console.warn('[updateRenderScale] error', e && (e.message||e)); } catch(_){}
  }
}

// Keep mobile zoom correct when the screen size/orientation changes
try {
  window.addEventListener('resize', function(){
    try { updateRenderScale(); updateCamera && updateCamera(); } catch(_){}
  }, { passive: true });
  window.addEventListener('orientationchange', function(){
    try { setTimeout(function(){ updateRenderScale(); updateCamera && updateCamera(); }, 0); } catch(_){}
  }, { passive: true });
} catch(_){}

updateRenderScale();
    const TILE_SIZE = 40;
    const PLAYER_RADIUS = 10;
    const ZOMBIE_RADIUS = 10;
	const CLIENT_VIEW_RADIUS = 420;
    let map = [], MAP_ROWS = 0, MAP_COLS = 0;

// === Helpers map/structures (client) ===
function worldToTile(x, y) {
  return { tx: Math.floor(x / TILE_SIZE), ty: Math.floor(y / TILE_SIZE) };
}
function isWallAt(tx, ty) {
  if (!map || ty < 0 || ty >= MAP_ROWS || tx < 0 || tx >= MAP_COLS) return true;
  return map[ty][tx] === 1;
}

function losBlockedForPlayer(x0, y0, x1, y1) {
  const dx = x1 - x0, dy = y1 - y0;
  const dist = Math.hypot(dx, dy);
  if (dist < 1) return false;
  const steps = Math.ceil(dist / 8);
  for (let s = 1; s < steps; s++) {
    const ix = x0 + (dx * s / steps);
    const iy = y0 + (dy * s / steps);
    const { tx, ty } = worldToTile(ix, iy);
    if (isWallAt(tx, ty)) return true;
  }
  return false;
}
function structAtWorld(x, y) {
  if (!structures) return null;
  const { tx, ty } = worldToTile(x, y);
  if (ty < 0 || ty >= MAP_ROWS || tx < 0 || tx >= MAP_COLS) return null;
  return structures[ty]?.[tx] || null;
}
function isSolidForZombieClient(struct) {
  // pour la ligne de vue c√¥t√© client : tout ce qui a des PV bloque
  return struct && struct.hp > 0; // B, D, T‚Ä¶
}
function losBlockedForZombieClient(x0, y0, x1, y1) {
  // √âchantillonnage plus grossier (‚âà 1 pas par tuile) : bien plus l√©ger en rafale
  const dx = x1 - x0, dy = y1 - y0;
  const dist = Math.hypot(dx, dy);
  if (dist < 1) return false;

  // Un pas ‚âà taille de tuile (√©vite ~5‚Äì8x plus d'it√©rations qu'avant)
  const STEP = TILE_SIZE; // 40px chez toi
  const steps = Math.max(1, Math.ceil(dist / STEP));

  for (let s = 1; s < steps; s++) {
    const ix = x0 + (dx * s / steps);
    const iy = y0 + (dy * s / steps);
    const { tx, ty } = worldToTile(ix, iy);

    if (isWallAt(tx, ty)) return true;

    const st = structures?.[ty]?.[tx];
    if (st && st.hp > 0) return true; // toute structure avec PV bloque
  }
  return false;
}

function findTurretTargetAngle(turretKey, cxWorld, cyWorld) {
  const now = performance.now();

  // 1  Si on a un angle r√©cent, on le r√©utilise (cache TTL)
  const cached = turretAngleCache.get(turretKey);
  if (cached && (now - cached.t) <= TURRET_ANGLE_TTL_MS) {
    return cached.ang;
  }

  // 2  Throttle: on n'autorise un recalcul complet qu'√† partir d'un certain moment
  const nextAt = turretAngleNextAt.get(turretKey) || 0;
  if (now < nextAt && cached) {
    // encore trop t√¥t ‚Üí on garde l'angle pr√©c√©dent
    return cached.ang;
  }

  // 3  Cherche la cible la plus proche dans la port√©e, LOS avec pas par tuile
  let bestDist2 = Infinity;
  let bdx = 1, bdy = 0;

  // ZOMBIES_FRAME est rafra√Æchi une fois par frame (cf. √©tape 4 plus bas)
  for (let i = 0; i < ZOMBIES_FRAME.length; i++) {
    const z = ZOMBIES_FRAME[i];
    const dx = z.x - cxWorld;
    const dy = z.y - cyWorld;
    const d2 = dx*dx + dy*dy;

    if (d2 > TURRET_TARGET_MAX_DIST2) continue;

    if (d2 < bestDist2) {
      if (!losBlockedForZombieClient(cxWorld, cyWorld, z.x, z.y)) {
        bestDist2 = d2;
        bdx = dx; bdy = dy;
      }
    }
  }

  const ang = Math.atan2(bdy, bdx);

  // 4  M√©mos
  turretAngleCache.set(turretKey, { ang, t: now });
  turretAngleNextAt.set(turretKey, now + TURRET_RECALC_MIN_MS);

  return ang;
}

    let cameraX = 0, cameraY = 0;
    const keys = {};
    let mouseDown = false, mousePos = { x: 0, y: 0 };
    let aimDir = { x: 1, y: 0 }; // direction de vis√©e par d√©faut (droite)
	let lastAimDir = { x: 1, y: 0 };
	
	window.addEventListener('keydown', e => {
	  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
		e.preventDefault(); // √©vite le scroll de la page !
	  }
	  keys[e.key.toLowerCase()] = true;
	});
	window.addEventListener('keyup', e => {
	  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
		e.preventDefault();
	  }
	  keys[e.key.toLowerCase()] = false;
	});
	
window.addEventListener('mousedown', e => {
  if (buildMode) { e.preventDefault(); return; }   // ‚Üê ajoute √ßa
  const sm = document.getElementById('shopModal');
  if (sm && sm.style.display === 'block') return;
  mouseDown = e.button === 0;
});

    window.addEventListener('mouseup', e => { if (e.button === 0) mouseDown = false; });
    window.addEventListener('mousemove', e => {
      mousePos = { x: e.clientX, y: e.clientY };
      if (!isMobileDevice && myId && playersHealth[myId]) {
        const player = playersHealth[myId];
		aimDir = {
		  x: (cameraX + mousePos.x / renderScale) - player.x,
		  y: (cameraY + mousePos.y / renderScale) - player.y
		};
        let len = Math.hypot(aimDir.x, aimDir.y);
        if (len > 0) {
          aimDir.x /= len;
          aimDir.y /= len;
        }
      }
    });
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

function createMapBuffer() {
  if (!map || !map.length) return;

  mapBufW = MAP_COLS * TILE_SIZE;
  mapBufH = MAP_ROWS * TILE_SIZE;

  // (Re)cr√©e le canvas offscreen
  mapBuffer = document.createElement('canvas');
  mapBuffer.width  = mapBufW;
  mapBuffer.height = mapBufH;
  mapBufCtx = mapBuffer.getContext('2d');

  // Fond neutre (optionnel) : on laisse transparent, on ne dessine que les murs
  // Rendu des tuiles MURS une seule fois
  mapBufCtx.fillStyle = '#363636';
  for (let r = 0; r < MAP_ROWS; r++) {
    for (let c = 0; c < MAP_COLS; c++) {
      if (map[r][c] === 1) {
        mapBufCtx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }
  }
}

    // JOYSTICK PATCH MOBILE
    let moveJoy = null, aimJoy = null;
	let moveJoyVal = {x:0, y:0}, aimJoyVal = {x:0, y:0}; // valeurs normalis√©es [-1..1]
	
function createJoystick(container, baseX, baseY, id) {
  const size = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.23);
  const joyDiv = document.createElement('div');
  joyDiv.className = 'joystick-container';
  joyDiv.style.left = baseX + 'px';
  joyDiv.style.top = baseY + 'px';
  joyDiv.style.width = size + 'px';
  joyDiv.style.height = size + 'px';
  joyDiv.id = id;
  joyDiv.style.pointerEvents = 'auto';
  document.body.appendChild(joyDiv);

  const base = document.createElement('div');
  base.className = 'joystick-base';
  base.style.width = size + 'px';
  base.style.height = size + 'px';
  base.style.background = 'rgba(255,255,255,0.12)';
  base.style.borderRadius = '50%';
  base.style.position = 'absolute';
  base.style.left = '0px';
  base.style.top = '0px';
  base.style.pointerEvents = 'auto';
  joyDiv.appendChild(base);

  const stick = document.createElement('div');
  stick.className = 'joystick-stick';
  stick.style.width = (size * 0.52) + 'px';
  stick.style.height = (size * 0.52) + 'px';
  stick.style.background = 'rgba(160,255,240,0.45)';
  stick.style.borderRadius = '50%';
  stick.style.position = 'absolute';
  stick.style.left = (size * 0.24) + 'px';
  stick.style.top = (size * 0.24) + 'px';
  stick.style.pointerEvents = 'auto';
  joyDiv.appendChild(stick);

  return { joyDiv, base, stick, size };
}

function addJoystickHandlers(joy, which) {
  const size = joy.size;
  const radius = size / 2;
  const stickRadius = (size * 0.52) / 2;
  const center = { x: radius, y: radius };

  let activeId = null;

  function setVec(dx, dy) {
    const max = radius - stickRadius;
    const len = Math.hypot(dx, dy);

    // clamp visuel
    let nx = dx, ny = dy;
    if (len > max && len > 0) {
      nx = dx * (max / len);
      ny = dy * (max / len);
    }

    // position visuelle
    joy.stick.style.left = (center.x - stickRadius + nx) + "px";
    joy.stick.style.top  = (center.y - stickRadius + ny) + "px";

    // vecteur normalis√© [-1..1]
    const out = (max > 0) ? { x: nx / max, y: ny / max } : { x: 0, y: 0 };
    if (which === "move") moveJoyVal = out;
    else aimJoyVal = out;
  }

  function reset() {
    activeId = null;
    setVec(0, 0);
  }

  function localCoords(clientX, clientY) {
    const r = joy.joyDiv.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }

  function onDown(e) {
    if (activeId !== null) return;
    activeId = e.pointerId;
    joy.joyDiv.setPointerCapture(activeId);
    const p = localCoords(e.clientX, e.clientY);
    setVec(p.x - center.x, p.y - center.y);
    e.preventDefault();
  }

  function onMove(e) {
    if (e.pointerId !== activeId) return;
    const p = localCoords(e.clientX, e.clientY);
    setVec(p.x - center.x, p.y - center.y);
    e.preventDefault();
  }

  function onUp(e) {
    if (e.pointerId !== activeId) return;
    try { joy.joyDiv.releasePointerCapture(activeId); } catch {}
    reset();
    e.preventDefault();
  }

  // down sur toute la zone
  joy.joyDiv.addEventListener('pointerdown', onDown, { passive: false });
  joy.base.addEventListener('pointerdown', onDown, { passive: false });
  joy.stick.addEventListener('pointerdown', onDown, { passive: false });

  // move/up globaux
  window.addEventListener('pointermove', onMove, { passive: false });
  window.addEventListener('pointerup', onUp, { passive: false });
  window.addEventListener('pointercancel', onUp, { passive: false });

  reset();
}

	function addJoystickTouchHandlers(joy, which) {
	  const size = joy.size;
	  const radius = size / 2;
	  const stickRadius = (size * 0.52) / 2;
	  const center = { x: radius, y: radius };

	  let active = false;
	  let lastId = null;

	  function setVec(dx, dy) {
		const max = radius - stickRadius;
		const len = Math.hypot(dx, dy);
		let nx = dx, ny = dy;
		if (len > max && len > 0) {
		  nx = dx * (max / len);
		  ny = dy * (max / len);
		}
		joy.stick.style.left = (center.x - stickRadius + nx) + "px";
		joy.stick.style.top  = (center.y - stickRadius + ny) + "px";
		const out = (max > 0) ? { x: nx / max, y: ny / max } : { x: 0, y: 0 };
		if (which === "move") moveJoyVal = out;
		else aimJoyVal = out;
	  }

	  function reset() {
		active = false;
		lastId = null;
		setVec(0, 0);
	  }

	  function localCoords(clientX, clientY) {
		const r = joy.joyDiv.getBoundingClientRect();
		return { x: clientX - r.left, y: clientY - r.top };
	  }

	  function onStart(e) {
		if (active) return;
		const t = e.changedTouches ? e.changedTouches[0] : null;
		if (!t) return;
		active = true;
		lastId = t.identifier;
		const p = localCoords(t.clientX, t.clientY);
		setVec(p.x - center.x, p.y - center.y);
		e.preventDefault();
	  }

	  function onMove(e) {
		if (!active) return;
		const touches = e.changedTouches;
		for (let i = 0; i < touches.length; i++) {
		  const t = touches[i];
		  if (t.identifier !== lastId) continue;
		  const p = localCoords(t.clientX, t.clientY);
		  setVec(p.x - center.x, p.y - center.y);
		  e.preventDefault();
		  break;
		}
	  }

	  function onEnd(e) {
		if (!active) return;
		const touches = e.changedTouches;
		for (let i = 0; i < touches.length; i++) {
		  const t = touches[i];
		  if (t.identifier !== lastId) continue;
		  reset();
		  e.preventDefault();
		  break;
		}
	  }

	  // down sur toute la zone
	  joy.joyDiv.addEventListener('touchstart', onStart, { passive: false });
	  joy.base.addEventListener('touchstart', onStart, { passive: false });
	  joy.stick.addEventListener('touchstart', onStart, { passive: false });

	  // move/up globaux
	  window.addEventListener('touchmove', onMove, { passive: false });
	  window.addEventListener('touchend', onEnd, { passive: false });
	  window.addEventListener('touchcancel', onEnd, { passive: false });

	  reset();
	}

function setupJoysticks() {
  if (!isMobileDevice) return;

  // Nettoyage
  if (moveJoy && moveJoy.joyDiv) moveJoy.joyDiv.remove();
  if (aimJoy && aimJoy.joyDiv) aimJoy.joyDiv.remove();

  const padding = 36;
  const joySize = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.23);
  let joyY = window.innerHeight - joySize - padding;
  if (joyY < padding) joyY = padding;

  // Cr√©e les deux joysticks
  moveJoy = createJoystick(document.body, padding, joyY, "moveJoy");
  aimJoy  = createJoystick(document.body, window.innerWidth - joySize - padding, joyY, "aimJoy");

  // üëâ branchement selon le support
  if (HAS_POINTER) {
    addJoystickHandlers(moveJoy, "move");
    addJoystickHandlers(aimJoy,  "aim");
  } else {
    addJoystickTouchHandlers(moveJoy, "move");
    addJoystickTouchHandlers(aimJoy,  "aim");
  }

  // Repositionne l‚ÄôUI shop
  positionShopUI();
}

// ===== remplace enti√®rement cette fonction =====
function positionShopUI() {
  if (!isMobileDevice) return;
  const shopBtnEl   = document.getElementById('shopBtn');
  const shopModalEl = document.getElementById('shopModal');
  const buildBarEl  = document.getElementById('buildBar');
  if (!aimJoy || !aimJoy.joyDiv || !shopBtnEl) return;

  const isPortrait = window.matchMedia("(orientation: portrait)").matches;
  const joyRect = aimJoy.joyDiv.getBoundingClientRect();

  // --- Bouton SHOP au-dessus du joystick droit ---
  const btnGap = 20; // espace entre bouton et joystick
  shopBtnEl.style.position = "fixed";
  shopBtnEl.style.zIndex   = "10005";
  shopBtnEl.style.right    = (window.innerWidth - joyRect.right) + "px";
  shopBtnEl.style.bottom   = (window.innerHeight - joyRect.top) + btnGap + "px";

  // --- Panneau SHOP : align√© √† droite du joystick, et assez haut pour ne pas chevaucher ---
  if (shopModalEl) {
    const gap = isPortrait ? 28 : 12;
    const availableHeightAboveJoystick = Math.max(0, joyRect.top - gap);
    const margin = 10;

    const maxH = Math.max(180, Math.min(availableHeightAboveJoystick - margin, window.innerHeight - 2*margin));
    shopModalEl.style.maxHeight = maxH + "px";
    shopModalEl.style.overflowY = "auto";

    if (!isPortrait) {
      shopModalEl.style.minWidth = "300px";
      shopModalEl.style.maxWidth = Math.min(360, window.innerWidth - 20) + "px";
    }

    // ancrage horizontal √† droite du joystick
    shopModalEl.style.right = (window.innerWidth - joyRect.right + 14) + "px";

    // recalage vertical au-dessus du joystick
    let computedBottom = (window.innerHeight - joyRect.top) + gap;
    const minBottom = 8;
    const maxBottom = window.innerHeight - 120;
    if (computedBottom < minBottom) computedBottom = minBottom;
    if (computedBottom > maxBottom) computedBottom = maxBottom;
    shopModalEl.style.bottom = computedBottom + "px";
  }

  // --- ‚ù∂ NOUVEAU : positionner la barre de construction juste au-dessus du bouton SHOP ---
  if (buildBarEl) {
    // aligne horizontalement avec le bouton SHOP
    buildBarEl.style.position = "fixed";
    buildBarEl.style.right = shopBtnEl.style.right;

    // place la barre juste au-dessus du bouton SHOP (√©cart 12px)
    const btnBottomPx = parseFloat(shopBtnEl.style.bottom) || 0;
    const btnHeight   = shopBtnEl.offsetHeight || 56; // fallback si non rendu
    const gapAboveBtn = 12;
    buildBarEl.style.bottom = (btnBottomPx + btnHeight + gapAboveBtn) + "px";

    // priorit√© d‚Äôaffichage au-dessus du SHOP
    buildBarEl.style.zIndex = "10006";
  }
}

function drawMap() {
  if (!map || !map.length) return;
  // G√©n√®re le buffer si n√©cessaire (ou si tailles non pr√™tes)
  if (!mapBuffer || mapBufW !== MAP_COLS * TILE_SIZE || mapBufH !== MAP_ROWS * TILE_SIZE) {
    createMapBuffer();
  }
  if (!mapBuffer) return;

  // Calcule la portion visible (en coordonn√©es monde)
  const viewW = Math.ceil(canvas.width  / renderScale);
  const viewH = Math.ceil(canvas.height / renderScale);
  const sx = Math.floor(cameraX);
  const sy = Math.floor(cameraY);
  const sW = Math.min(viewW, mapBufW - sx);
  const sH = Math.min(viewH, mapBufH - sy);
  if (sW <= 0 || sH <= 0) return;

  // Dessine le morceau n√©cessaire du buffer √† la bonne position
  ctx.drawImage(
    mapBuffer,
    sx, sy, sW, sH,              // source rect (dans le buffer)
    sx - cameraX, sy - cameraY,  // destination (coord. monde ‚Üí apr√®s setTransform)
    sW, sH
  );
}

function drawStructures() {
  if (!structures) return;

  // Parcours des structures
  for (let row = 0; row < structures.length; row++) {
    for (let col = 0; col < structures[row].length; col++) {
      const cell = structures[row][col];
      if (!cell) continue; // Si pas de structure, on passe √† la suivante

      const x = col * TILE_SIZE - cameraX; // Calcul de la position en X
      const y = row * TILE_SIZE - cameraY; // Calcul de la position en Y

      // Dessiner la structure de base
      if (cell.type === 'B') {
        ctx.fillStyle = '#7b4b2a'; // Couleur du mur
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
      } else if (cell.type === 'D') {
        ctx.fillStyle = '#a57b4a'; // Couleur de la porte
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
      } else if (cell.type === 'T' || cell.type === 't') {
        const isBig = (cell.type === 'T');
        ctx.fillStyle = isBig ? '#d33' : '#3aa6ff'; // Couleur des tourelles
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = isBig ? '#3a0b0b' : '#0b1b2a';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
        
        // Dessiner le carr√© noir au centre de la tourelle
        const centerX = x + TILE_SIZE / 2;
        const centerY = y + TILE_SIZE / 2;
        ctx.fillStyle = '#000'; // Noir
        ctx.fillRect(centerX - 8, centerY - 8, 16, 16); // Dessiner un carr√© de 16px au centre
      }
      else if (cell.type === 'G') {
        ctx.fillStyle = '#b48cff';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#2b1b3a';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
        const centerX = x + TILE_SIZE / 2;
        const centerY = y + TILE_SIZE / 2;
        ctx.fillStyle = '#000';
        ctx.fillRect(centerX - 8, centerY - 8, 16, 16);
      }

    
      // --- Health bar for structures (walls/doors/turrets) ---
      let hp = 0, maxHp = 0;
      // Prefer object hp if >0, else grid hp >0, else previousHP >0, else default by type
      let rowArr = (typeof structHPGrid !== 'undefined' && Array.isArray(structHPGrid) && Array.isArray(structHPGrid[row])) ? structHPGrid[row] : null;
let hpFromGrid = (rowArr && typeof rowArr[col] === 'number') ? rowArr[col] : undefined;
let prevRowArr = (typeof structPrevHPGrid !== 'undefined' && Array.isArray(structPrevHPGrid) && Array.isArray(structPrevHPGrid[row])) ? structPrevHPGrid[row] : null;
let previousHP = (prevRowArr && typeof prevRowArr[col] === 'number') ? prevRowArr[col] : undefined;
      const defaultByType = (cell && cell.type)
        ? ((cell.type === 'B' || cell.type === 'D') ? 500 : (cell.type === 'T' ? 500 : (cell.type === 't' ? 200 : (cell.type === 'G' ? 2500 : 200))))
        : 0;
      if (cell && typeof cell.hp === 'number' && cell.hp > 0) hp = cell.hp;
      else if (typeof hpFromGrid === 'number' && hpFromGrid > 0) hp = hpFromGrid;
      else if (typeof previousHP === 'number' && previousHP > 0) hp = previousHP;
      else hp = defaultByType;
      // If no explicit cell.hp and no previous positive HP and grid HP < default, assume brand new => full default
      if (!(cell && typeof cell.hp === 'number' && cell.hp > 0) &&
          !(typeof previousHP === 'number' && previousHP > 0) &&
          (typeof hpFromGrid !== 'number' || hpFromGrid < defaultByType)) {
        hp = defaultByType;
      }
      maxHp = (cell && cell.type)
        ? ((cell.type === 'B' || cell.type === 'D') ? 500 : (cell.type === 'T' ? 500 : (cell.type === 't' ? 200 : (cell.type === 'G' ? 2500 : 0))))
        : 0;
      // Clamp: if hp non-positive (first frame after placement), show full bar
      if (hp <= 0 && maxHp > 0) hp = maxHp;
      if (maxHp > 0) {
        const ratio = Math.max(0, Math.min(1, hp / maxHp));
        const bw = TILE_SIZE - 8, bh = 5;
        ctx.fillStyle = '#000a';
        ctx.fillRect(x + 4, y - 8, bw, bh);
        ctx.fillStyle = ratio > 0.6 ? '#3f3' : (ratio > 0.3 ? '#fc3' : '#f33');
        ctx.fillRect(x + 4, y - 8, bw * ratio, bh);
      }
}
  }
}

	
function drawPlayers() {
  const me = (myId && playersHealth[myId]) ? playersHealth[myId] : null;
  const vx = me ? me.x : 0;
  const vy = me ? me.y : 0;
  const VIEW_MARGIN = 8;
  const R2 = (CLIENT_VIEW_RADIUS - VIEW_MARGIN) * (CLIENT_VIEW_RADIUS - VIEW_MARGIN);

  for (const id in playersHealth) {
    const p = playersHealth[id];
    if (!p || !p.alive) continue;

    // Culling autour du joueur local
    if (!isSpectator && id !== myId) {
      const dxv = p.x - vx, dyv = p.y - vy;
      if (dxv*dxv + dyv*dyv > R2) continue;
    }

    const screenX = p.x - cameraX;
    const screenY = p.y - cameraY;

    // --- Angle de vis√©e prioritaire si le joueur vient de tirer
    let angle = 0;
    const nowPerf = (typeof performance!=='undefined' && performance.now)?performance.now():Date.now();
    /* keep facing while holding fire */
    if (myId && playersHealth[myId] && mouseDown) {
      const angHold = Math.atan2(aimDir.y, aimDir.x);
      recentShootDir.set(myId, { ang: angHold, t: nowPerf });
    }

    const recent = recentShootDir.get(id);
    if (recent && (nowPerf - recent.t) < (window.SHOOT_DIR_TTL_MS || SHOOT_DIR_TTL_MS)) {
      angle = recent.ang;
    } else {
      // Sinon, angle de d√©placement (avec m√©moire si √† l'arr√™t)
      const prev = prevPlayerPos[id];
      if (prev) {
        const dx = p.x - prev.x, dy = p.y - prev.y;
        const sp2 = dx*dx + dy*dy;
        if (sp2 > 0.01) {
          angle = Math.atan2(dy, dx);
          lastPlayerAngle[id] = angle;
        } else {
          angle = (lastPlayerAngle[id] !== undefined) ? lastPlayerAngle[id] : 0;
        }
      } else {
        angle = (lastPlayerAngle[id] !== undefined) ? lastPlayerAngle[id] : 0;
      }
    }
    prevPlayerPos[id] = { x: p.x, y: p.y };

    // Dessin sprite joueur
    const size = PLAYER_RADIUS * 2 * 2; // un peu plus grand que le cercle
    const half = size / 2;
    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.rotate(angle + (window.SPRITE_BASE_ROT||0));
    ctx.drawImage(playerImg, -half, -half, size, size);
    ctx.restore();

    // Pseudo + barre de vie (inchang√©)
    ctx.font = "bold 17px Arial";
    ctx.textAlign = "center";
    ctx.fillStyle = "#aad8ff";
    ctx.fillText(p.pseudo || "Joueur", screenX, screenY - PLAYER_RADIUS - 22);
    drawHealthBar(
      screenX,
      screenY - PLAYER_RADIUS - 13,
      p.health,
      p.maxHealth || 100,
      30
    );
  }
}
	
	

function drawZombies() {
  if (!myId || !playersHealth[myId]) return;
  const me = playersHealth[myId];
  const vx = me.x, vy = me.y;

  const VIEW_MARGIN = 8;
  const R2 = (CLIENT_VIEW_RADIUS - VIEW_MARGIN) * (CLIENT_VIEW_RADIUS - VIEW_MARGIN);

  for (const id in zombies) {
    const z = zombies[id];
    if (!z || z.hp <= 0) continue;

    const dxv = z.x - vx, dyv = z.y - vy;
    if (!isSpectator && (dxv*dxv + dyv*dyv) > R2) continue;

    const screenX = z.x - cameraX;
    const screenY = z.y - cameraY;

    // Angle bas√© sur d√©placement avec m√©moire
    let angle = 0;
    const prev = prevZombiePos[id];
    if (prev) {
      const dx = z.x - prev.x, dy = z.y - prev.y;
      const sp2 = dx*dx + dy*dy;
      if (sp2 > 0.01) {
        angle = Math.atan2(dy, dx);
        lastZombieAngle[id] = angle;
      } else {
        angle = (lastZombieAngle[id] !== undefined) ? lastZombieAngle[id] : 0;
      }
    } else {
      angle = (lastZombieAngle[id] !== undefined) ? lastZombieAngle[id] : 0;
    }
    prevZombiePos[id] = { x: z.x, y: z.y };

    const size = ZOMBIE_RADIUS * 2 * 2;
    const half = size / 2;
    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.rotate(angle + (window.SPRITE_BASE_ROT||0));
    ctx.drawImage(zombieImg, -half, -half, size, size);
    ctx.restore();

    // Barre de vie
    drawHealthBar(screenX, screenY - ZOMBIE_RADIUS - 10, z.hp, z.maxHp, 30);
  }
}

function drawBullets() {
  const nowPerf = (typeof performance!=='undefined' && performance.now)?performance.now():Date.now();
  const viewW = canvas.width / renderScale;
  const viewH = canvas.height / renderScale;

  // marge pour √©viter pop-in/out
  const M = 40;
  const minX = cameraX - M, maxX = cameraX + viewW + M;
  const minY = cameraY - M, maxY = cameraY + viewH + M;

  for (const id in bullets) {
    const b = bullets[id];
    // culling rapide
    if (b.x < minX || b.x > maxX || b.y < minY || b.y > maxY) continue;

    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = (b.owner === myId) ? 'yellow' : '#ff0';
    ctx.lineWidth = 3;
    ctx.moveTo(b.x - cameraX, b.y - cameraY);
    ctx.lineTo(
      b.x - cameraX - b.dx * 8,
      b.y - cameraY - b.dy * 8
    );
    ctx.stroke();
    ctx.restore();

    // Memorize last shooting direction per owner (used to orient sprites while shooting)
    if (b && typeof b.dx === 'number' && typeof b.dy === 'number' && b.owner) {
      const ang = Math.atan2(b.dy, b.dx);
      recentShootDir.set(b.owner, { ang, t: nowPerf });
    }
  }
}

function drawTurretLasers() {
  if (!turretLasers.length) return;

  const now = performance.now();
  const LIFE_MS = 60;                // (√©tait 80) ‚Äî persistance plus courte
  const MAX_LASERS_PER_FRAME = 60;   // (√©tait 150) ‚Äî cap plus strict pour √©viter les spikes

  // Trim √† l‚Äôavant si trop d‚Äôentr√©es (on garde les plus r√©centes)
  if (turretLasers.length > MAX_LASERS_PER_FRAME) {
    turretLasers = turretLasers.slice(turretLasers.length - MAX_LASERS_PER_FRAME);
  }

  ctx.save();
  ctx.lineWidth = 2;

  let w = 0; // compteur de traits vraiment dessin√©s
  for (let i = turretLasers.length - 1; i >= 0; i--) {
    const b = turretLasers[i];
    const age = now - b.t;
    if (age > LIFE_MS) {
      turretLasers.splice(i, 1);
      continue;
    }

    // Alpha simple, pas d'effets co√ªteux
    const alpha = 1 - (age / LIFE_MS);
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = b.color || '#fff';

    ctx.beginPath();
    ctx.moveTo(b.x0 - cameraX, b.y0 - cameraY);
    ctx.lineTo(b.x1 - cameraX, b.y1 - cameraY);
    ctx.stroke();

    if (++w >= MAX_LASERS_PER_FRAME) break; // s√©curit√©
  }

  ctx.restore();
}

	function drawMoneyFloatingTexts() {
	  const now = Date.now();
	  for (let i = moneyFloatingTexts.length - 1; i >= 0; i--) {
		const f = moneyFloatingTexts[i];
		const t = (now - f.time);
		if (t > f.duration) {
		  moneyFloatingTexts.splice(i, 1); // On le retire
		  continue;
		}
		// Position √©cran
		const screenX = f.x - cameraX;
		const screenY = f.y - cameraY + f.vy * t;

		ctx.save();
		ctx.globalAlpha = 1 - (t / f.duration); // Fade out progressif
		ctx.font = "bold 28px Arial";
		ctx.textAlign = "center";
		ctx.lineWidth = 3;
		ctx.strokeStyle = "#222";
		ctx.strokeText(`+${f.amount}$`, screenX, screenY);
		ctx.fillStyle = "#32ff72";
		ctx.fillText(`+${f.amount}$`, screenX, screenY);
		ctx.restore();
	  }
	}

	function drawHealthBar(x, y, current, max, width = null, height = 5) {
	  let w;
	  if (width !== null) {
		w = width;  // largeur fix√©e explicitement
	  } else {
		// largeur variable pour zombies, par exemple
		w = Math.max(30, Math.min(70, 30 + (max - 10) * 0.7));
	  }
	  const ratio = Math.max(0, Math.min(1, current / max));
	  ctx.fillStyle = '#111';
	  ctx.fillRect(x - w / 2, y, w, height);
	  ctx.fillStyle = (ratio < 0.4) ? "#e66" : "#8f8";
	  ctx.fillRect(x - w / 2, y, w * ratio, height);
	  ctx.strokeStyle = '#fff';
	  ctx.strokeRect(x - w / 2, y, w, height);
	}

function drawAimLine() {
  if (isSpectator) return;
  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  const player = playersHealth[myId];
  let dir = { x: 1, y: 0 };
  let show = false;

  if (isMobileDevice) {
    // üëâ m√™me logique que le tir mobile (avec curve)
    let len = Math.hypot(aimJoyVal.x, aimJoyVal.y);
    if (len > 0.06) {
      let ax = aimJoyVal.x / (len || 1);
      let ay = aimJoyVal.y / (len || 1);
      ax = curve(ax);
      ay = curve(ay);
      const n = Math.hypot(ax, ay);
      if (n > 0.0001) dir = { x: ax / n, y: ay / n }; // on renormalise pour tracer une ligne propre
      show = true;
    }
  } else {
    if (mouseDown) {
      let dx = (cameraX + mousePos.x / renderScale) - player.x;
      let dy = (cameraY + mousePos.y / renderScale) - player.y;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 3) {
        dir = { x: dx / dist, y: dy / dist };
        show = true;
      }
    }
  }

  if (!show) return;

  const length = 440;
  const screenX = player.x - cameraX;
  const screenY = player.y - cameraY;

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(screenX, screenY);
  ctx.lineTo(screenX + dir.x * length, screenY + dir.y * length);
  ctx.strokeStyle = 'rgba(255,255,0,0.66)';
  ctx.lineWidth = 2;
  ctx.shadowColor = 'yellow';
  ctx.shadowBlur = 7;
  ctx.stroke();
  ctx.restore();
}

// ‚Äî D√©tection de support 'evenodd' (une fois) ‚Äî
let CANVAS_EVENODD_OK = null;
function testEvenOddSupport() {
  try {
    const c = document.createElement('canvas');
    c.width = c.height = 8;
    const g = c.getContext('2d');

    // fond blanc
    g.fillStyle = '#fff';
    g.fillRect(0, 0, 8, 8);

    // on dessine un masque noir avec un trou "evenodd"
    g.fillStyle = '#000';
    g.beginPath();
    g.rect(0, 0, 8, 8);
    g.moveTo(4 + 2, 4); // √©vite artefacts
    g.arc(4, 4, 2, 0, Math.PI * 2, true);
    g.fill('evenodd');

    // si le trou a bien √©t√© cr√©√©, le pixel central n‚Äôest PAS noir
    const [r, gch, b, a] = g.getImageData(4, 4, 1, 1).data;
    return !(r === 0 && gch === 0 && b === 0 && a !== 0);
  } catch {
    return false;
  }
}

function drawLightMask() {
  if (isSpectator) return;
  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;

  // centre du joueur en coordonn√©es √©cran (identique PC)
  const p = playersHealth[myId];
  const screenX = (p.x - cameraX) * renderScale;
  const screenY = (p.y - cameraY) * renderScale;

  // ‚òÖ rayon du halo en pixels √âCRAN (monde 420 * zoom √©cran)
  const r = CLIENT_VIEW_RADIUS * renderScale; // ‚òÖ AJOUT

  // on passe en coordonn√©es √©cran pour l‚Äôoverlay (identique PC)
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  // ‚Äî init du test 'evenodd' une fois ‚Äî
  if (CANVAS_EVENODD_OK === null) {
    CANVAS_EVENODD_OK = testEvenOddSupport();
  }

  if (CANVAS_EVENODD_OK) {
    // ‚úÖ chemin standard (exactement comme PC)
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.beginPath();
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.moveTo(screenX + r, screenY);                 // ‚òÖ remplace CLIENT_VIEW_RADIUS par r
    ctx.arc(screenX, screenY, r, 0, Math.PI * 2, true); // ‚òÖ idem
    ctx.fill('evenodd');
    ctx.restore();
  } else {
    // üîÅ fallback mobile (visuellement identique) : on ‚Äúperfore‚Äù le trou
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const prevOp = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(screenX, screenY, r, 0, Math.PI * 2);      // ‚òÖ idem
    ctx.fill();
    ctx.globalCompositeOperation = prevOp;
    ctx.restore();
  }

  // on remet l‚Äôespace monde
  ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);
}

function update(deltaTime) {
  
    // Spectator: send movement intent to server so it can filter updates around our view
    try {
      if (window.socket) {
        const dir = { x: 0, y: 0 };
        if (keys['arrowup'] || keys['w']) dir.y -= 1;
        if (keys['arrowdown'] || keys['s']) dir.y += 1;
        if (keys['arrowleft'] || keys['a']) dir.x -= 1;
        if (keys['arrowright'] || keys['d']) dir.x += 1;
        socket.emit('spectatorMove', dir);
      }
    } catch(e) {}
if (isSpectator) {
    // D√©placement libre du spectateur (500 px/s)
    let mx = 0, my = 0;
    if (keys['arrowup'] || keys['w']) my -= 1;
    if (keys['arrowdown'] || keys['s']) my += 1;
    if (keys['arrowleft'] || keys['a']) mx -= 1;
    if (keys['arrowright'] || keys['d']) mx += 1;
    const len = Math.hypot(mx, my) || 1;
    const speed = 500; // px/sec
    spectatorPos.x += (mx/len) * speed * deltaTime;
    spectatorPos.y += (my/len) * speed * deltaTime;
    // Clamp aux limites de la carte
    const maxX = MAP_COLS * TILE_SIZE;
    const maxY = MAP_ROWS * TILE_SIZE;
    spectatorPos.x = Math.max(0, Math.min(spectatorPos.x, maxX));
    spectatorPos.y = Math.max(0, Math.min(spectatorPos.y, maxY));
    return;
  }
  if (isDead || !myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  let player = playersHealth[myId];
  let move = { x: 0, y: 0 };

  // ---- MOUVEMENT ----
  if (!isMobileDevice) {
    if (keys['arrowup'] || keys['w']) move.y -= 1;
    if (keys['arrowdown'] || keys['s']) move.y += 1;
    if (keys['arrowleft'] || keys['a']) move.x -= 1;
    if (keys['arrowright'] || keys['d']) move.x += 1;
  } else {
    const len = Math.hypot(moveJoyVal.x, moveJoyVal.y);
    if (len > 0.06) {
      let mx = moveJoyVal.x / (len || 1);
      let my = moveJoyVal.y / (len || 1);
      move.x = curve(mx);
      move.y = curve(my);
    }
  }

  // ‚ö†Ô∏è Remplacement de l'ancien "socket.emit('moveDir', move);" par :
  emitMoveThrottled(move);

  // ---- TIR ----
  let shooting = false;
  let shootDir = { x: 1, y: 0 };

  if (!isMobileDevice) {
    // ‚úÖ corrige avec / renderScale
    let dx = (cameraX + mousePos.x / renderScale) - player.x;
    let dy = (cameraY + mousePos.y / renderScale) - player.y;
    let len = Math.hypot(dx, dy);
    if (len > 3) shootDir = { x: dx / len, y: dy / len };
    shooting = mouseDown;
  } else {
    const len = Math.hypot(aimJoyVal.x, aimJoyVal.y);
    if (len > 0.06) {
      let ax = aimJoyVal.x / (len || 1);
      let ay = aimJoyVal.y / (len || 1);
      ax = curve(ax);
      ay = curve(ay);
      shootDir = { x: ax, y: ay };
      shooting = true;
    }
  }

  if (shooting) {
    const n = Math.hypot(shootDir.x, shootDir.y);
    if (n > 0.0001) lastAimDir = { x: shootDir.x, y: shootDir.y };
  }

  // --- AUTO-FIRE: cible visible la plus proche (dans le halo) ---
  if (AUTO_FIRE_ENABLED && !buildMode) {
    const sm = document.getElementById('shopModal');
    const shopOpen = sm && sm.style.display === 'block';
    if (!shopOpen && myId && playersHealth[myId] && playersHealth[myId].alive) {
      const p = playersHealth[myId];
      let best = null, bestD2 = Infinity;
      const ZSRC = (typeof ZOMBIES_FRAME !== 'undefined' && Array.isArray(ZOMBIES_FRAME) && ZOMBIES_FRAME.length)
        ? ZOMBIES_FRAME
        : Object.values(zombies || {});
      const r2 = CLIENT_VIEW_RADIUS * CLIENT_VIEW_RADIUS;
      for (const z of ZSRC) {
        if (!z || z.hp <= 0) continue;
        const dx = z.x - p.x, dy = z.y - p.y;
        const d2 = dx*dx + dy*dy;
        if (d2 > r2) continue;
        if (losBlockedForPlayer(p.x, p.y, z.x, z.y)) continue;
        if (d2 < bestD2) { bestD2 = d2; best = z; }
      }
      if (best) {
        const d = Math.sqrt(bestD2) || 1;
        shooting = true;
        shootDir = { x: (best.x - p.x) / d, y: (best.y - p.y) / d };
        lastAimDir = shootDir;
      }
    }
  }

  if (shooting && !shootBlocked) {
    shootBlocked = true;
    socket.emit('shoot', {
      targetX: player.x + shootDir.x * 120,
      targetY: player.y + shootDir.y * 120
    });
    setTimeout(() => { shootBlocked = false; }, 300);
  }
}

if (isMobileDevice) {
  canvas.addEventListener('pointerdown', (e) => {
    if (buildMode) return;
    if (e.clientX <= window.innerWidth * 0.5) return;
    if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;

    const p = playersHealth[myId];
    const dx = (cameraX + e.clientX / renderScale) - p.x;
    const dy = (cameraY + e.clientY / renderScale) - p.y;
    const d  = Math.hypot(dx, dy);
    const dir = d > 4 ? { x: dx / d, y: dy / d } : lastAimDir;

    if (!shootBlocked) {
      shootBlocked = true;
      socket.emit('shoot', {
        targetX: p.x + dir.x * 120,
        targetY: p.y + dir.y * 120
      });
      setTimeout(() => { shootBlocked = false; }, 300);
    }
  }, { passive: true });
}

// ---- Aide : √©cran -> monde -> tuile ----
function screenToWorldTile(clientX, clientY) {
  const wx = cameraX + clientX / renderScale;
  const wy = cameraY + clientY / renderScale;
  return {
    tx: Math.floor(wx / TILE_SIZE),
    ty: Math.floor(wy / TILE_SIZE)
  };
}

// Test d'intersection cercle-rectangle (client)
function circleIntersectsTileClient(cx, cy, cr, tx, ty) {
  const rx = tx * TILE_SIZE, ry = ty * TILE_SIZE;
  const closestX = Math.max(rx, Math.min(cx, rx + TILE_SIZE));
  const closestY = Math.max(ry, Math.min(cy, ry + TILE_SIZE));
  const dx = cx - closestX, dy = cy - closestY;
  return (dx*dx + dy*dy) <= cr*cr;
}
// Survol pour l'aper√ßu de placement
canvas.addEventListener('mousemove', (e) => {
  if (!buildMode) return;
  const { tx, ty } = screenToWorldTile(e.clientX, e.clientY);
  buildHover.tx = tx; buildHover.ty = ty;
}, { passive: true });

canvas.addEventListener('pointermove', (e) => {
  if (!buildMode) return;
  const { tx, ty } = screenToWorldTile(e.clientX, e.clientY);
  buildHover.tx = tx; buildHover.ty = ty;
}, { passive: true });

// Survol mobile pour l‚Äôaper√ßu de placement
canvas.addEventListener('touchmove', (e) => {
  if (!buildMode) return;
  const t = e.changedTouches && e.changedTouches[0];
  if (!t) return;
  const { tx, ty } = screenToWorldTile(t.clientX, t.clientY);
  buildHover.tx = tx; 
  buildHover.ty = ty;
}, { passive: true });

// ---- Placement sur mobile (touch) ----
// [patched] mobile touchstart immediate placement removed (replaced by drag-to-drop setup)


canvas.addEventListener('pointerdown', (e) => {
  if (!buildMode) return;
  if (e.pointerType && e.pointerType !== 'mouse') return; // ignore touch/pen to let mobile drag handle
e.preventDefault();
  e.stopPropagation();
  tryPlaceStructureAtCursor(e.clientX, e.clientY);
  mouseDown = false;
});


function drawBuildPreview() {
  if (!buildMode || buildHover.tx < 0 || buildHover.ty < 0) return;

  const tx = buildHover.tx, ty = buildHover.ty;
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) return;

  // rouge si bloqu√©, vert si OK
  const me = (myId && playersHealth[myId]) ? playersHealth[myId] : null;
  let blocked = isWallAt(tx, ty) || (structures?.[ty]?.[tx]);
  // Hors halo de visibilit√© (d√©sactiv√© en spectateur)
  if (me && !isSpectator) {
    const cx = (tx + 0.5) * TILE_SIZE;
    const cy = (ty + 0.5) * TILE_SIZE;
    const dx = me.x - cx, dy = me.y - cy;
    const R2 = (CLIENT_VIEW_RADIUS - 8) * (CLIENT_VIEW_RADIUS - 8);
    if ((dx*dx + dy*dy) > R2) blocked = true;
  }

  // collision avec entit√©s (joueurs/bots/zombies)
  if (!blocked) {
    for (const id in playersHealth) {
      const p = playersHealth[id]; if (!p || !p.alive) continue;
      if (circleIntersectsTileClient(p.x, p.y, PLAYER_RADIUS, tx, ty)) { blocked = true; break; }
    }
  }
  if (!blocked) {
    for (const zid in zombies) {
      const z = zombies[zid]; if (!z) continue;
      if (circleIntersectsTileClient(z.x, z.y, ZOMBIE_RADIUS, tx, ty)) { blocked = true; break; }
    }
  }

  const x = tx * TILE_SIZE - cameraX;
  const y = ty * TILE_SIZE - cameraY;

  ctx.save();
  ctx.globalAlpha = 0.5;
  // couleur selon le type
  if (buildMode === 'T') ctx.fillStyle = '#d33';
  else if (buildMode === 't') ctx.fillStyle = '#3aa6ff';
  else if (buildMode === 'B') ctx.fillStyle = '#7b4b2a';
  else if (buildMode === 'D') ctx.fillStyle = '#a57b4a';
  else if (buildMode === 'G') ctx.fillStyle = '#b48cff';
  else ctx.fillStyle = '#888';

  // pr√©visualisation
  ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
  ctx.strokeStyle = blocked ? '#ff3b3b' : '#34e05a';
  ctx.lineWidth = 2;
  ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
  ctx.restore();
}

function drawBuildPreview() {
  if (!buildMode || buildHover.tx < 0 || buildHover.ty < 0) return;

  const tx = buildHover.tx, ty = buildHover.ty;
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) return;

  // rouge si bloqu√©, vert si OK
  const me = (myId && playersHealth[myId]) ? playersHealth[myId] : null;
  let blocked = isWallAt(tx, ty) || (structures?.[ty]?.[tx]);

  // Hors halo de visibilit√© (d√©sactiv√© en spectateur)
  if (me && !isSpectator) {
    const cx = (tx + 0.5) * TILE_SIZE;
    const cy = (ty + 0.5) * TILE_SIZE;
    const dx = me.x - cx, dy = me.y - cy;
    const R2 = (CLIENT_VIEW_RADIUS - 8) * (CLIENT_VIEW_RADIUS - 8);
    if ((dx*dx + dy*dy) > R2) blocked = true;
  }

  // collision avec entit√©s (joueurs/bots/zombies)
  if (!blocked) {
    for (const id in playersHealth) {
      const p = playersHealth[id]; if (!p || !p.alive) continue;
      if (circleIntersectsTileClient(p.x, p.y, PLAYER_RADIUS, tx, ty)) { blocked = true; break; }
    }
  }
  if (!blocked) {
    for (const zid in zombies) {
      const z = zombies[zid]; if (!z) continue;
      if (circleIntersectsTileClient(z.x, z.y, ZOMBIE_RADIUS, tx, ty)) { blocked = true; break; }
    }
  }

  const x = tx * TILE_SIZE - cameraX;
  const y = ty * TILE_SIZE - cameraY;

  ctx.save();
  ctx.globalAlpha = 0.5;
  // couleur selon le type
  if (buildMode === 'T') ctx.fillStyle = '#d33';
  else if (buildMode === 't') ctx.fillStyle = '#3aa6ff';
  else if (buildMode === 'B') ctx.fillStyle = '#7b4b2a';
  else if (buildMode === 'D') ctx.fillStyle = '#a57b4a';
  else if (buildMode === 'G') ctx.fillStyle = '#b48cff';
  else ctx.fillStyle = '#888';

  // pr√©visualisation du bloc
  ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
  ctx.strokeStyle = blocked ? '#ff3b3b' : '#34e05a';
  ctx.lineWidth = 2;
  ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
  ctx.restore();
}

function tryPlaceStructureAtCursor(clientX, clientY) {
  const { tx, ty } = screenToWorldTile(clientX, clientY);

  // bornes / murs
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) {
    console.debug('[build] Hors carte', { tx, ty });
    return;
  }
  if (isWallAt(tx, ty)) {
    console.debug('[build] Case murale', { tx, ty });
    return;
  }

  // bloc d√©j√† occup√© par une structure ?

  // halo de visibilit√©
  const me = (myId && playersHealth[myId]) ? playersHealth[myId] : null;
  if (me && !isSpectator) {
    const cx = (tx + 0.5) * TILE_SIZE;
    const cy = (ty + 0.5) * TILE_SIZE;
    const dx = me.x - cx, dy = me.y - cy;
    const R2 = (CLIENT_VIEW_RADIUS - 8) * (CLIENT_VIEW_RADIUS - 8);
    if ((dx*dx + dy*dy) > R2) {
      console.debug('[build] Hors halo', { tx, ty });
      return;
    }
  }

  // collision avec entit√©s (joueurs/bots/zombies)
  for (const id in playersHealth) {
    const p = playersHealth[id]; if (!p || !p.alive) continue;
    if (circleIntersectsTileClient(p.x, p.y, PLAYER_RADIUS, tx, ty)) {
      console.debug('[build] Collision avec joueur/bot', { tx, ty });
      return;
    }
  }
  for (const zid in zombies) {
    const z = zombies[zid]; if (!z) continue;
    if (circleIntersectsTileClient(z.x, z.y, ZOMBIE_RADIUS, tx, ty)) {
      console.debug('[build] Collision avec zombie', { tx, ty });
      return;
    }
  }

  if (structures?.[ty]?.[tx]) {
    console.debug('[build] Case d√©j√† occup√©e par une structure', { tx, ty, existing: structures[ty][tx] });
    return;
  }

  // payload (on envoie aussi centre monde pour aider le serveur s'il en a besoin)
  const payload = {
    type: buildMode,
    tx,
    ty,
    x: tx * TILE_SIZE + TILE_SIZE / 2,
    y: ty * TILE_SIZE + TILE_SIZE / 2
  };

  console.debug('[emit] buyStructure', payload);

  // ‚ÜòÔ∏è on attend l‚ÄôACK du serveur pour savoir si on sort du mode placement
  try {
    socket.emit('buyStructure', payload, (ack) => {
      if (ack && ack.type && ack.type === 'T_big') { if (structures) { let t = structures.find(s=>s && s.type==='T_big'); if (t) t.hp = t.maxHP||t.hp; } }
      console.debug('[ack] buyStructure', ack);
      if (ack && ack.ok) {
        // succ√®s confirm√© ‚Üí sortir du mode placement
        buildMode = null;
        buildHover = { tx: -1, ty: -1 };
      } else {
        // refus: on reste en mode placement pour r√©essayer ailleurs
        const reason = ack && ack.reason ? ack.reason : 'unknown';
        console.warn('[build] Refus√© par le serveur:', reason);
      }
    });
  } catch (err) {
    console.error('[emit] buyStructure error:', err);
  }
}

	function updateCamera() {
      const viewW = canvas.width / renderScale;
      const viewH = canvas.height / renderScale;
      if (isSpectator) {
        cameraX = spectatorPos.x - viewW / 2;
        cameraY = spectatorPos.y - viewH / 2;
        cameraX = Math.max(0, Math.min(cameraX, MAP_COLS * TILE_SIZE - viewW));
        cameraY = Math.max(0, Math.min(cameraY, MAP_ROWS * TILE_SIZE - viewH));
        return;
      }
	  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
	  let player = playersHealth[myId];

	  cameraX = player.x - viewW / 2;
	  cameraY = player.y - viewH / 2;

	  cameraX = Math.max(0, Math.min(cameraX, MAP_COLS * TILE_SIZE - viewW));
	  cameraY = Math.max(0, Math.min(cameraY, MAP_ROWS * TILE_SIZE - viewH));
	}

function drawHUD() {
  const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
  const aliveCount = Object.values(playersHealth).filter(p => p.alive).length;

  hudAlive.textContent = `${tr.alive} : ${aliveCount}`;
  hudMoney.textContent = `${tr.money || 'Money'} : $${myMoney}`;

  // ‚ö†Ô∏è Libell√© impos√© : "Zombies left" (pas de fallback "Active zombies")
  const labelZ = (TRANSLATIONS[currentLang] && TRANSLATIONS[currentLang].zombiesLeft) || 'Zombies left';

  // Compteur : priorise zombiesRemaining, sinon on compte les zombies actifs
  const countZ = (Number.isFinite(zombiesRemaining) && zombiesRemaining >= 0)
    ? zombiesRemaining
    : (zombies && typeof zombies === 'object' ? Object.keys(zombies).length : 0);

  hudZombies.textContent = `${labelZ}: ${countZ}`;

  hudKills.textContent = `${tr.kills}: ${myKills}`;
  hudRound.textContent = `${tr.round}: ${currentRound}`;

  const me = playersHealth[myId];
  hudHP.textContent = me && me.maxHealth
    ? `${tr.health}: ${Math.round(me.health)} / ${me.maxHealth}`
    : `${tr.health}: ${Math.round(me ? me.health : 0)}`;
}

    function showDeathScreen(kills = myKills, round = currentRound) {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      const deathStats = document.getElementById('deathStats');
      if (deathStats) {
        deathStats.innerHTML = `${tr.zombiesKilled}: <b>${kills}</b><br>${tr.roundReached}: <b>${round}</b>`;
      }
      // --- Submit score to ladder (robust, non-blocking) ---
      try {
        if (!window.__ladderSubmitted) {
          window.__ladderSubmitted = true;
          var player = (window.myPseudo && String(window.myPseudo)) || (window.pseudoInput && String(window.pseudoInput.value)) || '';
          player = (player || '').replace(/[^a-zA-Z0-9]/g,'').slice(0,10) || 'Anonymous';
          /* Ladder is now recorded server-side on death; client no longer posts. */
            if (!window.__ladderSubmitted) { window.__ladderSubmitted = true; }
        }
      } catch(_){}

      // Met √† jour les libell√©s
      const deathTitle = document.getElementById('deathTitle');
      if (deathTitle) deathTitle.textContent = tr.youDied || 'You died!';
      const btnReplay = document.getElementById('btnReplay');
      if (btnReplay) btnReplay.textContent = tr.replay || 'Replay';
      if (btnSpectate) {
        btnSpectate.textContent = (tr.spectate || 'Spectate');
        // Affiche Spectate seulement s'il reste au moins un autre joueur vivant
        try {
          const hasOtherAlive = Object.keys(playersHealth || {}).some(id => {
            if (id === myId) return false;
            const p = playersHealth[id];
            return p && p.alive;
          });
          btnSpectate.style.display = hasOtherAlive ? 'inline-block' : 'none';
        } catch(e) { btnSpectate.style.display = 'none'; }
      }
      deathScreen.style.display = 'flex';
    }

const spectateReplayBtn = document.getElementById('spectateReplayBtn');
if (btnSpectate) {
  const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
  btnSpectate.textContent = (tr.spectate || 'Spectate');
}
if (spectateReplayBtn) {
  spectateReplayBtn.onclick = () => { location.reload(); };
}
function enterSpectatorMode() {
  try { if (window.socket) { socket.emit('enterSpectator'); } } catch(e){}
  // init position au centre de la cam√©ra actuelle (derni√®re position connue)
  try {
    if (playersHealth[myId]) {
      spectatorPos.x = playersHealth[myId].x || (cameraX + canvas.width / (2*renderScale));
      spectatorPos.y = playersHealth[myId].y || (cameraY + canvas.height / (2*renderScale));
    } else {
      spectatorPos.x = cameraX + canvas.width / (2*renderScale);
      spectatorPos.y = cameraY + canvas.height / (2*renderScale);
    }
  } catch(e) {
    spectatorPos.x = cameraX + canvas.width / (2*renderScale);
    spectatorPos.y = cameraY + canvas.height / (2*renderScale);
  }
  isSpectator = true;
  deathScreen.style.display = 'none';
        if (spectateReplayBtn) spectateReplayBtn.style.display = 'block';
}
// Config bouton Spectate (seulement si la partie est encore en cours)
if (btnSpectate) {
  btnSpectate.onclick = () => {
    if (btnSpectate.style.display !== 'none') enterSpectatorMode();
  };
}

let lastTime = 0;
function gameLoop(timestamp = 0) {
  FRAME_ID++; // <- important : identifie le frame courant pour nos caches
	refreshZombiesFrame();
  const deltaTime = Math.max(0.008, Math.min(0.05, (timestamp - lastTime) / 1000));
  lastTime = timestamp;

  update(deltaTime);
  updateCamera();

  // Remet la transform, clear, puis applique le scale (zoom)
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);

  drawMap();
  drawBuildPreview();
  drawStructures();        // utilise refreshZombiesFrame() (1x/frame)
  drawBullets();           // culling
  drawTurretLasers();
  drawZombies();
  drawMoneyFloatingTexts();
  drawPlayers();
  drawAimLine();
  drawLightMask();

  drawHUD();

  requestAnimationFrame(gameLoop);
}

    socket.on('connect', () => { myId = socket.id; });
    socket.on('lobbyUpdate', (data) => {
      lobbyData = {
        started: !!data.started,
        count: Number(data.count)||0,
        max: Number(data.max)||0,
        timeLeft: Number(data.timeLeft)||0,
        players: data.players || {},
        hostId: (data && data.hostId) || null
      };
      try { window.lobbyData = lobbyData; } catch(_){}

      try { lobbyData.id = data && data.id; lobbyData.manual = !!(data && data.manual); } catch(e){}
      try { const t = document.getElementById('manualLobbyTitle'); if (t && data && data.manual) { t.textContent = ( (TRANSLATIONS[currentLang]&&TRANSLATIONS[currentLang].lobby) ? (TRANSLATIONS[currentLang].lobby+' #') : 'Lobby #') + (data.id || '?'); } } catch(e){}
      try { const p = document.getElementById('manualLobbyPanel'); if (p && p.style.display !== 'none') { renderManualPlayers(); } } catch(e){}
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      if (data.started) {
        lobbyScreen.style.display = 'none';
        lobbyStarted = true;
        return;
      }
      lobbyScreen.style.display = 'flex';
      updateLobbyTexts();
      lobbyJoin.disabled = (!!window.lobbyJoined) || !pseudoInput.value.trim();
      pseudoInput.readOnly = lobbyJoined;
      lobbyJoin.textContent = tr.join;
    });

    lobbyJoin.onclick = () => {
      if (!pseudoInput.value.trim()) {
        pseudoInput.focus();
        pseudoInput.style.background = "#fdd";
        setTimeout(() => pseudoInput.style.background = "", 600);
        return;
      }
      socket.emit('setPseudoAndReady', pseudoInput.value.trim()); try { localStorage.setItem('zombi_last_pseudo', String(pseudoInput.value.trim())); } catch(_) {}lobbyJoined = true;
      window.lobbyJoined = true;
      lobbyJoin.disabled = true;
      pseudoInput.readOnly = true;
      
          try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }lobbyJoin.textContent = TRANSLATIONS[currentLang].waiting;
      try { updateButtonsDisabled(); } catch(_) {}
    };

    pseudoInput.onkeydown = (e) => {
      if (e.key === "Enter") lobbyJoin.click();
    };

    socket.on('gameStarted', (data) => { myId = socket.id; isSpectator = false;
      map = data.map;
	  createMapBuffer();
      MAP_ROWS = map.length;
      MAP_COLS = map[0].length;
      playersHealth = data.players;
      try {
        var me = (playersHealth && myId) ? playersHealth[myId] : null;
        var ok = me && isNum(me.x) && isNum(me.y);
        if (ok) { __lastValidMyPos = {x: me.x, y: me.y}; centerCameraOn(me.x, me.y); __centeredOnPlayerOnce = true; }
        try { debugLog('üéØ gameStarted mePos=', ok ? (me.x+','+me.y) : 'n/a', 'centered=', !!ok); } catch(_){}
      } catch(_){}

      
      // Guard: if my player exists, center camera immediately; else keep default until first update
      try {
        if (playersHealth && myId && playersHealth[myId]) {
          const viewW = canvas.width / renderScale;
          const viewH = canvas.height / renderScale;
          cameraX = Math.max(0, Math.min(playersHealth[myId].x - viewW/2, MAP_COLS*TILE_SIZE - viewW));
          cameraY = Math.max(0, Math.min(playersHealth[myId].y - viewH/2, MAP_ROWS*TILE_SIZE - viewH));
        }
      } catch(e) {}
    currentRound = data.round;
      lobbyScreen.style.display = 'none';
      isDead = false; playerHealth = 100; myKills = 0;
      if (isMobileDevice) setTimeout(setupJoysticks, 300);
      setTimeout(()=>{ gameLoop(); }, 400);
	  structures = data.structures || null;
	if (data.structurePrices) {
	  STRUCTURE_PRICES = data.structurePrices;
	}
	updateBuildTilesState(); // rafra√Æchir les √©tiquettes + disabled
    });

socket.on('waveStarted', ({ totalZombies }) => {
  resetWaveCounters(totalZombies);
});

// --- MISE √Ä JOUR DES STRUCTURES PAR LE SERVEUR ---
// Re√ßoit une grille 2D (chaque case = null ou { type, hp } ou juste "type")
socket.on('structuresUpdate', (grid) => {
  // Normalise la grille re√ßue pour garantir des HP corrects
  if (!grid || !grid.length) { structures = grid; return; }
  const rows = grid.length;
  const cols = grid[0]?.length || 0;
  const newGrid = Array.from({ length: rows }, (_, y) =>
    Array.from({ length: cols }, (_, x) => {
      const cell = grid[y][x];
      if (!cell || cell === 0) return null;

      // HP depuis structHPGrid (si dispo) sinon HP pr√©c√©dent sinon valeur par d√©faut selon type
      const hpFromGrid = structHPGrid?.[y]?.[x];
      const previousHP = structures?.[y]?.[x]?.hp;

      if (typeof cell === 'object') {
          const type = cell.type;
let hp = (typeof cell.hp === 'number') ? cell.hp
          : ((typeof hpFromGrid === 'number' && hpFromGrid > 0) ? hpFromGrid
            : ((typeof previousHP === 'number' && previousHP > 0) ? previousHP
              : (type === 'T' ? 500 : (type === 't' ? 200 : (type === 'G' ? 2500 : ((type === 'B' || type === 'D') ? 500 : 200))))));
        if (hp <= 0) return null;
          return { type, hp, placedBy: cell.placedBy };
        }

      if (typeof cell === 'string') {
        const type = cell;
        let hp = ((typeof hpFromGrid === 'number' && hpFromGrid > 0) ? hpFromGrid
          : ((typeof previousHP === 'number' && previousHP > 0) ? previousHP
            : (type === 'T' ? 500 : (type === 't' ? 200 : (type === 'G' ? 2500 : ((type === 'B' || type === 'D') ? 500 : 200))))));
        if (hp <= 0) return null;
        return { type, hp };
      }

      return null;
    })
  );
  structures = newGrid;

  // seed/rafra√Æchir structHPGrid si la grille contient des hp
  if (!structHPGrid) structHPGrid = [];
  for (let ty = 0; ty < grid.length; ty++) {
    const row = grid[ty];
    if (!structHPGrid[ty]) structHPGrid[ty] = [];
    for (let tx = 0; tx < row.length; tx++) {
      const cell = row[tx];
      if (cell && typeof cell === 'object' && typeof cell.hp === 'number') {
        structHPGrid[ty][tx] = cell.hp;
      } else if (cell == null) {
        structHPGrid[ty][tx] = 0; // d√©truit
      }
    }
  }
});

   
   
   socket.on('laserBeam', ({ x0, y0, x1, y1, color }) => {
  // On stocke pour le prochain rendu; l‚Äôeffet dispara√Æt tr√®s vite
  turretLasers.push({
    x0, y0, x1, y1, color,
    t: performance.now()
  });
});

   
   socket.on('laserBeams', (arr) => {
  const t = performance.now();
  // On push dans le m√™me buffer que d‚Äôhabitude
  for (let i = 0; i < arr.length; i++) {
    const b = arr[i];
    turretLasers.push({ x0: b.x0, y0: b.y0, x1: b.x1, y1: b.y1, color: b.color, t });
  }
});

   
   
	socket.on('zombiesRemaining', (n) => {
	  zombiesRemaining = Number(n) || 0;
	  drawHUD();
	});

    socket.on('killsUpdate', (kills) => { myKills = kills; drawHUD(); });
	
socket.on('zombieDied', () => {
  if (zombiesRemaining > 0) zombiesRemaining--;
  waveKilledThisWave++;
  drawHUD();
});
	

    socket.on('youDied', (data) => {
      isDead = true;
      playerHealth = 0;
      showDeathScreen(data.kills, data.round);
    });

	socket.on('moneyEarned', ({ amount, x, y }) => {
	  // Position sur la map, converti en coordonn√©es √©cran pour affichage temporaire
	  moneyFloatingTexts.push({
		amount,
		x,
		y,
		time: Date.now(),
		duration: 1200, // ms
		vy: -0.14 // pixels/ms (vitesse vers le haut)
	  });
	  myMoney += amount;          // <--- ajoute
	  drawHUD();                  // <--- ajoute
	  updateBuildTilesState();    // <--- ajoute
	});

socket.on('upgradeUpdate', ({ myUpgrades: u, myMoney: m }) => {
  if (u) myUpgrades = u;
  if (typeof m === 'number') myMoney = m;
  renderShopUpgrades();
  drawHUD();
  updateBuildTilesState();
});

    socket.on('waveMessage', (msg) => {
  try {
    const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']);
    const m = String(msg || '').match(/\d+/);
    const n = m ? parseInt(m[0], 10) : NaN;
    const label = tr.round || 'Wave';
    waveMessage.textContent = Number.isFinite(n) ? (label + ' ' + n) : label;
  } catch(e) {
    waveMessage.textContent = 'Wave';
  }
  waveMessage.style.opacity = '1';
  setTimeout(() => { waveMessage.style.opacity = '0'; }, 2500);
});

	socket.on('upgradeBought', ({ upgId, newLevel, newMoney }) => {
	  if (!upgId) return;
	  myUpgrades[upgId] = newLevel;
	  myMoney = newMoney;
	  renderShopUpgrades();
	  drawHUD();
	  updateBuildTilesState();

	  // Trouve le bouton correspondant et applique l'animation
	  setTimeout(() => {
		const btn = document.querySelector(`#shopUpgrades button[data-upgid="${upgId}"]`);
		if (btn) {
		  btn.classList.remove('bought-flash'); // Si jamais d√©j√† pr√©sente
		  // Force reflow pour relancer l'anim m√™me si le bouton venait d'√™tre upgrad√©
		  void btn.offsetWidth;
		  btn.classList.add('bought-flash');
		  setTimeout(() => btn.classList.remove('bought-flash'), 280);
		}
	  }, 60); // petit d√©lai pour que le bouton existe apr√®s le render
	});

    setInterval(drawHUD, 150);

	// --- SHOP BTN LOGIC ---
	const shopBtn = document.getElementById('shopBtn');
	const shopModal = document.getElementById('shopModal');
	const shopClose = document.getElementById('shopClose');

// ====== UI Achat Structures \(au-dessus du SHOP\) ======

// === Auto-fire state & UI ===
let AUTO_FIRE_ENABLED = false;
const autoBtn = document.getElementById('autoFireBtn');
const autoLbl = document.getElementById('autoFireLabel');

function updateAutoFireBtnUI() {
  if (!autoBtn || !autoLbl) return;
  if (AUTO_FIRE_ENABLED) {
    autoBtn.style.background = '#d1292f';
    autoBtn.style.borderColor = '#7b0e13';
    autoBtn.style.color = '#fff';
    autoLbl.textContent = ((TRANSLATIONS[currentLang]||TRANSLATIONS['en']).autoFireOn || 'Auto fire ON');
    autoBtn.querySelector('span').style.background = '#ff6066';
  } else {
    autoBtn.style.background = '#5a2226';
    autoBtn.style.borderColor = '#4a1111';
    autoBtn.style.color = '#f1d6d6';
    autoLbl.textContent = ((TRANSLATIONS[currentLang]||TRANSLATIONS['en']).autoFireOff || 'Auto fire OFF');
    autoBtn.querySelector('span').style.background = '#742f36';
  }
}
if (autoBtn) {
  autoBtn.addEventListener('click', () => {
    AUTO_FIRE_ENABLED = !AUTO_FIRE_ENABLED;
    updateAutoFireBtnUI();
  });
  updateAutoFireBtnUI();
}

function upperFirstLocalized(s){
  if (!s) return s;
  try{
    var i = s.search(/[A-Za-z√Ä-√ñ√ò-√∂√∏-√øƒÄ-≈æ–ê-–Ø–∞-—è–Å—ë]/u);
    if (i < 0) return s;
    return s.slice(0, i) + s.charAt(i).toUpperCase() + s.slice(i + 1);
  } catch(e){
    try { return s.charAt(0).toUpperCase() + s.slice(1); } catch(_) { return s; }
  }
}
const buildBar = document.getElementById('buildBar');
const buildTiles = document.querySelectorAll('#buildTiles .build-tile');
const buildTooltip = document.getElementById('buildTooltip');
let STRUCTURE_PRICES = { T: 1000, t: 250, G: 5000, B: 100, D: 200 };

// Hover ‚Üí tooltip (localized, hard method)
buildTiles.forEach(btn => {
  function computeTip(type) {
    const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']) || {};
    const names = (tr.turretType || {});
    const hpLabel = tr.hpShort || 'HP';
    const dmgLabel = tr.damage || 'Damage';
    const rateLabel = tr.fireRate || 'Fire rate';
    const baseHP = { T:500, t:200, G:2500, B:500, D:500 };
    let name =  (type==='B') ? (tr.buildWall || 'Wall')
                : (type==='D') ? (tr.buildDoor || 'Door')
                : (names[type] || 'Turret');
    name = upperFirstLocalized(name);
    if (type==='B' || type==='D') {
      return name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ')';
    } else {
      const rate = (type==='T') ? '1' : (type==='G') ? '2' : '0.5';
      const dmg = (typeof computeTurretDamageDisplay==='function') ? computeTurretDamageDisplay(type) : 0;
      return name + ' (' + hpLabel + ': ' + (baseHP[type]||0) + ', ' + dmgLabel + ': ' + dmg + ', ' + rateLabel + ': ' + rate + ((TRANSLATIONS[currentLang]||TRANSLATIONS['en']).perSec||'/s') + ')';
    }
  }
  btn.addEventListener('mouseenter', () => {
    const type = btn.getAttribute('data-type');
    const tip = computeTip(type);
    buildTooltip.textContent = tip;
    buildTooltip.style.display = 'block';
  }, { passive: true });
  btn.addEventListener('mouseleave', () => {
    buildTooltip.style.display = 'none';
  }, { passive: true });
});
// Click ‚Üí entrer/sortir du mode placement (toggle)
let buildClickCooldown = false;
buildTiles.forEach(btn => {
  btn.addEventListener('click', () => {
    if (buildClickCooldown) return;
    buildClickCooldown = true;
    setTimeout(() => (buildClickCooldown = false), 250);

    const type = btn.getAttribute('data-type');

    // Si on reclique sur le m√™me type ‚Üí on annule le placement
    if (buildMode === type) {
      buildMode = null;
      buildHover = { tx: -1, ty: -1 };
      
      return;
    }

    // Sinon, on entre en mode placement pour ce type
    buildMode = type;
    
  });
});

updateBuildTilesState();

// Ajuster la position quand on bouge le shop (mobile)
function positionBuildBar() {
  // Sur mobile, on se base sur la position recalcul√©e du SHOP (d√©j√† g√©r√©e par positionShopUI)
  // Ici, on laisse le buildBar accroch√©e en haut du shopBtn (style inline d√©j√† ok).
  // Si besoin d‚Äôajustements fins mobile, on les ferait ici sans toucher au reste.
}
window.addEventListener('resize', positionBuildBar);
window.addEventListener('orientationchange', positionBuildBar);

// Normalise les coordonn√©es re√ßues : supporte {tx,ty} ou {x,y} en pixels
function normalizeTileCoords(obj) {
  let tx = (typeof obj.tx === 'number') ? obj.tx
        : (typeof obj.x === 'number') ? Math.floor(obj.x / TILE_SIZE)
        : null;
  let ty = (typeof obj.ty === 'number') ? obj.ty
        : (typeof obj.y === 'number') ? Math.floor(obj.y / TILE_SIZE)
        : null;
  return { tx, ty };
}

// Tente d'appliquer sur [ty][tx], puis fallback sur [tx][ty] si n√©cessaire
function setStructureHP(tx, ty, hp) {
  if (!structures) return false;

  // bornes ‚Äúnormales‚Äù
  if (ty >= 0 && ty < MAP_ROWS && tx >= 0 && tx < MAP_COLS && structures?.[ty]) {
    const cell = structures[ty][tx];
    if (cell != null) {
      if (typeof cell === 'object') structures[ty][tx].hp = hp;
      else structures[ty][tx] = { type: cell, hp };
      if (!structHPGrid) structHPGrid = [];
      if (!structHPGrid[ty]) structHPGrid[ty] = [];
      structHPGrid[ty][tx] = hp;
      return true;
    }
  }

  // fallback si inversion tx/ty c√¥t√© serveur
  if (tx >= 0 && tx < MAP_ROWS && ty >= 0 && ty < MAP_COLS && structures?.[tx]) {
    const cell = structures[tx][ty];
    if (cell != null) {
      if (typeof cell === 'object') structures[tx][ty].hp = hp;
      else structures[tx][ty] = { type: cell, hp };
      if (!structHPGrid) structHPGrid = [];
      if (!structHPGrid[tx]) structHPGrid[tx] = [];
      structHPGrid[tx][ty] = hp;
      return true;
    }
  }

  return false;
}

socket.on('structureHP', (payload) => {
  // --- 1) Coords tuile fiables (accepte {tx,ty} OU {x,y} en pixels) ---
  const tx = (typeof payload.tx === 'number') ? payload.tx
            : (typeof payload.x  === 'number') ? Math.floor(payload.x / TILE_SIZE) : null;
  const ty = (typeof payload.ty === 'number') ? payload.ty
            : (typeof payload.y  === 'number') ? Math.floor(payload.y / TILE_SIZE) : null;
  const hp = Number(payload.hp);

  if (!Number.isFinite(tx) || !Number.isFinite(ty) || !Number.isFinite(hp)) return;

  // --- 2  Miroir HP (grille) : on met √† jour la case "normale",
  // et si n√©cessaire on tente aussi l‚Äôinversion [tx][ty] (serveur invers√©)
  if (!structHPGrid) structHPGrid = [];
  if (!structHPGrid[ty]) structHPGrid[ty] = [];
  structHPGrid[ty][tx] = hp;

  // Si la case "normale" n'existe pas c√¥t√© structures mais l‚Äôinvers√©e oui,
  // on maintien aussi le miroir invers√© pour l‚Äôaffichage
  if (!(structures?.[ty]?.[tx]) && (structures?.[tx]?.[ty])) {
    if (!structHPGrid[tx]) structHPGrid[tx] = [];
    structHPGrid[tx][ty] = hp;
  }

  // --- 3  Mise √† jour de la grille visuelle (si elle existe d√©j√†) ---
  const applyHP = (r, c) => {
    if (!structures || !structures[r]) return false;
    const cell = structures[r][c];
    if (cell == null) return false; // rien √† mettre √† jour

    if (typeof cell === 'object') {
      structures[r][c].hp = hp;
    } else {
      // Le serveur a peut-√™tre envoy√© juste le type (string) :
      // on le convertit en objet pour avoir un HP visible qui descend.
      structures[r][c] = { type: cell, hp };
    }

    // HP <= 0 ‚Üí suppression visuelle imm√©diate
    if (hp <= 0) {
      structures[r][c] = null;
      if (structHPGrid?.[r]) structHPGrid[r][c] = 0;
    }
    return true;
  };

  // Essai en [ty][tx], puis fallback en [tx][ty] si besoin
  if (!applyHP(ty, tx)) applyHP(tx, ty);
});function clearStructureAt(tx, ty) {
  if (!structures) return false;

  // chemin ‚Äúnormal‚Äù [ty][tx]
  if (ty >= 0 && ty < MAP_ROWS && tx >= 0 && tx < MAP_COLS && structures?.[ty]) {
    if (structures[ty][tx] !== undefined) {
      structures[ty][tx] = null;
      if (structHPGrid?.[ty]) structHPGrid[ty][tx] = 0;
      return true;
    }
  }
  // fallback inversion [tx][ty]
  if (tx >= 0 && tx < MAP_ROWS && ty >= 0 && ty < MAP_COLS && structures?.[tx]) {
    if (structures[tx][ty] !== undefined) {
      structures[tx][ty] = null;
      if (structHPGrid?.[tx]) structHPGrid[tx][ty] = 0;
      return true;
    }
  }
  return false;
}

socket.on('structureDestroyed', (payload) => {
  const { tx, ty } = normalizeTileCoords(payload);
  
// Wall/Door cooldown update from server

if (!Number.isFinite(tx) || !Number.isFinite(ty)) return;

  const ok = clearStructureAt(tx, ty);
  if (!ok) console.warn('[structureDestroyed] cellule introuvable', { payload, tx, ty });
});

// R√©ception du r√©sultat d‚Äôachat d‚Äôune structure
socket.on('buildResult', (payload) => {
  const {
    ok,
    reason,
    type,
    tx,
    ty,
    newMoney,
    structurePrices,
    hp: hpFromServer
  } = payload || {};

  console.debug('[on] buildResult', payload);

  // Maj argent et √©ventuellement la table des prix
  if (typeof newMoney === 'number') {
    myMoney = newMoney;
  }
  if (structurePrices) {
    STRUCTURE_PRICES = { STRUCTURE_PRICES, structurePrices };
  }

  // Rafra√Æchir l‚ÄôUI
  drawHUD();
  updateBuildTilesState();

  if (!ok) {
    let msg = '';
    switch (reason) {
      case 'game_not_running': msg = "Impossible d‚Äôacheter : la partie n‚Äôest pas en cours."; break;
      case 'player_invalid':   msg = "Action impossible : joueur inactif."; break;
      case 'invalid_type':     msg = "Type d‚Äôobjet invalide."; break;
      case 'not_enough_money': msg = "Pas assez d‚Äôargent."; break;
      case 'tile_blocked':     msg = "Case indisponible (mur, structure, autre joueur ou zombie)."; break;
      default:                 msg = "Achat impossible."; break;
    }
    console.warn('[buildResult] Refus√©:', msg, { type, tx, ty });
    // on reste en mode placement pour r√©essayer ailleurs
    return;
  }

  // ‚úÖ Succ√®s : on pose localement la structure pour l'afficher tout de suite// S'assure que la grille existe
  if (!structures) {
    structures = Array.from({ length: MAP_ROWS }, () => Array(MAP_COLS).fill(null));
  } else if (!structures[ty]) {
    structures[ty] = [];
  }

  // HP par d√©faut si non fourni par le serveur
  const defaultHp = (type === 'T') ? 500 : (type === 't' ? 200 : (type === 'G' ? 2500 : ((type === 'B' || type === 'D') ? 500 : 200)));
  const hp = (typeof hpFromServer === 'number') ? hpFromServer : defaultHp;

  // Place localement
  structures[ty][tx] = { type, hp, placedBy: myId };
  
 // Maintenir aussi la grille HP si on l'utilise
if (structHPGrid) {
  if (!structHPGrid[ty]) structHPGrid[ty] = [];
  structHPGrid[ty][tx] = hp;
}

  // Sort du mode placement
  buildMode = null;
  buildHover = { tx: -1, ty: -1 };
});

	function closeShopIfOutside(evt) {
	  if (shopModal.style.display !== 'block') return;
	  const target = evt.target;
	  // Ne ferme pas si on clique sur le bouton ou dans le panneau
	  if (shopModal.contains(target) || shopBtn.contains(target)) return;
	  shopModal.style.display = 'none';
	}
	document.addEventListener('pointerdown', closeShopIfOutside, { passive: true });

function updateBuildTilesState() {
  document.querySelectorAll('#buildTiles .build-tile').forEach(btn => {
    const type = btn.getAttribute('data-type');
    const price = STRUCTURE_PRICES[type] ?? Infinity;

    // maj de l‚Äô√©tiquette sous la tuile (2e div)
    const priceLabel = btn.querySelector('div:nth-child(2)');
    if (priceLabel) {
      let label = `$${price}`;
      if (type==='t'||type==='T'||type==='G') {
        const limits = { t:2, T:2, G:1 };
        let count=0;
        if (structures) {
          for (let r=0;r<structures.length;r++) for (let c=0;c<structures[r].length;c++){
            const sc = structures[r][c];
            if (sc && sc.type===type && sc.hp>0 && sc.placedBy===myId) count++;
          }
        }
        label += ` ‚Ä¢ ${count}/${limits[type]}`;
      }
      priceLabel.textContent = label;
    }

    // √©tat ‚Äúachetable‚Äù
    const afford = myMoney >= price;
    btn.style.opacity = afford ? '1' : '0.55';
    btn.style.cursor  = afford ? 'pointer' : 'not-allowed';
    btn.disabled = !afford;
    // enforce per-type max counts per player
    if (type==='t' || type==='T' || type==='G') {
      const limits = { 't': 2, 'T': 2, 'G': 1 };
      let count=0;
      if (structures) {
        for (let r=0;r<structures.length;r++) for (let c=0;c<structures[r].length;c++) {
          const sc = structures[r][c];
          if (sc && sc.type===type && sc.hp>0 && sc.placedBy===myId) count++;
        }
      }
      if (count>=limits[type]) { btn.disabled=true; btn.style.opacity='0.5'; btn.style.cursor='not-allowed'; }
    }

  });
}

const PRICE_TIERS = [10, 25, 50, 75, 100];
const PRICE_STEP_AFTER_TIER = 75;
function getUpgradePrice(nextLevel) {
  if (nextLevel <= PRICE_TIERS.length) return PRICE_TIERS[nextLevel - 1];
  if (nextLevel <= 7) return PRICE_TIERS[PRICE_TIERS.length - 1] + (nextLevel - PRICE_TIERS.length) * PRICE_STEP_AFTER_TIER;
  const priceAt7 = PRICE_TIERS[PRICE_TIERS.length - 1] + (7 - PRICE_TIERS.length) * PRICE_STEP_AFTER_TIER;
  const k = nextLevel - 7;
  return Math.round(priceAt7 * Math.pow(1.2, k));
}

function getUpgText(upg, field){
  try {
    const tr = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']);
    const pack = (tr.upgrades && tr.upgrades[upg.id]) || null;
    if (pack && pack[field]) return pack[field];
    return upg && upg[field] ? upg[field] : '';
  } catch(e){ return (upg && upg[field]) || ''; }
}
function renderShopUpgrades() {
  if (!window.myTurretUp || typeof myTurretUp !== 'object') { window.myTurretUp = {}; }
  const el = document.getElementById('shopUpgrades');
  el.innerHTML = "";

  // Event delegation for turret upgrade buttons (survives innerHTML changes)
  try {
    if (!el._turretDelegation) {
      el.addEventListener('click', (ev) => {
        const btn = ev.target.closest && ev.target.closest('.btn-turret-up');
        if (!btn) return;
        const type = btn.getAttribute('data-type');
        if (btn.hasAttribute('disabled')) {return;
        }
        
        socket.emit('upgradeTurret', { type });
      });
      el._turretDelegation = true;}
  } catch(e) { console.error('[UI] turret delegation error', e); }

  // --- Upgrades Tourelles (3 slots, m√™me design) ---
  const turretDefs = [
      
    { type:'G', name:'Big-tourelle +D√©g√¢ts',  color:'#b48cff', border:'#2b1b3a', basePrice:5000, scale:1.2 },
    { type:'T', name:'Tourelle +D√©g√¢ts',      color:'#ff3b3b', border:'#2b0b0b', basePrice:2000, scale:1.3 },
    { type:'t', name:'Mini-tourelle +D√©g√¢ts', color:'#3aa6ff', border:'#0b2436', basePrice:500,  scale:1.3 }
  

  ];
  try { turretDefs.forEach(td => {
    const lvl = (myTurretUp && (myTurretUp[td.type]||0)) || 0;
    const next = lvl + 1;
    const price = Math.round(td.basePrice * Math.pow(td.scale, lvl));
    const dmgNow = computeTurretDamageDisplay(td.type);
    // simulate next damage (preview)
    const tmp = (myTurretUp && myTurretUp[td.type]) || 0;
    myTurretUp[td.type] = (myTurretUp[td.type]||0) + 1;
    const dmgNext = computeTurretDamageDisplay(td.type);
    myTurretUp[td.type] = tmp;

    const disabled = myMoney < price;
    

    el.innerHTML += `
      <div class="shop-upg-item" style="display:flex; align-items:center; gap:14px; margin:10px 0; background:#222a; border-radius:10px; padding:12px 14px 10px 7px;">
        <div style="width:44px; height:44px; border-radius:10px; display:flex; align-items:center; justify-content:center; border:2px solid ${td.border}; background:${td.color}22;">
          <div style="width:18px; height:18px; background:${td.color}; border:2px solid ${td.border}; border-radius:3px;"></div>
        </div>
        <div style="flex:1;">
          <div style="font-size:18px;"><b>${((TRANSLATIONS[currentLang]||TRANSLATIONS["en"]).turretUpg && (TRANSLATIONS[currentLang]||TRANSLATIONS["en"]).turretUpg[td.type]) || td.name}</b></div>
          <div style="color:#9ab; font-size:13px;">${(TRANSLATIONS[currentLang]||TRANSLATIONS['en'])[td.type==='t'?'turretDescMini':(td.type==='T'?'turretDescNormal':'turretDescBig')]}<\/div>
          <div style="margin-top:6px; color:#9f9; font-size:14px;">${(TRANSLATIONS[currentLang]||TRANSLATIONS['en']).damage || 'Damage'} : <b>${dmgNow}</b> ‚Üí <b>${dmgNext}</b></div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center; gap:8px;">
          <div style="display:inline-flex;align-items:center;justify-content:center;width:36px;height:24px;background:#282;color:#fff;font-weight:bold;border-radius:7px;font-size:15px;box-shadow:0 1.5px 6px #0007;border:2px solid #232;">${lvl}</div>
          <button class="btn-turret-up" data-type="${td.type}" style="min-width:64px; padding:8px 10px; border-radius:10px; border:none; background:${disabled ? '#444' : '#393'}; color:#fff; cursor:${disabled?'not-allowed':'pointer'}; opacity:${disabled?'0.5':'1'};">
            +1<br>$${price}
          </button>
        </div>
      </div>`;
  });

  // Re-bind achat upgrades tourelles (apr√®s TOUT le contenu est ins√©r√©)
  try {
    const turretBtns = el.querySelectorAll('.btn-turret-up');turretBtns.forEach(btn => {
      const type = btn.getAttribute('data-type');
      btn.onclick = () => {  socket.emit('upgradeTurret', { type }); };
    });
  } catch(e) { console.error('[UI] late-bind turret error', e); }

} catch(e) { console.error('[UI] renderShopUpgrades turret section error', e); }

  // --- Upgrades joueur (les 5 existants) ---
  UPGRADES.forEach(upg => {
    const lvl = myUpgrades[upg.id] || 0;
    const price = getUpgradePrice(lvl + 1);
    const value = upg.getValue(upg.baseValue, lvl);
    const nextValue = upg.getValue(upg.baseValue, lvl + 1);
    const disabled = myMoney < price;

    let __label = getUpgText(upg,'label');
    try {
      if (upg.id === 'speed') {
        try {
          const rest = (getUpgText(upg,'label') || '').replace(/^\s*\+?\d+\s*%?\s*/,'').trim();
          __label = '+10% ' + (rest || getUpgText(upg,'statLabel') || 'Speed');
        } catch(e2) { __label = '+10% ' + (getUpgText(upg,'label') || 'Speed'); }
      } else if (upg.id === 'regen') {
        const __lvl = myUpgrades[upg.id] || 0;
        const __cur = upg.getValue(upg.baseValue, __lvl);
        const __nxt = upg.getValue(upg.baseValue, __lvl + 1);
        let __delta = __nxt - __cur;
        let __str;
        if (Math.abs(__delta) < 10) { __str = __delta.toFixed(2); }
        else if (Math.abs(__delta) < 100) { __str = __delta.toFixed(1); }
        else { __str = Math.round(__delta).toString(); }
        __str = __str.replace(/\.0+$/,'').replace(/(\.\d*[1-9])0+$/,'$1');
        const __trUnits = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']) || {}; const __unit = (__trUnits.hpShort || 'HP') + (__trUnits.perSec || '/s');
        __label = '+' + __str + ' ' + __unit;
      }
    } catch(e) { /* keep default label */ }
    

    const __trUnits2 = (TRANSLATIONS[currentLang] || TRANSLATIONS['en']) || {};
    const __hpU = __trUnits2.hpShort || 'HP';
    const __perSec = __trUnits2.perSec || '/s';
    const __pxPerSec = (__trUnits2.pxPerSec || ('px' + __perSec));
    function __fmt(upg, v){
      if (upg.id === 'maxHp') return v + ' ' + __hpU;
      if (upg.id === 'regen') return v + ' ' + __hpU + __perSec;
      if (upg.id === 'speed') return v + ' ' + __pxPerSec;
      return (upg.format ? upg.format(v) : v);
    }
    const fmtCur = __fmt(upg, value);
    const fmtNext = __fmt(upg, nextValue);
el.innerHTML += `
      <div style="display:flex; align-items:center; gap:14px; margin-bottom:19px; background:#222a; border-radius:10px; padding:12px 14px 10px 7px;">
        <div style="flex:1;">
          <div style="font-size:18px;"><b>${__label}</b></div>
          <div style="font-size:14px; color:#fffa; margin-bottom:3px;">${getUpgText(upg,'desc')}</div>
          <div style="font-size:15px; color:#bcffa8;">
            ${getUpgText(upg,'statLabel')} : <b>${fmtCur}</b>
            <span style="color:#8f8; font-size:14px; margin-left:7px;">‚Üí ${fmtNext}</span>
          </div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center; gap:8px;"><div style="display:inline-flex;align-items:center;justify-content:center;width:36px;height:24px;background:#282;color:#fff;font-weight:bold;border-radius:7px;font-size:15px;box-shadow:0 1.5px 6px #0007;border:2px solid #232;">${lvl}</div>
        <button
          style="font-size:16px;background:${disabled ? '#444' : '#393'};color:#fff;border:none;border-radius:7px;padding:7px 18px;box-shadow:0 2px 8px #0004;cursor:${disabled ? 'not-allowed' : 'pointer'};opacity:${disabled ? '0.5' : '1'};margin-left:8px;transition: background 0.16s;"
          data-upgid="${upg.id}" ${disabled?'disabled':''} ${disabled ? "disabled" : ""}>
          +1<br>$${price}
        </button></div>
      </div>
    `;
  });

  // Bind achat upgrades joueur
  el.querySelectorAll('button[data-upgid]').forEach(btn => {
    const upgId = btn.getAttribute('data-upgid');
    btn.onclick = () => socket.emit('upgradeBuy', { upgId });
  });
}

	shopBtn.onclick = () => {
	  renderShopUpgrades();
	  shopModal.style.display = 'block';
	  // Recalage √† l‚Äôouverture (tailles DOM connues)
	  positionShopUI();
	};

	shopClose.onclick = () => {
	  shopModal.style.display = 'none';
	};

	// (optionnel, fermer si on clique dehors la fen√™tre)
	shopModal.addEventListener('mousedown', function(e) {
	  if (e.target === shopModal) shopModal.style.display = 'none';
	});

    updateUITexts();
    drawHUD();

    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'p' && myPseudo === 'Myg') {
        socket.emit('killAllZombies');
      }
      if (e.key.toLowerCase() === 'o' && myPseudo === 'Myg') {
        socket.emit('giveMillion');
      }
      if (e.key.toLowerCase() === 'm' && myPseudo === 'Myg') {
        socket.emit('skipRound');
      }
    });
	
	// --- REAFFICHER LES JOYSTICKS + MAJ ZOOM SUR MOBILE APR√àS CHANGEMENT D'ORIENTATION ---
	if (isMobileDevice) {
	  window.addEventListener('resize', () => {
		updateRenderScale();
		setTimeout(() => { setupJoysticks(); positionShopUI(); }, 200);
	  });
	  window.addEventListener('orientationchange', () => {
		updateRenderScale();
		setTimeout(() => { setupJoysticks(); positionShopUI(); }, 200);
	  });
	}
(() => {
  const container = document.getElementById('mobile-build');
  if (!container) return;

  const buttons = container.querySelectorAll('.mb-btn');

  function setBuildMode(type) {
    // Toggle si on reclique le m√™me type
    if (buildMode === type) {
      buildMode = null;
      buildHover = { tx: -1, ty: -1 };
      return;
    }

    // V√©rif argent (√©vite de passer en mode si pas assez d'argent)
    const price = (STRUCTURE_PRICES && STRUCTURE_PRICES[type]) ?? Infinity;
    if (myMoney < price) {
      if (navigator.vibrate) try { navigator.vibrate(60); } catch {}
      return;
    }

    buildMode = type;
    // reset survol
    buildHover = { tx: -1, ty: -1 };
  }

  function handleTap(type, e) {
    if (e) { e.preventDefault(); e.stopPropagation(); }
    setBuildMode(type);
  }

  buttons.forEach(btn => {
    const type = btn.getAttribute('data-type');
    // Click / Pointer / Touch : on capte tous les cas
    btn.addEventListener('click',       e => handleTap(type, e));
    btn.addEventListener('pointerdown', e => handleTap(type, e), { passive: false });
    btn.addEventListener('touchstart',  e => handleTap(type, e), { passive: false });
  });
})();
	
  

window.DEV = (typeof window !== "undefined" && window.__DEV_PERF) ? window.__DEV_PERF : undefined;

// ===== New lobby buttons & manual lobby logic =====
(function(){
  const btnJoinList = document.getElementById('btnJoinLobbyList');
  const btnCreate = document.getElementById('btnCreateLobby');
  const manualPanel = document.getElementById('manualLobbyPanel');
  const manualPlayers = document.getElementById('manualLobbyPlayers');
  const btnBackManual = document.getElementById('btnBackFromManual');
  const listPanel = document.getElementById('joinLobbyPanel');
  const lobbiesList = document.getElementById('lobbiesList');
  const btnBackList = document.getElementById('btnBackFromList');
  
  // Control Start button visibility based on hostId
  // Control Start button visibility based on hostId
  // Control Start button visibility based on hostId
  socket.on('lobbyUpdate', function(data){
    try {
      const isHost = !!(data && data.hostId && socket && socket.id && data.hostId === socket.id);
      const btn = document.getElementById('btnStartManual');
      if (btn) btn.style.display = isHost ? 'inline-block' : 'none';
    } catch(e){}
    try { const t = document.getElementById('manualLobbyTitle'); if (t && data && data.manual) { t.textContent = ( (TRANSLATIONS[currentLang]&&TRANSLATIONS[currentLang].lobby) ? (TRANSLATIONS[currentLang].lobby+' #') : 'Lobby #') + (data.id || '?'); } } catch(e){}
    try { if (manualPanel && manualPanel.style.display !== 'none') renderManualPlayers(); } catch(e){}
  
  try {
    window.lobbyData = data;
    if (data && data.manual && !data.started && data.hostId) {
      var players = (data.players||{});
      if (!players[data.hostId]) { try{ showMain(); window.lobbyJoined = false; if (pseudoInput){ pseudoInput.disabled=false; if(window.myPseudo) pseudoInput.value=window.myPseudo; } try{ updateButtonsDisabled(); }catch(_){}}catch(_){ } }
    }
  } catch(e){}});
const btnRefreshLobbies = document.getElementById('btnRefreshLobbies');

  let listInterval = null;
  function showMain() {
    try { clearInterval(listInterval); listInterval = null; } catch(_){}
    try { updateButtonsDisabled(); } catch(_){}
    try { manualPanel.style.display='none'; listPanel.style.display='none'; } catch(_){}
    manualPanel.style.display = 'none';
    listPanel.style.display = 'none';
    try{ if (pseudoInput) { pseudoInput.style.display = ''; if (window.myPseudo && !pseudoInput.value) pseudoInput.value = window.myPseudo; } }catch(_){}
  }
  function showManual(){
    manualPanel.style.display = 'block';
    listPanel.style.display = 'none';
    try{ if (pseudoInput) pseudoInput.style.display = 'none'; }catch(_){}
  }
  function showList(){
    manualPanel.style.display = 'none';
    listPanel.style.display = 'block';
    try{ if (pseudoInput) pseudoInput.style.display = 'none'; }catch(_){}
  }

  function updateButtonsDisabled() {
    const hasPseudo = !!(pseudoInput && pseudoInput.value.trim());
    const shouldDisable = !hasPseudo || !!window.lobbyJoined;
    const inLobby = !!window.lobbyJoined;

    if (btnJoinList) btnJoinList.disabled = shouldDisable;
    if (btnCreate) btnCreate.disabled = shouldDisable;
    if (lobbyJoin) lobbyJoin.disabled = shouldDisable;
    // Also gray out Ladder and auth buttons when in a lobby
try {
  var _ladder = document.getElementById('btnLadder');
  if (_ladder) _ladder.disabled = inLobby;
  var _login = document.getElementById('btnLogin');
  if (_login) _login.disabled = inLobby;
  var _signup = document.getElementById('btnSignup');
  if (_signup) _signup.disabled = inLobby;
  var _settings = document.getElementById('btnSettings');
  if (_settings) _settings.disabled = inLobby;
  var _logout = document.getElementById('btnLogout');
  if (_logout) _logout.disabled = inLobby;
} catch(_){}

    // Disable chat 'Send' when no pseudo
try {
  var _chatSend = document.getElementById('chatSend');
  if (_chatSend) _chatSend.disabled = !hasPseudo;
} catch(_){}
  }
  if (pseudoInput) {
    pseudoInput.addEventListener('input', updateButtonsDisabled, { passive: true });
    setTimeout(updateButtonsDisabled, 0);
    // === Robust nickname sync & uniqueness enforcement (client-side wiring) ===
    (function(){
      var __lastAcceptedPseudo = (window.myPseudo || '');
      function applyAcceptedPseudo(p){
        __lastAcceptedPseudo = p || '';
        window.myPseudo = __lastAcceptedPseudo;
        try { localStorage.setItem('zombi_pseudo', __lastAcceptedPseudo); } catch(_){}
      }
      try {
        if (window.socket) {
          window.socket.on('lobbyUpdate', function(data){
            try {
              var meId = (window.socket && socket.id) || null;
              var me = data && data.lobby && data.lobby.players ? data.lobby.players[meId] : null;
              if (me && typeof me.pseudo === 'string') {
                applyAcceptedPseudo(me.pseudo);
                if (window.pseudoInput && document.activeElement !== window.pseudoInput) { try { window.pseudoInput.value = me.pseudo; } catch(_){ } }
              }
            } catch(_){}
          });
        }
      } catch(_){}
      function sendRename(){
        try {
          if (!window.pseudoInput) return;
          var p = (window.pseudoInput.value || '').trim();
          if (!p) return;
          if (!(window.socket && socket.connected)) return;
          try { socket.emit('renamePseudo', { pseudo: p }); } catch(_){}
        } catch(_){}
      }
      if (window.pseudoInput) {
        // Trigger rename ONLY when the user finished typing: on blur or Enter
        window.pseudoInput.addEventListener('blur', function(){ sendRename(); }, { passive: true });
        window.pseudoInput.addEventListener('keydown', function(e){
          try {
            if (e && (e.key === 'Enter' || e.keyCode === 13)) { e.preventDefault(); sendRename(); }
          } catch(_){}
        }, { passive: false });
      }
      try {
        if (window.socket) {
          if (window.socket.off) window.socket.off('renameResult');
          window.socket.on('renameResult', function(res){
            try {
              if (res && res.ok && res.pseudo) {
                applyAcceptedPseudo(res.pseudo);
                if (window.pseudoInput && document.activeElement !== window.pseudoInput) { try { window.pseudoInput.value = res.pseudo; } catch(_){ } }
              } else if (res && res.reason === 'pseudo_taken') {
                if (window.pseudoInput) {
                  window.pseudoInput.value = __lastAcceptedPseudo || '';
                  window.pseudoInput.style.background = '#3b0000';
                  setTimeout(function(){ try { window.pseudoInput.style.background = ''; } catch(_){ } }, 450);
                }
                window.myPseudo = __lastAcceptedPseudo || '';
                try { localStorage.setItem('zombi_pseudo', window.myPseudo); } catch(_){}
              }
            } catch(_){}
          });
        }
      } catch(_){}
    })();

  }
  if (window) window.updateButtonsDisabled = updateButtonsDisabled;
  // Load persisted pseudo from localStorage
  try {
    var savedP = localStorage.getItem('zombi_pseudo');
    if (savedP && pseudoInput && !pseudoInput.value) {
      pseudoInput.value = savedP;
      myPseudo = savedP; window.myPseudo = savedP;
      try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){}
    }
  } catch(_){}

  
if (btnCreate) {
    btnCreate.addEventListener('click', function(){
      try {
        if (!window.pseudoInput) window.pseudoInput = document.getElementById('pseudoInput');
        const hasPseudo = !!(window.pseudoInput && window.pseudoInput.value && window.pseudoInput.value.trim());
        if (!hasPseudo || btnCreate.disabled) {
          try { if (window.pseudoInput && !window.pseudoInput.value) window.pseudoInput.focus(); } catch(_) {}
          return;
        }
        const p = window.pseudoInput.value.trim();
        myPseudo = p; window.myPseudo = p;
        // Optimistically switch to manual lobby UI to avoid any flicker or crash
        try {
          window.lobbyJoined = true;
          showManual();
          try { renderManualPlayers(); } catch(_) {}
          try { updateButtonsDisabled(); } catch(_) {}
        } catch(_){}
        if (!window.socket || typeof socket.emit !== 'function') { console.error('Socket not ready on createLobby'); return; }
        btnCreate.disabled = true;
        socket.emit('createLobby', p, function(res){
          try {
            if (!res || !res.ok) {
              if (res && res.reason === 'pseudo_taken') {
                var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
                __alertPseudoTaken();
              }
              btnCreate.disabled = false; window.lobbyJoined = false; showMain(); return;
            }
                        try {
              if (res && res.ok && res.gameId && res.hostToken) {
                try { localStorage.setItem('zombi_host_game', String(res.gameId)); } catch(_){}
                try { localStorage.setItem('zombi_host_token', String(res.hostToken)); } catch(_){}
              }
            } catch(_){}
// Server will follow up with lobbyUpdate
          } catch(err) {
            console.error('createLobby callback error', err);
} finally {
            try { btnCreate.disabled = true; } catch(_) {}
          }
        });
      } catch(err) {
        console.error('Create lobby click error', err);
      }
    }, { passive: true });
  }

  if (btnJoinList) {
    btnJoinList.addEventListener('click', function(){
      if (!pseudoInput.value.trim() || btnJoinList.disabled) return;
      showList();
      requestLobbies();
      clearInterval(listInterval);
      listInterval = setInterval(requestLobbies, 2000);
    }, { passive: true });
  }

  if (btnBackList) {
    btnBackList.addEventListener('click', function(){
      showMain();
      try{
        if (pseudoInput){
          // Restore pseudo field state depending on login/join status
          var loggedIn = false;
          try {
            var btnLg = document.getElementById('btnLogout');
            loggedIn = !!(btnLg && btnLg.style.display !== 'none');
          } catch(_){ }
          pseudoInput.disabled = false;
          if (loggedIn || window.lobbyJoined) {
            pseudoInput.readOnly = true;
            try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }
          } else {
            pseudoInput.readOnly = false;
            try { pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }
          }
          if (window.myPseudo) pseudoInput.value = window.myPseudo;
        }
      }catch(_){ }
      clearInterval(listInterval);
      listInterval = null;
      try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){ }
    }, { passive: true });
  }

  if (btnBackManual) {
    btnBackManual.addEventListener('click', function(){
      try {
        const isHost = !!(window.lobbyData && window.lobbyData.hostId && socket && socket.id && window.lobbyData.hostId === socket.id);
        if (isHost) {
          socket.emit('hostBackManual', function(res){});
        } else {
          socket.emit('leaveLobby');
        }
      } catch(e){}
      showMain();
      window.lobbyJoined = false;
      try{ if (pseudoInput){ pseudoInput.disabled = false; 
          try { pseudoInput.readOnly = false; pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }if (window.myPseudo) pseudoInput.value = window.myPseudo; } }catch(_){}
      try { updateButtonsDisabled(); } catch(_) {}
    }, { passive: true });
  }
if (btnStartManual) {
    btnStartManual.addEventListener('click', function(){
      socket.emit('startManualLobby', function(res){
        // if not host, ignore; server will no-op
      });
    }, { passive: true });
  }

  function requestLobbies() {
    socket.emit('requestLobbies');
  }
  

socket.on('lobbiesList', function(list){
    if (!Array.isArray(list)) list = [];
    lobbiesList.innerHTML = '';
    if (!list.length) {
      const empty = document.createElement('div');
      empty.textContent = (TRANSLATIONS[currentLang] && TRANSLATIONS[currentLang].noLobbyAvailable) || 'No lobby available.';
      empty.style.color = '#ccc';
      empty.style.textAlign = 'center';
      lobbiesList.appendChild(empty);
      return;
    }
    list.forEach(lob => {
      const item = document.createElement('div');
      item.style.background = 'rgba(0,0,0,0.3)';
      item.style.border = '1px solid rgba(255,255,255,0.1)';
      item.style.borderRadius = '8px';
      item.style.padding = '8px';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      const names = (lob.players || []).join(', ');
      item.innerHTML = '<div><b>Lobby #' + lob.id + '</b> ‚Ä¢ (' + lob.count + '/' + (lob.max||6) + ') ‚Äî ' + names + '</div>';
      const btn = document.createElement('button');
      btn.textContent = (TRANSLATIONS[currentLang] && (TRANSLATIONS[currentLang].joinAction || TRANSLATIONS[currentLang].join)) || 'Join';
      btn.style.padding = '6px 12px';
      btn.style.background = '#3fa33f';
      btn.style.color = '#fff';
      btn.style.border = 'none';
      btn.style.borderRadius = '6px';
      btn.style.cursor = 'pointer';
      
      btn.onclick = function(){
        var raw = (pseudoInput && pseudoInput.value) ? pseudoInput.value : '';
        var p = (raw || '').trim().substring(0, 10).replace(/[^a-zA-Z0-9]/g, '');
        if (!p) {
          try { pseudoInput && pseudoInput.focus(); pseudoInput && (pseudoInput.style.background='#fdd'); setTimeout(function(){ try{ pseudoInput.style.background=''; }catch(_){ } }, 600); } catch(_){}
          return;
        }
        // Client-side pre-check against current lobby roster to prevent duplicates
        try {
          var list = Array.isArray(lob.players) ? lob.players : [];
          var taken = list.some(function(n){ return String(n||'').toLowerCase() === p.toLowerCase(); });
          if (taken) {
            try { var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            __alertPseudoTaken();
          } catch(_){}
          return;
          }
        } catch(_){}
        socket.emit('joinLobbyById', { gameId: lob.id, pseudo: p }, function(res){
          if (res && res.ok) {
            myPseudo = p; window.myPseudo = p;
            window.lobbyJoined = true;
            showManual();

            try {
              window.lobbyData = window.lobbyData || {};
              window.lobbyData.manual = true;
              window.lobbyData.started = false;
              if (typeof window.lobbyData.max !== 'number' || !window.lobbyData.max) window.lobbyData.max = 6;
              try {
                if (!window.lobbyData.players || typeof window.lobbyData.players !== 'object') window.lobbyData.players = {};
                if (window.socket && socket.id) window.lobbyData.players[socket.id] = { pseudo: window.myPseudo || p };
              } catch(_) {}
              if (!Number.isFinite(window.lobbyData.count) || window.lobbyData.count < 1) window.lobbyData.count = 1;
              if (typeof updateLobbyTexts === 'function') updateLobbyTexts();
            } catch(_){}

            renderManualPlayers();
            try { updateButtonsDisabled(); } catch(_) {}
          } else if (res && res.reason === 'pseudo_taken') {
            try { var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            __alertPseudoTaken(); } catch(_){}
          }
        });
      };

      item.appendChild(btn);
      lobbiesList.appendChild(item);
    });
  });

function renderManualPlayers() {
  try {
    const playersObj = (typeof lobbyData === 'object' && lobbyData && lobbyData.players) ? lobbyData.players : {};
    const entries = Object.entries(playersObj); // [ [id, {pseudo, ready}],  ]
    const emptyLabel = (TRANSLATIONS[currentLang] && TRANSLATIONS[currentLang].emptySlot) || 'empty';
    const isHost = !!(window.lobbyData && window.lobbyData.hostId && window.socket && window.socket.id && window.lobbyData.hostId === socket.id);
    const tr = (window.TRANSLATIONS && (TRANSLATIONS[currentLang] || TRANSLATIONS['en'])) || {};
    const kickTxt = tr.kick || 'Kick';

    // Build up to 6 slots
    let cells = [];
    for (let i = 0; i < 6; i++) {
      if (i < entries.length) {
        const sid = entries[i][0];
        const p = entries[i][1] || {};
        const name = (p && p.pseudo) ? p.pseudo : '';
        const canKick = isHost && sid !== socket.id; // host cannot kick self
        let inner = '<div style="display:flex;align-items:center;gap:8px;">'
                    + '<span>' + (name || '') + '</span>' + (((window.lobbyData && window.lobbyData.hostId === sid) || (!window.lobbyData?.hostId && entries && entries.length === 1 && window.socket && sid === window.socket.id)) ? '<span class="host-crown" title="Host" aria-label="Host" style="margin-left:6px">üëë</span>' : '' )+ (canKick ? '<button class="kick-btn" data-target="' + sid + '" style="padding:4px 8px;font-size:12px;cursor:pointer;background:#b00020;color:#fff;border:none;border-radius:4px;margin-left:auto;">'+kickTxt+'</button>' : '')
                    + '</div>';
        cells.push({ inner, empty:false });
      } else {
        cells.push({ inner: emptyLabel, empty:true });
      }
    }

    let html = '';
    html += '<table style="margin:8px auto;border-collapse:separate;border-spacing:6px;">';
    for (let r = 0; r < 2; r++) {
      html += '<tr>';
      for (let c = 0; c < 3; c++) {
        const idx = r * 3 + c;
        const cell = cells[idx];
        var bg = cell.empty ? 'rgba(255,255,255,0.06)' : 'rgba(72,199,73,0.18)';
        var border = '1px solid rgba(255,255,255,0.12)';
        var color = cell.empty ? '#bbb' : '#fff';
        html += '<td style="min-width:120px;padding:10px 14px;background:'+bg+';border:'+border+';border-radius:8px;text-align:left;color:'+color+';">' + cell.inner + '</td>';
      }
      html += '</tr>';
    }
    html += '</table>';
    const container = (typeof manualPlayers !== 'undefined' && manualPlayers) ? manualPlayers : document.getElementById('manualLobbyPlayers');
    if (container) container.innerHTML = html;
  } catch(e) {}

  try { if (typeof translateEmptySlotsInManualLobby === 'function') translateEmptySlotsInManualLobby(); } catch(_){}
}  function safe(fn){ try{ fn(); }catch(e){} }

  // Hide legacy timer/status elements globally
  safe(function(){
    var t = document.getElementById('lobbyTimer'); if (t){ t.style.display='none'; t.textContent=''; }
    var s = document.getElementById('lobbyStatus'); if (s){ s.style.display='none'; s.textContent=''; }
  });

  // Replace updateLobbyTexts to remove timer/waiting and only show players in manual lobbies
  window.updateLobbyTexts = function(){
  try {
    var tr = (window.TRANSLATIONS && (window.TRANSLATIONS[window.currentLang] || window.TRANSLATIONS['en'])) || {};
    var manualPanel = document.getElementById('manualLobbyPanel');
    var lobbyPlayersEl = document.getElementById('lobbyPlayers');
    var showPlayers = manualPanel && manualPanel.style.display !== 'none';
    var max = 6, count = 0;
    try { max = Number((window.lobbyData && window.lobbyData.max) || 6) || 6; } catch(_){ max = 6; }
    try {
      if (window.lobbyData && window.lobbyData.players && typeof window.lobbyData.players === 'object') {
        count = Object.keys(window.lobbyData.players).length;
      } else if (window.lobbyData && Array.isArray(window.lobbyData.players)) {
        count = window.lobbyData.players.length;
      } else if (typeof window.lobbyData?.count !== 'undefined') {
        count = Number(window.lobbyData.count) || 0;
      }
    } catch(_){ count = Number(window.lobbyData && window.lobbyData.count) || 0; }
    if (lobbyPlayersEl) lobbyPlayersEl.textContent = showPlayers ? ((tr.playersInGame || 'Players in game') + ' : ' + count + '/' + max) : '';
    // Hide legacy timer/status unconditionally in this global updater
    try { var t = document.getElementById('lobbyTimer'); if (t){ t.style.display='none'; t.textContent=''; } } catch(_){}
    try { var s = document.getElementById('lobbyStatus'); if (s){ s.style.display='none'; s.textContent=''; } } catch(_){}
  } catch(_){}
};

  // Wrap updateUITexts to force the "Join" label (no waiting state on main)
  if (typeof window.updateUITexts === 'function'){
    var _updateUITexts = window.updateUITexts;
    window.updateUITexts = function(){
      try { _updateUITexts.apply(this, arguments); } catch(_){}
      var tr = (window.TRANSLATIONS && window.TRANSLATIONS[window.currentLang]) || (window.TRANSLATIONS && window.TRANSLATIONS['en']) || {};
      var lobbyJoin = document.getElementById('lobbyJoin');
      if (lobbyJoin) lobbyJoin.textContent = tr.join || 'Join';

// Keep the Join button localized even if other code changes its text
(function(){
  const el = document.getElementById('lobbyJoin');
  if (!el) return;
  const ensure = () => {
    const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
    const expected = (tr.join || 'Join');
    if (el.textContent !== expected) el.textContent = expected;
  };
  const mo = new MutationObserver(ensure);
  mo.observe(el, {characterData:true, childList:true, subtree:true});
  ensure();
})();
    };
  }

  // Ensure Replay returns to lobby (reload)
  safe(function(){
    var btnReplay = document.getElementById('btnReplay');
    if (btnReplay) btnReplay.onclick = function(){ try { location.reload(); } catch(_){} };
  });

  // Override main Join click to start solo immediately (server handles launch)
  safe(function(){
    var lobbyJoin = document.getElementById('lobbyJoin');
    var pseudoInput = document.getElementById('pseudoInput');
    if (lobbyJoin){
      lobbyJoin.onclick = function(){
        if (!pseudoInput || !pseudoInput.value || !pseudoInput.value.trim()){
          if (pseudoInput){ pseudoInput.focus(); pseudoInput.style.background = '#fdd'; setTimeout(function(){ pseudoInput.style.background=''; }, 600); }
          return;
        }
        socket.emit('setPseudoAndReady', (pseudoInput && pseudoInput.value || '').trim()); try { localStorage.setItem('zombi_last_pseudo', String((pseudoInput && pseudoInput.value || '').trim())); } catch(_) {}
        window.lobbyJoined = true;
        try { lobbyJoin.disabled = true; if (pseudoInput) pseudoInput.readOnly = true; 
          try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }} catch(_){}
        try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){}
      };
    }
  });

  // Clear players line on main load until manual panel is visible
  safe(function(){ var p = document.getElementById('lobbyPlayers'); if (p) p.textContent=''; });

})();
</script>

<script>
(function(){
  function setVersionBox(){
    try{
      var langRaw = (typeof window.currentLang === 'string' && window.currentLang)
                 || (typeof currentLang === 'string' && currentLang)
                 || ((navigator.language||'en').slice(0,2));
      // normalize aliases coming from browser locales
      var alias = { ja:'jp', zh:'cn', ko:'kr' };
      var lang = alias[langRaw] || langRaw;
      var tr = (window.TRANSLATIONS && (TRANSLATIONS[lang]||TRANSLATIONS['en'])) || {};
      var el = document.getElementById('versionBox');
      if (!el) return;
      var ver = (typeof window.GAME_VERSION==='string' ? window.GAME_VERSION : '1.0.0');
      var fallbackTpl = {
        en:'Version {v} by Myg',
        fr:'Version {v} par Myg',
        es:'Versi√≥n {v} por Myg',
        pt:'Vers√£o {v} por Myg',
        de:'Version {v} von Myg',
        ru:'–í–µ—Ä—Å–∏—è {v} –æ—Ç Myg',
        cn:'ÁâàÊú¨ {v} Áî± Myg',
        jp:'„Éê„Éº„Ç∏„Éß„É≥ {v}ÔºàMygÔºâ',
        pl:'Wersja {v} od Myg',
        kr:'Î≤ÑÏ†Ñ {v} - Myg'
      }[lang] || 'Version {v} by Myg';
      var tpl = tr.versionBy || fallbackTpl;
      el.textContent = tpl.replace('{v}', ver);
    }catch(_){}
}
  // First display
  setVersionBox();
  // Retry hook once DOM and all scripts are loaded (ensures updateUITexts exists)
  function tryHook(){
    if (typeof window.updateUITexts === 'function') {
      var _u = window.updateUITexts;
      window.updateUITexts = function(){
        try { _u.apply(this, arguments); } catch(_){}
        setVersionBox();
      };
    } else {
      // if not yet defined, try again on next tick
      setTimeout(tryHook, 50);
    }
  }
  tryHook();
  // Also refresh on visibility change just in case
  document.addEventListener('visibilitychange', function(){ if(!document.hidden) setVersionBox(); }, {passive:true});
  window.addEventListener('resize', setVersionBox, {passive:true});
  window.setVersionBox = setVersionBox;
})();
</script>

<script>
// --- Join lobby count badge (polling every 2s) ---
(function(){
  var openLobbyCount = 0;

  function updateJoinLobbyBtnText(){
    try {
      var btn = document.getElementById('btnJoinLobbyList');
      if (!btn) return;
      var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
      var base = tr.joinLobby || 'Join lobby';
      btn.textContent = base + ' (' + (openLobbyCount|0) + ')';
    } catch(e){}
  }

  // Hook into updateUITexts so localization is preserved and the count suffix stays
  (function hookUpdateUITexts(){
    try {
      if (typeof window.updateUITexts === 'function') {
        var _u = window.updateUITexts;
        window.updateUITexts = function(){
          try { _u.apply(this, arguments); } catch(_){}
          updateJoinLobbyBtnText();
        };
      } else {
        // if not yet defined, try again a bit later
        setTimeout(hookUpdateUITexts, 50);
      }
    } catch(e){}
  })();

  // Update the cached count whenever the server sends the lobbies list
  try {
    if (window.socket) {
      socket.on('lobbiesList', function(list){
        try { openLobbyCount = Array.isArray(list) ? list.length : 0; } catch(e){ openLobbyCount = 0; }
        updateJoinLobbyBtnText();
      });
    }
  } catch(e){}

  // Poll count every 2 seconds, but skip if the list panel is already visible (it's already polling)
  var __lobbyCountInterval = setInterval(function(){
    try {
      if (!window.socket || !socket.connected) return;
      var panel = document.getElementById('joinLobbyPanel');
      if (panel && panel.style.display === 'block') return; // join list already polling
      socket.emit('requestLobbies'); // reuse existing endpoint
    } catch(e){}
  }, 2000);

  // Clean up on unload
  window.addEventListener('beforeunload', function(){ try{ clearInterval(__lobbyCountInterval); }catch(_){}});

  // Initial paint
  updateJoinLobbyBtnText();
})();
</script>

<script>
(function(){
  function setMenuUIHidden(on){ try { document.body.classList.toggle('menu-hide-ui', !!on); } catch(e){} }
  // Initially hide until game starts
  setMenuUIHidden(true);
  try {
    socket.on('lobbyUpdate', function(data){
      try { setMenuUIHidden(!(data && data.started)); } catch(_){}
    });
    socket.on('gameStarted', function(){ setMenuUIHidden(false); });
  } catch(e){}
  // In case UI functions are used elsewhere
  window.setMenuUIHidden = setMenuUIHidden;
})();
</script>

<script>
(function(){
  try {
    var container = document.getElementById('manualLobbyPlayers');
    if (container) {
      container.addEventListener('click', function(ev){
        var btn = ev.target && ev.target.closest && ev.target.closest('.kick-btn');
        if (!btn) return;
        if (!window.socket) return;
        var targetId = btn.getAttribute('data-target');
        if (!targetId) return;
        // Only host will see the button; server will re-check permissions
        try { socket.emit('kickPlayer', { targetId: targetId }); } catch(e){}
      });
    }
  } catch(e){}

  try {
    if (window.socket) {
      
          
          socket.on('kicked', function(info){
            // Force back to main menu without relying on local-scope functions
            try {
              var panel = document.getElementById('manualLobbyPanel');
              if (panel) panel.style.display = 'none';
            } catch(_){}
            try {
              var listPanel = document.getElementById('joinLobbyPanel');
              if (listPanel) listPanel.style.display = 'none';
            } catch(_){}
            try { window.lobbyJoined = false; } catch(_){}
            try {
              if (window.pseudoInput) {
                pseudoInput.style.display = '';
                pseudoInput.disabled = false;
                
          try { pseudoInput.readOnly = false; pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }if (!pseudoInput.value && window.myPseudo) pseudoInput.value = window.myPseudo;
                try { pseudoInput.focus(); } catch(_){}
              }
            } catch(_){}
            try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){}
            try {
              var tr = (window.TRANSLATIONS && (TRANSLATIONS[currentLang] || TRANSLATIONS['en'])) || {};
              var wait = (info && info.until && info.until > Date.now()) ? Math.ceil((info.until - Date.now())/1000) : 30;
              var msg = (tr && tr.kickedMsg) ? tr.kickedMsg.replace('{s}', String(wait)) : ('You were kicked. You can rejoin in ~' + wait + 's.');
              alert(msg);
            } catch(_){}
          });
}
  } catch(e){}
})();
</script>

<div id="chatPanel" role="region" aria-label="Chat">
  <div id="chatHeader">
    <div id="chatTitle">Chat</div>
    <button id="chatToggle" title="Collapse">‚Äì</button>
  </div>
  <div id="chatTabs">
    <button id="tabWorld" class="chatTab active">World chat</button>
    <button id="tabLobby" class="chatTab">Lobby chat</button>
  </div>
  <div id="chatMessages" aria-live="polite"></div>
  <div id="chatInputRow">
    <input id="chatInput" type="text" maxlength="50" placeholder="Message (max 50)" />
    <button id="chatSend">Send</button>
  </div>
</div>
<button id="chatCollapsedBtn" title="Chat">üí¨</button>

<script>(function(){
  const MAX_LEN = 50;
  const COOLDOWN_MS = 2000;
  let lastSent = 0;

  let currentChannel = 'world'; // 'world' | 'lobby'
  let pendingHistoryFor = null;
  const chatBuf = { world: [], lobby: [] };
  const chatSeen = { world: new Set(), lobby: new Set() };

  let inGame = false;
  let inManualLobby = false;
  let __chatBoundTo = null;
  let __chatPrevMode = null;

  function qs(id){ return document.getElementById(id); }
  const panel = qs('chatPanel');
  const toggle = qs('chatToggle');
  const title = qs('chatTitle');
  const list = qs('chatMessages');
  const input = qs('chatInput');
  const sendBtn = qs('chatSend');
  const collapsedBtn = qs('chatCollapsedBtn');
  const tabWorld = qs('tabWorld');
  const tabLobby = qs('tabLobby');

  try { if (typeof window.updateButtonsDisabled === 'function') window.updateButtonsDisabled(); } catch(_){}
  // Toggle / expand handlers
  if (toggle) toggle.addEventListener('click', function(){ setCollapsed(true); }, {passive:true});
  if (collapsedBtn) collapsedBtn.addEventListener('click', function(){ setCollapsed(false); }, {passive:true});

  // -- Helper: position collapsed button above HUD (best-effort)
  function positionCollapsedBtn(){
    try{
      if (!collapsedBtn) return;
      if (!inGame) { collapsedBtn.style.bottom = '12px'; return; }
      var hud = document.getElementById('hudStats') || document.getElementById('hudAlive') || document.getElementById('hudMoney');
      if (hud && hud.getBoundingClientRect){
        var r = hud.getBoundingClientRect();
        var fromBottom = Math.max(12, Math.round(window.innerHeight - r.top + 12));
        collapsedBtn.style.bottom = fromBottom + 'px';
      } else {
        collapsedBtn.style.bottom = '12px';
      }
    }catch(e){}
  }

  // i18n
  function applyChatI18n(){
    try{
      const tr = (window.TRANSLATIONS && (TRANSLATIONS[currentLang] || TRANSLATIONS['en'])) || {};
      title.textContent = tr.chat || 'Chat';
      tabWorld.textContent = tr.worldChat || 'World chat';
      tabLobby.textContent = tr.lobbyChat || 'Lobby chat';
      sendBtn.textContent = tr.send || 'Send';
      input.placeholder = tr.chatPlaceholder || 'Message (max 50)';
      toggle.title = tr.collapse || 'Collapse';
      collapsedBtn.title = tr.chat || 'Chat';
    }catch(e){}
  }
  applyChatI18n();
  if (typeof window.updateUITexts === 'function'){
    const _u = window.updateUITexts;
    window.updateUITexts = function(){ try{ _u.apply(this, arguments); }catch(_){}
      applyChatI18n();
    };
  }

  // Collapse/expand
  function setCollapsed(on){
    if (on){
      if (panel) panel.style.display = 'none';
      if (collapsedBtn) collapsedBtn.style.display = 'flex';
      positionCollapsedBtn();
      try { localStorage.setItem('chatCollapsed','1'); } catch(_){}
    } else {
      if (panel) panel.style.display = 'flex';
      if (collapsedBtn) collapsedBtn.style.display = 'none';
      if (collapsedBtn) collapsedBtn.classList.remove('notify');
      positionCollapsedBtn();
      try { localStorage.setItem('chatCollapsed','0'); } catch(_){}
      try { input && input.focus(); } catch(_){}
    }
  }

  // Render from buffer
  function renderChannel(ch){
    try{
      chatSeen[ch] = new Set((chatBuf[ch]||[]).map(m => ((m.sid||'')+'|'+(m.text||'')+'|'+Math.floor((m.ts||0)/2000))));
      const arr = (chatBuf[ch]||[]);
      list.innerHTML = '';
      for (let i=0;i<arr.length;i++){
        const msg = arr[i];
        const name = msg && msg.pseudo ? String(msg.pseudo) : 'player';
        const text = msg && msg.text ? String(msg.text) : '';
        const div = document.createElement('div');
        div.className = 'chatLine';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'chatName';
        nameSpan.textContent = name + ':';
        div.appendChild(nameSpan);
        div.appendChild(document.createTextNode(text));
        list.appendChild(div);
      }
      list.scrollTop = list.scrollHeight + 1000;
    }catch(e){}
  }

  // Select channel
  function pushMsg(msg){
    try{
      if (!msg) return;
      const ch = msg && msg.channel ? ((msg.channel === 'lobby') ? 'lobby' : 'world') : currentChannel;
      const arr = chatBuf[ch] = chatBuf[ch] || [];
      const key = ((msg.sid||'')+'|'+(msg.text||'')+'|'+Math.floor((msg.ts||0)/2000));
      if (chatSeen[ch] && chatSeen[ch].has(key)) { return; }
      try { chatSeen[ch].add(key); } catch(_){}
      arr.push(msg); if (arr.length > 200) arr.shift();
      if (ch === currentChannel){
        const name = msg && msg.pseudo ? String(msg.pseudo) : 'player';
        const text = msg && msg.text ? String(msg.text) : '';
        const div = document.createElement('div');
        div.className = 'chatLine';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'chatName';
        nameSpan.textContent = name + ':';
        div.appendChild(nameSpan);
        div.appendChild(document.createTextNode(text));
        list.appendChild(div);
        list.scrollTop = list.scrollHeight + 1000;
        while (list.childElementCount > 200) list.removeChild(list.firstElementChild);
      }
    }catch(e){}
  }

  function selectChannel(ch){
    if (ch !== 'world' && ch !== 'lobby') ch = 'world';
    if (collapsedBtn && ch === 'lobby') { try { collapsedBtn.classList.remove('notify'); } catch(_){} }
    if (tabLobby && ch === 'lobby') { try { tabLobby.classList.remove('notify'); } catch(_){} }
    if (tabWorld && ch === 'world') { try { tabWorld.classList.remove('notify'); } catch(_){} }
    if (ch === currentChannel) return;
    currentChannel = ch;
    tabWorld.classList.toggle('active', ch === 'world');
    tabLobby.classList.toggle('active', ch === 'lobby');
    renderChannel(currentChannel);
    pendingHistoryFor = ch;
    try { if (window.socket) window.socket.emit('chat:join', { channel: ch }); } catch(_){ }
    applyChatI18n();
  }
  if (tabWorld) tabWorld.addEventListener('click', function(){ selectChannel('world'); });
  if (tabLobby) tabLobby.addEventListener('click', function(){ selectChannel('lobby'); });

  // Send
  function send(){
    try {
      if (!window.socket || !window.socket.connected) return;
      const now = Date.now();
      // Block sending if no pseudo entered
      try {
        var __pi = window.pseudoInput || document.getElementById('pseudoInput');
        var __has = !!(__pi && __pi.value && __pi.value.trim());
        if (!__has) { if (__pi) try { __pi.focus(); } catch(_){ } return; }
      } catch(_){}
      if (now - lastSent < COOLDOWN_MS) return;
      let t = (input.value || '').replace(/[\r\n\t]/g,' ').trim();
      if (!t) return;
      if (t.length > MAX_LEN) t = t.slice(0, MAX_LEN);
      window.socket.emit('chat:send', { channel: currentChannel, text: t, name: (window.myPseudo || '') });
      lastSent = now;
      input.value = '';
    } catch(e){}
  }
  if (sendBtn) sendBtn.addEventListener('click', send);
  if (input) input.addEventListener('keydown', function(ev){
    if (ev.key === 'Enter'){ ev.preventDefault(); send(); }
  });

  // Socket bindings
  function initSocketBindings(){
    try {
      if (!window.socket) return false;
      if (!panel) return false;
      if (__chatBoundTo === window.socket) return true;
      __chatBoundTo = window.socket;

      panel.style.display = 'flex';
      window.socket.emit('chat:join', { channel: currentChannel });

      if (window.socket.off){
        window.socket.off('chat:history');
        window.socket.off('chat:msg');
        window.socket.off('chat:error');
      }
      window.socket.on('chat:history', function(payload){
        try{
          if (!payload) return;
          var __chan = (payload && payload.channel) ? payload.channel : currentChannel;
          chatBuf[__chan] = (payload.history||[]);
          chatSeen[__chan] = new Set((chatBuf[__chan]||[]).map(m => ((m.sid||'')+'|'+(m.text||'')+'|'+Math.floor((m.ts||0)/2000))));
          if (__chan === currentChannel) renderChannel(currentChannel);
          if (pendingHistoryFor === __chan) pendingHistoryFor = null;
        }catch(_){}
      });
      window.socket.on('chat:msg', function(msg){
        try {
          var isCollapsed = panel && panel.style && panel.style.display === 'none';
          if (isCollapsed && msg && msg.channel === 'lobby' && collapsedBtn) collapsedBtn.classList.add('notify');
          // Notify world on collapsed when not in game (menu or lobby)
          if (isCollapsed && msg && msg.channel === 'world' && !inGame && collapsedBtn) collapsedBtn.classList.add('notify');
          if (!isCollapsed && msg && msg.channel === 'lobby' && currentChannel !== 'lobby' && tabLobby) tabLobby.classList.add('notify');
          if (!isCollapsed && msg && msg.channel === 'world' && currentChannel !== 'world' && tabWorld) tabWorld.classList.add('notify');
        } catch(_){ }
        try {
  var __ua = (navigator.userAgent||'');
  var __isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(__ua);
  var __isSelf = !!(msg && msg.sid && window.socket && (msg.sid === window.socket.id));
  if (__isMobile && inGame && isCollapsed && !__isSelf && collapsedBtn) {
    collapsedBtn.classList.add('notify');
  }
} catch(_){ }
        pushMsg(msg);
      });window.socket.on('chat:error', function(e){
        if (!e || e.type !== 'cooldown') return;
        try { sendBtn.disabled = true; setTimeout(function(){ sendBtn.disabled = false; }, Math.min(1200, e.waitMs || 1000)); } catch(_){}
      });
      window.socket.on('connect', function(){ try { __chatBoundTo = null; initSocketBindings(); } catch(_){}});
      window.socket.on('reconnect', function(){ try { __chatBoundTo = null; initSocketBindings(); } catch(_){}});
      window.socket.on('gameStarted', function(info){ inGame = true; updateTabs(); positionCollapsedBtn(); try { var humans=0; var pls=(info&&info.players)||{}; for (var k in pls){ if(!Object.prototype.hasOwnProperty.call(pls,k)) continue; var p=pls[k]; if(p&&p.isBot) continue; humans++; } if (humans >= 2) { setCollapsed(true); } } catch(_){ }});
      return true;
    } catch(e){ return false; }
  }
  positionCollapsedBtn();
  if (window.socket) initSocketBindings();
  var __chatTry = setInterval(function(){ if (initSocketBindings()){ clearInterval(__chatTry); } }, 300);

  // Periodic history refresh (fallback)
  setInterval(function(){
    try {
      if (window.socket && window.socket.connected) {
        window.socket.emit('chat:join', { channel: currentChannel });
      }
    } catch(_){}
  }, 2000);

  // Modes & tabs
  function updateTabs(){
    const modeMain = (!inManualLobby && !inGame);
    const modeLobby = (inManualLobby && !inGame);
    const modeGame = inGame;
    const newMode = modeGame ? 'game' : (modeLobby ? 'lobby' : 'main');
    if (__chatPrevMode === newMode) return;
    __chatPrevMode = newMode;

    if (newMode === 'main'){
      tabWorld.style.display = '';
      tabLobby.style.display = 'none';
      if (currentChannel !== 'world') selectChannel('world');
    } else if (newMode === 'lobby'){
      tabWorld.style.display = '';
      tabLobby.style.display = '';
    } else {
      tabWorld.style.display = 'none';
      tabLobby.style.display = '';
      if (currentChannel !== 'lobby') selectChannel('lobby');
    }
  }

  function refreshLobbyMode(){
    try {
      var pnl = document.getElementById('manualLobbyPanel');
      inManualLobby = !!(pnl && pnl.style && pnl.style.display !== 'none');
      updateTabs();
      positionCollapsedBtn();
    } catch(_){}
  }
  // show by default, ignore previous collapsed state
  try { localStorage.removeItem('chatCollapsed'); } catch(_){}
  setCollapsed(false);
  setInterval(refreshLobbyMode, 1500);
  window.addEventListener('resize', positionCollapsedBtn);
})();</script>
<script>
/* === SOLO MODE CHAT HIDING (client-only, robust & non-invasive) ===
   Hides both the chat panel and the collapsed chat button whenever a game is started
   with only one human player (solo). Re-enables chat automatically when back to lobby/menu.
   Does not modify server behavior.
*/
(function(){
  try {
    var FORCED_HIDE = false;

    function getEl(id){ return document.getElementById(id); }
    function applyVisibility(){
      try {
        var panel = getEl('chatPanel');
        var btn = getEl('chatCollapsedBtn');
        if (!panel || !btn) return;
        if (FORCED_HIDE) {
          panel.style.display = 'none';
          btn.style.display = 'none';
          // clear any visual notifications to avoid stale UI when re-enabled
          try { btn.classList.remove('notify'); } catch(_) {}
          try { var tabW = getEl('tabWorld'); tabW && tabW.classList.remove('notify'); } catch(_) {}
          try { var tabL = getEl('tabLobby'); tabL && tabL.classList.remove('notify'); } catch(_) {}
        } else {
          // do not force-show; keep existing collapse state managed by the chat script
        }
      } catch(_){}
    }

    function isSoloFromPayload(info){
      try {
        var players = (info && info.players) || {};
        var humans = 0;
        for (var id in players){
          if (!players.hasOwnProperty(id)) continue;
          var p = players[id];
          if (p && p.isBot) continue;
          humans++;
        }
        return humans <= 1;
      } catch(_){ return false; }
    }

    if (window.socket && typeof window.socket.on === 'function') {
      // When a game starts, hide chat if solo; otherwise ensure it's not forced-hidden
      window.socket.on('gameStarted', function(info){
        try {
          FORCED_HIDE = !!isSoloFromPayload(info);
          applyVisibility();
        } catch(_){}
      });

      // When we return to the lobby (game not started), re-enable chat
      window.socket.on('lobbyUpdate', function(data){
        try {
          if (!data || data.started === false) {
            FORCED_HIDE = false;
            applyVisibility();
          }
        } catch(_){}
      });

      // Also on reconnect, reset the forced flag (state will re-apply on next events)
      window.socket.on('reconnect', function(){ try { FORCED_HIDE = false; applyVisibility(); } catch(_){}});
    }

    // Expose for debugging if needed
    window.__forceHideChatSolo = function(on){ FORCED_HIDE = !!on; applyVisibility(); };
  } catch(_){}
})();
</script>

<script>
(function(){
  try {
    if (window.socket) {
      socket.on('setPseudoAndReadyResult', function(res){
        try {
          if (!res || res.ok) return;
          var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
          __alertPseudoTaken();
        } catch(_){}
      });
      socket.on('renameResult', function(res){
        try {
          if (!res || res.ok) return;
          if (res && res.reason === 'pseudo_taken') {
            var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            __alertPseudoTaken();
          }
        } catch(_){}
      });
    }
  } catch(_){}
})();
</script>
<script>
function __alertPseudoTaken(){
  try {
    var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
    alert(tr.pseudoTaken || 'Nickname already in use.');
  } catch(_) { alert('Nickname already in use.'); }
}
</script>

<script>
// Robust listener to ensure popup on pseudo_taken for chat send, even if other handlers exist.
(function ensurePseudoTakenPopup(){
  function bind(){
    try{
      if (!window.socket || !window.socket.on) return false;
      window.socket.on('chat:error', function(e){
        try{
          if (e && e.type === 'pseudo_taken') {
            var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            alert(tr.pseudoTaken || 'Nickname already in use.');
          }
        }catch(_){}
      });
      return true;
    }catch(_){ return false; }
  }
  if (!bind()){
    var __ptint = setInterval(function(){ if (bind()) { clearInterval(__ptint); } }, 300);
  }
})();
</script>

<script>
// Robust listener to ensure popup on pseudo_taken for Join lobby actions (server-side signal)
(function ensureJoinPseudoTakenPopup(){
  function bind(){
    try{
      if (!window.socket || !window.socket.on) return false;
      window.socket.on('join:error', function(e){
        try{
          if (e && e.type === 'pseudo_taken') {
            var tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
            alert(tr.pseudoTaken || 'Nickname already in use.');
          }
        }catch(_){}
      });
      return true;
    }catch(_){ return false; }
  }
  if (!bind()){
    var __jpt = setInterval(function(){ if (bind()) { clearInterval(__jpt); } }, 300);
  }
})();
</script>

<!-- MOBILE LOBBY RESIZE PATCH JS -->
<script id="mobile-lobby-resize-patch-js">
(function(){
  // Compute reliable 1% viewport height in px, update --vh on resize/keyboard/orientation
  function setVH() {
    try {
      var h = (window.visualViewport && window.visualViewport.height) || window.innerHeight || document.documentElement.clientHeight || 0;
      if (h > 0) document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
    } catch(_) {}
  }
  setVH();
  window.addEventListener('resize', setVH, {passive:true});
  window.addEventListener('orientationchange', setVH, {passive:true});
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', setVH);
    window.visualViewport.addEventListener('scroll', setVH); // some UIs move on keyboard
  }

  // Fallback: if content still taller than viewport, scale the box down slightly.
  function fitLobbyBoxMobile(){
    try {
      var box = document.getElementById('lobbyBox');
      var screen = document.getElementById('lobbyScreen');
      if (!box || !screen) return;
      if (window.matchMedia('(min-width: 769px)').matches) {
        box.style.transform = '';
        box.style.transformOrigin = '';
        return;
      }
      var vh = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
      var maxH = Math.max(200, vh - 24);
      box.style.maxHeight = maxH + 'px';
      box.style.overflowY = 'auto';

      // Only scale down when even with scroll the box would overflow viewport badly
      // (rare on iOS with toolbars showing). Clamp between 0.82 and 1.
      var contentHeight = box.scrollHeight;
      var scale = Math.min(1, Math.max(0.82, maxH / (contentHeight + 8)));
      if (scale < 1) {
        box.style.transformOrigin = 'center';
        box.style.transform = 'scale(' + scale.toFixed(3) + ')';
      } else {
        box.style.transform = '';
        box.style.transformOrigin = '';
      }
    } catch(e){}
  }
  // Observe changes inside the lobby to refit when panels switch
  var mo;
  function ensureObserver(){
    try{
      if (mo) return;
      var box = document.getElementById('lobbyBox');
      if (!box) return;
      mo = new MutationObserver(function(){ fitLobbyBoxMobile(); });
      mo.observe(box, {childList:true, subtree:true, attributes:true});
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    setVH(); fitLobbyBoxMobile(); ensureObserver();
  });
  window.addEventListener('load', function(){
    setVH(); fitLobbyBoxMobile(); ensureObserver();
  });
  window.addEventListener('resize', fitLobbyBoxMobile, {passive:true});
  if (window.visualViewport) window.visualViewport.addEventListener('resize', fitLobbyBoxMobile);
})();
</script>

<script>
/* === AUTH CLIENT === */
(function(){
  'use strict';
  function trAuth(key, fallback){
    try {
      const lang = (window.currentLang || 'en');
      const pack = (window.TRANSLATIONS && window.TRANSLATIONS[lang]) || (window.TRANSLATIONS && window.TRANSLATIONS['en']) || {};
      return pack[key] || fallback || key;
    } catch(e){ return fallback || key; }
  }
  const btnLogin = document.getElementById('btnLogin');
  const btnSignup = document.getElementById('btnSignup');
  const btnLogout = document.getElementById('btnLogout');
  const btnSettings = document.getElementById('btnSettings');
  const modal = document.getElementById('authModal');
  const overlay = document.getElementById('authModalOverlay');
  const modalTitle = document.getElementById('authModalTitle');
  const modalBody = document.getElementById('authModalBody');
  const btnCancel = document.getElementById('authCancel');
  const btnSubmit = document.getElementById('authSubmit');
  const pseudoInput = document.getElementById('pseudoInput');
  const lobbyJoin = document.getElementById('lobbyJoin');
  const btnJoinLobbyList = document.getElementById('btnJoinLobbyList');
  const btnCreateLobby = document.getElementById('btnCreateLobby');
  let reservedPseudo = false;
  let loggedUser = null;

  function setAuthUI(loggedIn, username){
    try {
      if (btnLogin) btnLogin.style.display = loggedIn ? 'none' : '';
      if (btnSignup) btnSignup.style.display = loggedIn ? 'none' : '';
      if (btnLogout) btnLogout.style.display = loggedIn ? '' : 'none';
      if (btnSettings) btnSettings.style.display = loggedIn ? '' : 'none';
    } catch(_){}
    try {
      if (pseudoInput) {
        if (loggedIn) {
          pseudoInput.value = username || '';
          pseudoInput.readOnly = true;
          
          try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }window.myPseudo = username || '';
          try { localStorage.setItem('zombi_pseudo', window.myPseudo); } catch(_){}
        } else {
          pseudoInput.disabled = false;
        
          try { pseudoInput.readOnly = false; pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }}
        if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled();
      }
    } catch(_){}
    loggedUser = loggedIn ? (username || '') : null;
    validatePseudoBlocking(); // re-validate
  }

  function updateAuthTexts(){
    try {
      if (btnLogin) btnLogin.textContent = trAuth('login','Log in');
      if (btnSignup) btnSignup.textContent = trAuth('signup','Sign up');
      if (btnLogout) btnLogout.textContent = trAuth('signout','Sign out');
      if (btnSettings) btnSettings.textContent = trAuth('settings','Settings');
      if (modal && modal.style.display !== 'none') {
        document.getElementById('authCancel').textContent = trAuth('cancel','Cancel');
        document.getElementById('authSubmit').textContent = trAuth('submit','Submit');
      }
    } catch(_){}
  }
  window.updateAuthTexts = updateAuthTexts;

  // Hook into existing updateUITexts
  setTimeout(function(){
    try {
      if (typeof window.updateUITexts === 'function') {
        const _orig = window.updateUITexts;
        window.updateUITexts = function(){ try { _orig.apply(this, arguments); } catch(_){ } try { updateAuthTexts(); } catch(_){ } };
      } else {
        updateAuthTexts();
      }
    } catch(_){}
  }, 0);

  function showModal(kind){
    overlay.style.display = 'flex';
    modal.style.display = 'flex';
    if (kind === 'login') {
      modalTitle.textContent = trAuth('login','Log in');
      modalBody.innerHTML = ''
        + '<div style="display:flex;flex-direction:column;gap:8px;">'
        + '  <label>' + trAuth('username','Username') + '</label>'
        + '  <input id="authUser" maxlength="10" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('password','Password') + '</label>'
        + '  <input id="authPass" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '</div>';
      btnSubmit.onclick = doLogin;
    } else if (kind === 'signup') {
      modalTitle.textContent = trAuth('signup','Sign up');
      modalBody.innerHTML = ''
        + '<div style="display:flex;flex-direction:column;gap:8px;">'
        + '  <label>' + trAuth('username','Username') + '</label>'
        + '  <input id="authUser" maxlength="10" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('password','Password') + '</label>'
        + '  <input id="authPass" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('confirmPassword','Confirm your password') + '</label>'
        + '  <input id="authPass2" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '</div>';
      btnSubmit.onclick = doSignup;
    } else if (kind === 'settings') {
      modalTitle.textContent = trAuth('settings','Settings');
      modalBody.innerHTML = ''
        + '<div style="display:flex;flex-direction:column;gap:8px;">'
        + '  <label>' + trAuth('currentPassword','Current password') + '</label>'
        + '  <input id="currPass" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('newPassword','New password') + '</label>'
        + '  <input id="newPass" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '  <label>' + trAuth('confirmNewPassword','Confirm your new password') + '</label>'
        + '  <input id="newPass2" type="password" style="padding:8px;border-radius:8px;border:1px solid #444;background:#111;color:#fff" />'
        + '</div>';
      btnSubmit.onclick = doChangePassword;
    }
    btnCancel.textContent = trAuth('cancel','Cancel');
    btnSubmit.textContent = trAuth('submit','Submit');
    setTimeout(() => { const u = document.getElementById('authUser'); if (u) u.focus(); }, 30);
  }
  function hideModal(){ overlay.style.display='none'; modal.style.display='none'; modalBody.innerHTML=''; }

  async function fetchJSON(url, opts){
    const res = await fetch(url, Object.assign({ headers:{'Content-Type':'application/json'} }, opts||{}));
    let data = null; try { data = await res.json(); } catch(_){}
    return { ok: res.ok && data && (data.ok===true || data.ok===undefined), status: res.status, data };
  }

  async function doSignup(){
    try {
      const u = document.getElementById('authUser').value.trim();
      const p = document.getElementById('authPass').value;
      const p2 = document.getElementById('authPass2').value;
      if (!u || !p || !p2) { alert(trAuth('fillAll')); return; }
      if (p !== p2) { alert(trAuth('confirmPassword') + ' ‚úñ'); return; }
      const { ok, data, status } = await fetchJSON('/api/signup', { method:'POST', body: JSON.stringify({ username: u, password: p })});
      if (ok && (!data || data.ok)) { hideModal(); alert(trAuth('signupOk')); }
      else {
        if (data && data.code === 'exists') alert(trAuth('userExists'));
        else if (data && (data.code === 'weak_password' || status === 400)) alert(trAuth('weakPassword'));
        else alert('Error.');
      }
    } catch(e){ alert('Error'); }
  }
  async function doLogin(){
    try {
      const u = document.getElementById('authUser').value.trim();
      const p = document.getElementById('authPass').value;
      if (!u || !p) { alert(trAuth('fillAll')); return; }
      const { ok, data } = await fetchJSON('/api/login', { method:'POST', body: JSON.stringify({ username: u, password: p })});
      if (ok && data && data.username) { hideModal(); setAuthUI(true, data.username); alert(trAuth('loginOk')); }
      else { alert(trAuth('invalidCredentials')); }
    } catch(e){ alert('Error'); }
  }
  async function doChangePassword(){
    try {
      const c = document.getElementById('currPass').value;
      const n = document.getElementById('newPass').value;
      const n2 = (document.getElementById('newPass2') && document.getElementById('newPass2').value) || '';
      if (!c || !n || !n2) { alert(trAuth('fillAll')); return; }
      if (n !== n2) { alert(trAuth('confirmNewPassword') + ' ‚úñ'); return; }
      const { ok, data } = await fetchJSON('/api/change-password', { method:'POST', body: JSON.stringify({ currentPassword: c, newPassword: n })});
      if (ok) { hideModal(); setAuthUI(false); alert(trAuth('pwdChanged')); }
      else { if (data && data.code === 'weak_password') alert(trAuth('weakPassword')); else alert(trAuth('invalidCredentials')); }
    } catch(e){ alert('Error'); }
  }

  // Check if pseudo is reserved by an account when not logged in
  let checkTimer = null;
  async function validatePseudoBlocking(){
    try {
      if (!pseudoInput) return;
      const name = (pseudoInput.value || '').trim();
      if (!name) { reservedPseudo = false; setButtonsEnabled(true); return; }
      if (loggedUser && name.toLowerCase() === (loggedUser||'').toLowerCase()) {
        reservedPseudo = false; setButtonsEnabled(true); return;
      }
      const { ok, data } = await fetchJSON('/api/username-taken?u=' + encodeURIComponent(name), { method:'GET' });
      reservedPseudo = !!(ok && data && data.taken && !loggedUser);
      setButtonsEnabled(!reservedPseudo);
    } catch(_){ reservedPseudo = false; setButtonsEnabled(true); }
  }
  function setButtonsEnabled(enabled){
    try {
      [lobbyJoin, btnJoinLobbyList, btnCreateLobby].forEach(el => { if (el) el.disabled = !enabled; });
      if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled();
    } catch(_){}
  }

  if (pseudoInput) pseudoInput.addEventListener('input', function(){
    clearTimeout(checkTimer);
    checkTimer = setTimeout(validatePseudoBlocking, 200);
  }, { passive:true });

  if (btnLogin) btnLogin.addEventListener('click', function(){ showModal('login'); }, { passive:true });
  if (btnSignup) btnSignup.addEventListener('click', function(){ showModal('signup'); }, { passive:true });
  if (btnLogout) btnLogout.addEventListener('click', async function(){ try { await fetchJSON('/api/logout', { method:'POST' }); } catch(_){ } setAuthUI(false); alert(trAuth('logoutOk')); }, { passive:true });
  if (btnSettings) btnSettings.addEventListener('click', function(){ showModal('settings'); }, { passive:true });
  if (overlay) overlay.addEventListener('click', hideModal, { passive:true });
  if (btnCancel) btnCancel.addEventListener('click', hideModal, { passive:true });

  // Intercept clicks to block reserved pseudo
  function guardAction(e){
    if (reservedPseudo) { e.preventDefault(); e.stopPropagation(); alert(trAuth('reservedName')); return false; }
  }
  [lobbyJoin, btnJoinLobbyList, btnCreateLobby].forEach(el => { if (el) el.addEventListener('click', guardAction, true); });
  // Also guard chat sending (button click and Enter key) when pseudo is reserved
  try {
    var chatSendBtn = document.getElementById('chatSend');
    var chatInputEl = document.getElementById('chatInput');
    if (chatSendBtn) chatSendBtn.addEventListener('click', guardAction, true);
    if (chatInputEl) chatInputEl.addEventListener('keydown', function(ev){
      try {
        var k = ev && (ev.key || ev.code || '');
        var isEnter = (k === 'Enter') || (ev && (ev.keyCode === 13));
        if (isEnter && reservedPseudo) { ev.preventDefault(); ev.stopPropagation(); alert(trAuth('reservedName')); return false; }
      } catch(_){}
    }, true);
  } catch(_){}

  // Also guard chat sending (button click and Enter key) when pseudo is reserved
  try {
    var chatSendBtn = document.getElementById('chatSend');
    var chatInputEl = document.getElementById('chatInput');
    if (chatSendBtn) chatSendBtn.addEventListener('click', guardAction, true);
    if (chatInputEl) chatInputEl.addEventListener('keydown', function(ev){
      try {
        var k = ev && (ev.key || ev.code || '');
        var isEnter = (k === 'Enter') || (ev && (ev.keyCode === 13 || ev.which === 13));
        if (isEnter && reservedPseudo) { ev.preventDefault(); ev.stopPropagation(); alert(trAuth('reservedName')); return false; }
      } catch(_){}
    }, true);
  } catch(_){}

  // Initial state from server
  async function refreshMe(){
    try {
      const { ok, data } = await fetchJSON('/api/me', { method:'GET' });
      if (ok && data && data.username) setAuthUI(true, data.username);
      else setAuthUI(false);
    } catch(_){ setAuthUI(false); }
  }
  document.addEventListener('DOMContentLoaded', function(){ refreshMe(); updateAuthTexts(); validatePseudoBlocking(); }, { passive:true });
})();
</script>

<script>
// Keep Ladder UI translated instantly on language change (button, title, back, table headers)
(function(){
  function currentTR(){
    try { return (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {}; } catch(e){ return {}; }
  }
  function applyLadderTexts(){
    try {
      var tr = currentTR();
      var b = document.getElementById('btnLadder'); if (b) b.textContent = tr.ladder || 'Ladder';
      var t = document.getElementById('ladderTitle'); if (t) t.textContent = tr.ladderTitle || (tr.ladder || 'Ladder');
      var back = document.getElementById('btnBackFromLadder'); if (back) back.textContent = tr.back || 'Back';
      // Update table headers live if Ladder is open
      var list = document.getElementById('ladderList');
      if (list) {
        var ths = list.querySelectorAll('thead th');
        if (ths && ths.length >= 4) {
          if (ths[0]) ths[0].textContent = tr.rank || 'Rank';
          if (ths[1]) ths[1].textContent = tr.player || 'Player';
          if (ths[2]) ths[2].textContent = tr.roundReached || 'Wave reached';
          if (ths[3]) ths[3].textContent = tr.zombiesKilled || 'Zombies killed';
        }
      }
    } catch(e){}
  }
  function hook(){
    // Patch updateUITexts so any language switch updates Ladder labels immediately
    if (typeof window.updateUITexts === 'function' && !window.__ladderHooked) {
      window.__ladderHooked = true;
      var _u = window.updateUITexts;
      window.updateUITexts = function(){
        try { _u.apply(this, arguments); } catch(_){}
        applyLadderTexts();
      };
    }
    applyLadderTexts();
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', hook, {passive:true}); else hook();

  // Also listen for generic lang change via Mutation (flags toggling currentLang on window)
  (function observeLang(){
    try {
      var last = window.currentLang;
      setInterval(function(){
        if (window.currentLang !== last) { last = window.currentLang; applyLadderTexts(); }
      }, 150);
    } catch(_){}
  })();
})();
</script>

<script>
(function(){
  function qs(id){ return document.getElementById(id); }
  const btnLadder = qs('btnLadder');
  const btnBack = qs('btnBackFromLadder');
  const panelLadder = qs('ladderPanel');
  const panelManual = qs('manualLobbyPanel');
  const panelList = qs('joinLobbyPanel');
  const ladderList = qs('ladderList');

  function showLadder(){
    try { if (panelManual) panelManual.style.display = 'none'; } catch(_){}
    try { if (panelList) panelList.style.display = 'none'; } catch(_){}
    try { if (panelLadder) panelLadder.style.display = 'block'; } catch(_){}
    try{ if (typeof pseudoInput!=='undefined' && pseudoInput) pseudoInput.style.display='none'; }catch(_){ }
    // Fetch ladder
    fetch('/api/ladder', { method: 'GET' })
      .then(r => r.json().catch(()=>({ok:false})))
      .then(data => {
        try{
          const tr = (window.TRANSLATIONS && (TRANSLATIONS[window.currentLang] || TRANSLATIONS['en'])) || {};
          if (!data || (data.ok===false)) {
            ladderList.innerHTML = '<div style="text-align:center;color:#ccc;padding:8px;">' + (tr.noData || 'No data') + '</div>';
            return;
          }
          const arr = Array.isArray(data.ladder) ? data.ladder : (Array.isArray(data) ? data : []);
          if (!arr.length) {
            ladderList.innerHTML = '<div style="text-align:center;color:#ccc;padding:8px;">' + (tr.noData || 'No data') + '</div>';
            return;
          }
          // Build table
          let html = '';
          html += '<table style="width:100%; border-collapse:separate; border-spacing:0; font-size:14px;">';
          html += '<thead><tr>';
          html += '<th style="position:sticky;top:0;background:#222;border-bottom:1px solid #333;text-align:left;padding:8px 10px;">' + (tr.rank || 'Rank') + '</th>';
          html += '<th style="position:sticky;top:0;background:#222;border-bottom:1px solid #333;text-align:left;padding:8px 10px;">' + (tr.player || 'Player') + '</th>';
          html += '<th style="position:sticky;top:0;background:#222;border-bottom:1px solid #333;text-align:right;padding:8px 10px;">' + (tr.roundReached || 'Wave reached') + '</th>';
          html += '<th style="position:sticky;top:0;background:#222;border-bottom:1px solid #333;text-align:right;padding:8px 10px;">' + (tr.zombiesKilled || 'Zombies killed') + '</th>';
          html += '</tr></thead><tbody>';
          for (let i=0; i<Math.min(arr.length, 100); i++){
            const it = arr[i] || {};
            const rank = (i+1);
            const name = (it.player || it.pseudo || it.name || '???');
            const wave = (it.wave|0);
            const kills = (it.kills|0);
            html += '<tr style="border-bottom:1px solid rgba(255,255,255,0.06);">';
            html += '<td style="padding:6px 10px; color:#9ab;">#' + rank + '</td>';
            html += '<td style="padding:6px 10px; white-space:normal; overflow:visible; text-overflow:clip; word-break:break-word;">' + escapeHtml(String(name)) + '</td>';
            html += '<td style="padding:6px 10px; text-align:right;">' + wave + '</td>';
            html += '<td style="padding:6px 10px; text-align:right;">' + kills + '</td>';
            html += '</tr>';
          }
          html += '</tbody></table>';
          ladderList.innerHTML = html;
        } catch(e){ try{ ladderList.innerHTML = '<div style="text-align:center;color:#ccc;padding:8px;">Error</div>'; }catch(_){ } }
      })
      .catch(()=>{
        try{ ladderList.innerHTML = '<div style="text-align:center;color:#ccc;padding:8px;">Error</div>'; }catch(_){}
      });
  }
  function showMainFromLadder(){
    try { if (panelLadder) panelLadder.style.display = 'none'; } catch(_){}
    try { if (panelManual) panelManual.style.display = 'none'; } catch(_){}
    try { if (panelList) panelList.style.display = 'none'; } catch(_){}
  
    try{ if (typeof pseudoInput!=='undefined' && pseudoInput){ pseudoInput.style.display=''; if (window.myPseudo && !pseudoInput.value) pseudoInput.value = window.myPseudo; } }catch(_){ }
  }
  function escapeHtml(s){
    return s.replace(/[&<>"]/g, function(c){
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]);
    });
  }

  if (btnLadder) btnLadder.addEventListener('click', function(){ showLadder(); }, { passive: true });
  if (btnBack) btnBack.addEventListener('click', function(){
    showMainFromLadder();
    try{
      if (typeof pseudoInput!=='undefined' && pseudoInput){
        var loggedIn = false;
        try { var btnLg = document.getElementById('btnLogout'); loggedIn = !!(btnLg && btnLg.style.display !== 'none'); } catch(_){ }
        pseudoInput.disabled = false;
        if (loggedIn || window.lobbyJoined) {
          pseudoInput.readOnly = true;
          try { pseudoInput.style.background = '#c7f7c7'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #49c749'; } catch(_){ }
        } else {
          pseudoInput.readOnly = false;
          try { pseudoInput.style.background = '#fff'; pseudoInput.style.color = '#000'; pseudoInput.style.border = '1px solid #444'; } catch(_){ }
        }
        try { if (window.myPseudo) pseudoInput.value = window.myPseudo; } catch(_){ }
        try { if (typeof updateButtonsDisabled === 'function') updateButtonsDisabled(); } catch(_){ }
      }
    }catch(_){ }
  }, { passive: true });

  // Expose for debug
  
  // Close ladder when main action buttons are clicked
  const btnSolo = qs('lobbyJoin');
  const btnJoin = qs('btnJoinLobbyList');
  const btnCreate = qs('btnCreateLobby');
  function hideLadderOnly(){ try { if (panelLadder) panelLadder.style.display = 'none'; } catch(_){} }
  if (btnSolo) btnSolo.addEventListener('click', hideLadderOnly, { passive: true });
  if (btnJoin) btnJoin.addEventListener('click', hideLadderOnly, { passive: true });
  if (btnCreate) btnCreate.addEventListener('click', hideLadderOnly, { passive: true });

  window.showLadder = showLadder;
})();
</script>

  <!-- Visual Debug Console -->
  <style id="debugConsoleStyles">
    #debugConsole { position: fixed; left: 0; right: 0; bottom: 0; max-height: 42vh; z-index: 2147483647; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; line-height: 1.35; background: rgba(0,0,0,0.75); color: #c7f284; overflow-y:auto; padding:6px 8px; display:none; box-shadow: 0 -4px 12px rgba(0,0,0,0.35); }
    #debugConsole .line { white-space: pre-wrap; word-break: break-word; margin: 0; padding: 1px 0; }
    #debugConsoleBar { position: fixed; bottom: 8px; right: 8px; z-index: 2147483647; display:flex; gap:6px; }
    #debugToggle, #debugClear, #debugCopy { font-size: 12px; padding: 6px 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.35); background: rgba(0,0,0,0.65); color: #fff; backdrop-filter: blur(4px); }
    #debugToggle:active, #debugClear:active, #debugCopy:active { transform: translateY(1px); }
    @media (hover:hover) { #debugToggle:hover, #debugClear:hover, #debugCopy:hover { background: rgba(0,0,0,0.8); } }
  </style>
  <div id="debugConsole" aria-label="Debug console (tap to scroll)"></div>
  <!-- <div id="debugConsoleBar" aria-hidden="false">
    <button id="debugToggle" type="button">üêõ Log</button>
    <button id="debugClear" type="button">Clear</button>
    <button id="debugCopy" type="button">Copy</button>
  </div> -->
  <script>
  (function(){
    var dc = document.getElementById('debugConsole');
    var toggle = document.getElementById('debugToggle');
    var clearBtn = document.getElementById('debugClear');
    var copyBtn = document.getElementById('debugCopy');
    var MAX_LINES = 400;
    function fmtArg(a){
      try {
        if (typeof a === 'string') return a;
        if (a === null) return 'null';
        if (typeof a === 'undefined') return 'undefined';
        if (a instanceof Error) return a.name + ': ' + (a.message || String(a));
        var s = JSON.stringify(a);
        return s;
      } catch(e){ try { return String(a); } catch(_) { return '[unprintable]'; } }
    }
    function ts(){
      var d = new Date();
      var ms = String(d.getMilliseconds()).padStart(3,'0');
      return d.toTimeString().slice(0,8) + '.' + ms;
    }
    function write(kind, args){
      try {
        var line = document.createElement('div');
        line.className = 'line';
        var prefix = kind ? ('['+kind+'] ') : '';
        var text = '['+ts()+'] ' + prefix + (args && args.length ? args.map(fmtArg).join(' ') : '');
        line.textContent = text;
        dc.appendChild(line);
        if (dc.childElementCount > MAX_LINES) dc.removeChild(dc.firstChild);
        dc.scrollTop = dc.scrollHeight;
      } catch(e){ /* ignore */ }
    }
    window.debugLog = function(){ try { console.log.apply(console, arguments); } catch(_){} write('LOG', Array.prototype.slice.call(arguments)); };
    window.debugWarn = function(){ try { console.warn.apply(console, arguments); } catch(_){} write('WARN', Array.prototype.slice.call(arguments)); };
    window.debugError = function(){ try { console.error.apply(console, arguments); } catch(_){} write('ERR', Array.prototype.slice.call(arguments)); };
    if (toggle) toggle.addEventListener('click', function(){ dc.style.display = (dc.style.display === 'block') ? 'none' : 'block'; });
    if (clearBtn) clearBtn.addEventListener('click', function(){ dc.innerHTML = ''; });
    if (copyBtn) copyBtn.addEventListener('click', async function(){
      try {
        var parts = [];
        try { for (var i=0;i<dc.children.length;i++){ parts.push(dc.children[i].textContent); } } catch(_){ parts.push(dc.textContent || ''); }
        var text = parts.join('\n');
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          var ta = document.createElement('textarea');
          ta.value = text; ta.style.position='fixed'; ta.style.opacity='0'; ta.style.left='-9999px';
          document.body.appendChild(ta); ta.focus(); ta.select(); try { document.execCommand('copy'); } catch(_) {}
          document.body.removeChild(ta);
        }
        var old = copyBtn.textContent; copyBtn.textContent = 'Copied!'; copyBtn.disabled = true;
        debugLog('üìã copied', dc.children.length || 0, 'line(s) to clipboard');
        setTimeout(function(){ copyBtn.textContent = 'Copy'; copyBtn.disabled = false; }, 1400);
      } catch(e){ debugError('copy failed', e && (e.message || e)); }
    });
    // Mirror console.* into overlay
    (function(){
      if (window.__consoleMirror) return;
      var orig = { log: console.log, info: console.info, warn: console.warn, error: console.error };
      function mirror(kind, args){ write(kind, Array.prototype.slice.call(args)); }
      console.log = function(){ try { orig.log.apply(console, arguments); } catch(_){} mirror('LOG', arguments); };
      console.info = function(){ try { orig.info.apply(console, arguments); } catch(_){} mirror('INFO', arguments); };
      console.warn = function(){ try { orig.warn.apply(console, arguments); } catch(_){} mirror('WARN', arguments); };
      console.error = function(){ try { orig.error.apply(console, arguments); } catch(_){} mirror('ERR', arguments); };
      window.__consoleMirror = true;
    })();
  })();
  </script>
  <!-- /Visual Debug Console -->

<script>
(function(){
  if (window.__forceGameEnterInstalled) return;
  window.__forceGameEnterInstalled = true;
  window.forceGameEnter = function(){
    try {
      window.__ingame = true;
      var lobby = document.getElementById('lobbyScreen');
      if (lobby) { lobby.style.setProperty('display','none','important'); }
      try { var m1 = document.getElementById('manualLobbyPanel'); if (m1) m1.style.display = 'none'; } catch(_){}
      try { var m2 = document.getElementById('joinLobbyPanel'); if (m2) m2.style.display = 'none'; } catch(_){}
      try { document.body.classList.remove('menu-hide-ui'); } catch(_){}
      var canvas = document.getElementById('gameCanvas');
      if (canvas) { canvas.style.display='block'; canvas.style.visibility='visible'; canvas.style.opacity='1'; }
      try { var btn = document.getElementById('lobbyJoin'); if (btn) { btn.disabled = true; btn.onclick = null; btn.dataset.clicked='1'; } } catch(_){}
      if (!window.__gameLoopStarted && typeof window.gameLoop === 'function') {
        window.__gameLoopStarted = true;
        debugLog('üéØ forceGameEnter: starting gameLoop()');
        setTimeout(function(){ try { window.gameLoop(); } catch(e){ debugError('gameLoop start error', e && e.message); } }, 120);
      } else {
        debugLog('üéØ forceGameEnter: gameLoop already started');
      }
    } catch(e) { debugError('forceGameEnter error', e && (e.message||e)); }
  };
})();
</script>

<script>
// NON_BLOCKING_GAMESTARTED_HELPER
(function(){
  try {
    socket.on('gameStarted', function(data){
      try {
        // Try to fix myId if not found (solo or from candidate sid)
        if (typeof playersHealth !== 'undefined' && data && data.players) {
          try { playersHealth = data.players; } catch(_){}
          try {
            var ok = (typeof myId !== 'undefined') && playersHealth && playersHealth[myId];
            if (!ok) {
              var cand = window.__candidateSid || (function(){ try { return localStorage.getItem('zombi_candidate_sid'); } catch(_){ return null; } })();
              if (cand && playersHealth[cand]) { myId = cand; debugWarn('üß≠ myId fallback to candidateSid:', cand); ok = true; }
              if (!ok) {
                var keys = Object.keys(playersHealth||{});
                if (keys.length === 1) { myId = keys[0]; debugWarn('üß≠ myId fallback to sole id:', myId); ok = true; }
              }
            }
            debugLog('üß™ postStart check: myId=', myId, 'hasMine=', !!(playersHealth && myId && playersHealth[myId]), 'keys=', playersHealth ? Object.keys(playersHealth).length : 'n/a');
          } catch(e){ debugWarn('postStart myId check error', e && e.message); }
        }
        if (typeof forceGameEnter === 'function') forceGameEnter();
      } catch(e){ debugError('postStart handler error', e && e.message); }
    });
  } catch(e){}
})();
</script>

<script>
(function(){
  function attachSocketDebug(s){
    try {
      if (!s || s.__debugAttached) return;
      s.__debugAttached = true;
      debugLog('üì° trying connect to server');
      s.on('connect', function(){
        try { debugLog('‚úÖ connect', 'socket.id=', s.id, 'transport=', s.io && s.io.engine && s.io.engine.transport && s.io.engine.transport.name); } catch(_){}
      });
      try {
        if (s.io && s.io.engine && s.io.engine.on) {
          s.io.engine.on('upgrade', function(tr){ debugLog('‚§¥Ô∏è upgrade ‚Üí', tr && tr.name); });
        }
      } catch(_){}
      s.on('connect_error', function(err){ debugError('connect_error', err && (err.message || err)); });
      if (s.io && s.io.on) {
        s.io.on('reconnect_attempt', function(n){ debugWarn('reconnect_attempt', n, 'transport=', s.io.engine && s.io.engine.transport && s.io.engine.transport.name); });
        s.io.on('reconnect', function(n){ debugLog('reconnect OK after', n, 'attempt(s), transport=', s.io.engine && s.io.engine.transport && s.io.engine.transport.name); });
        s.io.on('reconnect_error', function(err){ debugError('reconnect_error', err && (err.message || err)); });
        s.io.on('reconnect_failed', function(){ debugError('reconnect_failed'); });
      }
      s.on('disconnect', function(reason){ debugWarn('disconnect', reason); });
      s.on('error', function(err){ debugError('socket error', err && (err.message || err)); });
      // Wrap emit for key events with throttle for setPseudoAndReady
      try {
        var origEmit = s.emit.bind(s);
        s.emit = function(ev){
          var argv = Array.prototype.slice.call(arguments,1);
          if (ev === 'setPseudoAndReady') {
            try {
              var now = Date.now();
              if (typeof window.__lastJoinEmit === 'number' && (now - window.__lastJoinEmit) < 900) {
                debugWarn('‚õî duplicate setPseudoAndReady blocked within', (now - window.__lastJoinEmit), 'ms');
                return s;
              }
              window.__lastJoinEmit = now;
            } catch(_){}
          }
          if (['setPseudoAndReady','startManualLobby','joinManualLobby','createManualLobby','reclaimPlayer'].indexOf(ev) !== -1) {
            debugLog('üì§ emit', ev, argv);
          }
          return origEmit.apply(s, arguments);
        };
      } catch(_){}
      // Incoming markers
      s.on('gameStarted', function(payload){
        try {
          var pcount = payload && payload.players ? Object.keys(payload.players).length : 'n/a';
          debugLog('üéÆ gameStarted received', '; players=', pcount);
        } catch(_){}
      });
      s.on('lobbyUpdate', function(data){
        try { debugLog('üì• lobbyUpdate id=', data && data.id, 'started=', data && data.started); } catch(_){}
      });
    } catch(e){ debugWarn('attachSocketDebug error', String(e)); }
  }
  try { attachSocketDebug(window.socket); } catch(_){}
  // Patch global io() to auto-attach for future sockets
  (function(){
    if (!window.io || window.__io_patched_for_debug) return;
    var originalIO = window.io;
    function patchedIO(){
      var s = originalIO.apply(this, arguments);
      try { attachSocketDebug(s); } catch(_){}
      return s;
    }
    try { for (var k in originalIO) { patchedIO[k] = originalIO[k]; } } catch(_){}
    window.io = patchedIO; window.__io_patched_for_debug = true;
  })();
})();
</script>

  <!-- <!-- <div id="renderProbeBadge" style="position:fixed;left:8px;top:8px;z-index:2147483646;background:rgba(0,0,0,0.5);color:#fff;font:11px/1.3 ui-monospace,monospace;padding:4px 6px;border-radius:6px;display:none">üß™ render-probe</div> --> -->

<script>
(function(){
  function topmostAtCenter(){
    try {
      var el = document.elementFromPoint(Math.floor(window.innerWidth/2), Math.floor(window.innerHeight/2));
      if (!el) { debugWarn('üß± topmost@center = null'); return; }
      var id = el.id ? ('#'+el.id) : '';
      var cls = el.className ? ('.'+String(el.className).replace(/\s+/g,'.')) : '';
      debugLog('üß± topmost@center =', el.tagName+id+cls);
    } catch(e){ try{ debugError('topmost error', e && (e.message||e)); }catch(_){ } }
  }
  function ensureCanvasSize(canvas){
    try {
      if (!canvas) return;
      var ratio = Math.max(1, (window.devicePixelRatio || 1));
      var uiScale = (typeof window.__uiScale === 'number' && window.__uiScale > 0) ? window.__uiScale : 1;
      var cssW = canvas.clientWidth || 0;
      var cssH = canvas.clientHeight || 0;
      if (cssW === 0 || cssH === 0) { cssW = window.innerWidth || 0; cssH = window.innerHeight || 0; }
      var targetW = Math.max(16, Math.floor((cssW * ratio) / uiScale));
      var targetH = Math.max(16, Math.floor((cssH * ratio) / uiScale));
      if (canvas.width !== targetW || canvas.height !== targetH) {
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width = targetW; canvas.height = targetH;
        debugLog('üìê canvas resized attr ‚Üí', targetW, 'x', targetH, '(css=', cssW, 'x', cssH, 'ratio=', ratio, 'uiScale=', uiScale, ')');
      }
    } catch(e){ try{ debugWarn('ensureCanvasSize error', e && (e.message||e)); }catch(_){ } }
  }
  function drawMarker(canvas){
  try {
    // Disabled: avoid drawing the small green square + 'tick' text on desktop.
    // Return false so any probing logic that depends on this simply no-ops.
    return false;
  } catch(e){ try{ debugError('drawMarker error', e && (e.message||e)); }catch(_){ } return false; }
}
  function readOnePixel(canvas){
    try {
      var ctx = canvas.getContext && canvas.getContext('2d'); if (!ctx) return null;
      var d = ctx.getImageData(3,3,1,1).data; var rgba = [d[0],d[1],d[2],d[3]];
      debugLog('üß¨ pixel@3,3 =', rgba.join(',')); return rgba;
    } catch(e){ try{ debugWarn('readOnePixel error', e && (e.message||e)); }catch(_){ } return null; }
  }
  window.ensureCanvasReady = function(){
    try {
      var canvas = document.getElementById('gameCanvas');
      if (!canvas) { debugWarn('üéØ no #gameCanvas'); return; }
      canvas.style.display='block'; canvas.style.visibility='visible'; canvas.style.opacity='1';
      ensureCanvasSize(canvas);
      // Normalize for devicePixelRatio so 1 unit = 1 CSS pixel
      try {
        var ratio = Math.max(1, (window.devicePixelRatio || 1));
      var uiScale = (typeof window.__uiScale === 'number' && window.__uiScale > 0) ? window.__uiScale : 1;
        canvas.style.width = (canvas.clientWidth || window.innerWidth || 0) + 'px';
        canvas.style.height = (canvas.clientHeight || window.innerHeight || 0) + 'px';
        var ctx2d = canvas.getContext && canvas.getContext('2d');
        if (ctx2d) { ctx2d.setTransform(ratio,0,0,ratio,0,0); debugLog('üîé DPR applied to 2D context:', ratio); }
      } catch(_) {}

      topmostAtCenter();
      var __ua = (navigator.userAgent||'');
      var __isMobile = /Android|iPhone|iPad|iPod|Mobile|Windows Phone/i.test(__ua) || (Math.max(window.innerWidth||0, window.innerHeight||0) <= 812);
      var ok = false;
      if (!__isMobile) { ok = drawMarker(canvas); if (ok) { readOnePixel(canvas); } }
      var badge = document.getElementById('renderProbeBadge'); 
      if (badge) { badge.style.display='block'; setTimeout(function(){ try{ badge.style.display='none'; }catch(_){ } }, 2000); }
    } catch(e){ try{ debugError('ensureCanvasReady error', e && (e.message||e)); }catch(_){ } }
  };
  window.addEventListener('orientationchange', function(){ try{ ensureCanvasReady(); }catch(_){ } });
  window.addEventListener('resize', function(){ try{ ensureCanvasReady(); }catch(_){ } });
  setTimeout(function(){ try{ ensureCanvasReady(); }catch(_){ } }, 500);
})();
</script>

<script>
// GAMESTARTED_CANVASREADY_HELPER
try { if (window.socket && socket.on) { socket.on('gameStarted', function(){ try { if (window.ensureCanvasReady) ensureCanvasReady(); } catch(_){ } }); } } catch(_){}
</script>

<style id="mobile-portrait-lock-and-size-overrides">
/* === Mobile portrait "lock" & UI size tweaks (no effect on desktop) === */

/* Fullscreen rotate overlay (only shows on mobile + landscape) */
#rotateOverlay{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.9);
  color: #fff;
  z-index: 2147483647;
  font-weight: 700;
  text-align: center;
  padding: 28px;
  line-height: 1.35;
  -webkit-user-select: none;
  user-select: none;
}

@media (hover: none) and (pointer: coarse) and (orientation: landscape){
  #rotateOverlay{ display: flex; }
}

/* Mobile-only UI sizing + right alignment for build tiles */
@media (hover: none) and (pointer: coarse){
  /* Make build tiles hug the right edge */
  #buildTiles{ justify-content: flex-end; }
  /* Slightly smaller shop & auto-fire buttons */
  #shopBtn{ font-size: 18px !important; padding: 8px 18px 8px 14px !important; }
  #autoFireBtn{ font-size: 14px !important; padding: 3px 8px 3px 5px !important; gap: 6px !important; }
  #autoFireBtn > span:first-child{ width: 12px !important; height: 12px !important; }

  /* Smaller construction blocks */
  #buildTiles .build-tile > div:first-child{ width: 36px !important; height: 36px !important; }
  #buildTiles .build-tile > div + div{ font-size: 12px !important; padding: 2px 6px !important; }

  /* Keep the bar tight to the right/bottom on mobile */
  #buildBar{ right: 12px !important; bottom: 112px !important; gap: 8px !important; }
}
</style>


<script id="mobile-portrait-lock-and-zoom">
(function(){
  const isMobile = window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse)').matches;

  // Ensure overlay node exists (idempotent)
  function ensureRotateOverlay(){
    if (!document.getElementById('rotateOverlay')){
      const d = document.createElement('div');
      d.id = 'rotateOverlay';
      d.setAttribute('aria-hidden', 'true');
      d.textContent = (window.trLoc ? trLoc('rotateToPortrait', 'Rotate your device to portrait.') : 'Rotate your device to portrait.');
      document.body.appendChild(d);
    }
  }

  // Best-effort portrait lock using Screen Orientation API (requires user gesture/fullscreen on many browsers)
  async function tryLockPortrait(){
    if (!isMobile) return;
    try {
      if (screen.orientation && screen.orientation.lock){
        await screen.orientation.lock('portrait');
      }
    } catch(_e){
      // ignore ‚Äî overlay + CSS will enforce UX when in landscape
    }
  }

  function once(el, ev, fn, opts){
    const wrap = function(e){ try{ fn(e); }finally{ el.removeEventListener(ev, wrap, opts);} };
    el.addEventListener(ev, wrap, opts);
  }

  // Inject overlay ASAP
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureRotateOverlay, {passive:true});
  } else {
    ensureRotateOverlay();
  }

  if (isMobile){
    // Try to lock on first user interaction
    ['pointerup','touchend','click'].forEach(ev => once(window, ev, tryLockPortrait, {passive:true}));
    // Retry on orientation changes
    window.addEventListener('orientationchange', tryLockPortrait, {passive:true});
  }

  // Zoom out a bit when the game starts (mobile only) ‚Äî relies on existing pinchScale/updateRenderScale
  function mobileZoomOut(){
    if (!isMobile) return;
    try {
      // Respect existing clamp constants if present
      var minP = (typeof MIN_PINCH === 'number') ? MIN_PINCH : 0.6;
      var maxP = (typeof MAX_PINCH === 'number') ? MAX_PINCH : 1.6;
      var target = 0.85; // slightly zoomed out
      if (typeof pinchScale === 'number') {
        pinchScale = Math.max(minP, Math.min(maxP, target));
      } else {
        window.pinchScale = target;
      }
      if (typeof updateRenderScale === 'function') updateRenderScale();
    } catch(_e){ /* no-op */ }
  }

  try {
    if (window.socket && typeof socket.on === 'function'){
      socket.on('gameStarted', function(){ tryLockPortrait(); mobileZoomOut(); });
    } else {
      // Fallback: if socket arrives later, hook then
      const iv = setInterval(function(){
        if (window.socket && typeof socket.on === 'function'){
          clearInterval(iv);
          socket.on('gameStarted', function(){ tryLockPortrait(); mobileZoomOut(); });
        }
      }, 120);
      setTimeout(()=>clearInterval(iv), 10000);
    }
  } catch(_e){ /* ignore */ }
})();




// === Mobile: tap-select then confirm/cancel ===
(function(){
  try{
    var isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    if (!isTouch) return;
    if (window.__tapConfirmSetup) return;
    window.__tapConfirmSetup = true;

    var awaitingTap = false;
    var confirmUI = null, btnOk = null, btnNo = null;
    var pendingClient = { x: 0, y: 0 };

    function ensureUI(){
      if (confirmUI) return;
      confirmUI = document.createElement('div');
      confirmUI.className = 'mobile-build-confirm';
      confirmUI.style.display = 'none';
      btnOk = document.createElement('button');
      btnOk.className = 'btn btn-confirm';
      btnOk.setAttribute('aria-label', 'Valider');
      btnOk.textContent = '‚úì';
      btnNo = document.createElement('button');
      btnNo.className = 'btn btn-cancel';
      btnNo.setAttribute('aria-label', 'Refuser');
      btnNo.textContent = '‚úï';
      confirmUI.appendChild(btnOk);
      confirmUI.appendChild(btnNo);
      document.body.appendChild(confirmUI);

      btnOk.addEventListener('click', function(e){
        e.preventDefault(); e.stopPropagation();
        try { tryPlaceStructureAtCursor(pendingClient.x, pendingClient.y); } catch(_){}
        hideUI();
        awaitingTap = true;
      }, { passive: false });
      btnNo.addEventListener('click', function(e){
        e.preventDefault(); e.stopPropagation();
        hideUI();
        awaitingTap = true;
      }, { passive: false });
    }

    function showUI(){
      ensureUI();
      confirmUI.style.display = 'block';
      window.__buildConfirmActive = true;
      startRAF();
    }
    function hideUI(){
      if (!confirmUI) return;
      confirmUI.style.display = 'none';
      window.__buildConfirmActive = false;
      stopRAF();
    }

    var rafId = 0;
    function startRAF(){
      if (rafId) return;
      var step = function(){
        if (!confirmUI || confirmUI.style.display==='none'){ rafId=0; return; }
        try { positionUI(); } catch(_){}
        rafId = requestAnimationFrame(step);
      };
      rafId = requestAnimationFrame(step);
    }
    function stopRAF(){ try{ if (rafId) cancelAnimationFrame(rafId); }catch(_){} rafId = 0; }

    function positionUI(){
      var tx = (window.buildHover && buildHover.tx)|0;
      var ty = (window.buildHover && buildHover.ty)|0;
      if (tx < 0 || ty < 0) return;
      var rect = canvas.getBoundingClientRect();
      var cx = rect.left + ((tx * TILE_SIZE - cameraX + TILE_SIZE/2) * renderScale);
      var cy = rect.top  + ((ty * TILE_SIZE - cameraY + TILE_SIZE/2) * renderScale);

      var r = 44, gap = 36;
      btnOk.style.left = (cx - r - gap) + 'px';
      btnOk.style.top  = (cy - r/2) + 'px';
      btnNo.style.left = (cx + gap) + 'px';
      btnNo.style.top  = (cy - r/2) + 'px';
    }

    function setAwaiting(on){ awaitingTap = !!on; if (!awaitingTap) hideUI(); }

    function findType(target){
      var el = target, hops = 0;
      while (el && hops < 7){
        if (el.getAttribute && el.getAttribute('data-type')) return el.getAttribute('data-type');
        el = el.parentNode; hops++;
      }
      return null;
    }

    function wireBuildButtons(){
      var arr = [ document.getElementById('buildTiles'), document.getElementById('mobile-build') ];
      arr.forEach(function(cont){
        if (!cont) return;
        cont.addEventListener('click', function(e){
          var t = findType(e.target); if (!t) return;
          e.preventDefault(); e.stopPropagation();
          try { if (typeof setBuildMode==='function') setBuildMode(t); else { buildMode = t; buildHover = { tx:-1, ty:-1 }; } } catch(_){ buildMode = t; buildHover = { tx:-1, ty:-1 }; }
          setAwaiting(true);
        }, { passive: false });
        cont.addEventListener('touchstart', function(e){
          var t = findType(e.target); if (!t) return;
          e.preventDefault(); e.stopPropagation();
          try { if (typeof setBuildMode==='function') setBuildMode(t); else { buildMode = t; buildHover = { tx:-1, ty:-1 }; } } catch(_){ buildMode = t; buildHover = { tx:-1, ty:-1 }; }
          setAwaiting(true);
        }, { passive: false });
      });
    }

    function wireCanvas(){
      canvas.addEventListener('click', function(e){
        if (!awaitingTap || !buildMode) return;
        if (typeof isMobileDevice !== 'undefined' && !isMobileDevice) return;
        e.preventDefault(); e.stopPropagation();
        chooseTile(e.clientX, e.clientY);
      }, { passive: false });
      canvas.addEventListener('touchend', function(e){
        if (!awaitingTap || !buildMode) return;
        var t = (e.changedTouches && e.changedTouches[0]) || null;
        if (!t) return;
        e.preventDefault(); e.stopPropagation();
        chooseTile(t.clientX, t.clientY);
      }, { passive: false });
    }

    function chooseTile(clientX, clientY){
      pendingClient.x = clientX; pendingClient.y = clientY;
      var st = screenToWorldTile(clientX, clientY);
      buildHover.tx = st.tx; buildHover.ty = st.ty;
      showUI(); positionUI();
      awaitingTap = false;
    }

    window.addEventListener('resize', function(){ if (confirmUI && confirmUI.style.display!=='none') positionUI(); });
    window.addEventListener('orientationchange', function(){ if (confirmUI && confirmUI.style.display!=='none') positionUI(); });

    wireBuildButtons();
    wireCanvas();
  }catch(_e){ /* ignore */ }
})();
// === /Mobile: tap-select then confirm/cancel ===

</script>

</body></html>
      try { window.lobbyData = lobbyData; } catch(_){}