<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Zombination.io</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #222; color: white; font-family: Arial, sans-serif; }
    #gameCanvas { display: block; background: #222; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
	#gameCanvas { touch-action: none; }
	.joystick-base, .joystick-stick { touch-action: none; }
	html, body { overscroll-behavior: none; }
    #hudStats { position: fixed; left: 10px; bottom: 10px; background: rgba(0,0,0,0.7); border-radius: 7px; padding: 10px 20px 10px 15px; font-size: 18px; user-select: none; min-width: 210px; }
    #hudAlive { font-weight: bold; color: #fd7; }
    #deathScreen { display: none; position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; background: rgba(30,0,0,0.8); z-index: 3; justify-content: center; align-items: center; flex-direction: column; }
    #deathScreenInner { background: #181818; border-radius: 20px; padding: 35px 45px; color: #fff; box-shadow: 0 6px 30px #000c; text-align: center; min-width: 320px; }
    #deathScreen h2 { margin: 0 0 15px 0; color: #fc2c3c; }
    #deathStats { margin-bottom: 15px; font-size: 20px; }
    #btnReplay { background: #222; color: #fff; padding: 10px 32px; border: none; border-radius: 10px; font-size: 20px; cursor: pointer; transition: background 0.16s; }
    #btnReplay:hover { background: #393; color: #fff; }
    /* --- LOBBY --- */
    #lobbyScreen { display: flex; flex-direction: column; align-items: center; justify-content: center; position: fixed; left:0;top:0;width:100vw;height:100vh;z-index:10; background: #181c; }
    #lobbyBox { background: #19191e; border-radius: 20px; padding: 36px 42px; box-shadow: 0 6px 30px #000c; min-width: 350px; min-height: 190px; text-align: center; }
    #lobbyBox input[type=text] { font-size: 20px; padding: 7px 12px; border-radius: 7px; border: 1px solid #444; outline: none; margin-bottom: 10px; width: 175px; }
    #lobbyJoin { padding: 7px 32px; border-radius: 8px; border:none; font-size: 20px; background:#49c749; color: #fff; cursor: pointer; margin-top: 7px; }
    #lobbyJoin[disabled] { opacity: 0.6; cursor: not-allowed; }
    #lobbyPlayers { margin: 18px 0 12px 0; color: #9fd; }
    #lobbyTimer { font-size: 17px; margin-bottom: 9px; }
    #lobbyStatus { margin: 4px 0 0 0; color: #ccc; font-size: 14px; }

    /* --- LANG SELECT --- */
    #langSelectRow {
      margin-top: 18px;
      display: flex;
      justify-content: center;
      gap: 13px;
      user-select: none;
    }
    .langFlag {
      width: 38px;
      height: 26px;
      border-radius: 6px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: border 0.14s, transform 0.12s;
      background: #fff2;
      object-fit: cover;
      box-shadow: 0 2px 10px #0003;
    }
    .langFlag.selected {
      border: 2.5px solid #33fc69;
      transform: scale(1.07);
      box-shadow: 0 2px 16px #33fc6930;
    }

    /* --- WAVE MESSAGE --- */
    #waveMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #f2f263;
      font-size: 48px;
      font-weight: bold;
      text-shadow: 2px 2px 6px #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease-in-out;
      z-index: 20;
      user-select: none;
    }
    /* Version */
    #versionBox {
      position: fixed;
      right: 20px;
      bottom: 14px;
      color: #ccc;
      font-size: 14px;
      opacity: 0.8;
      z-index: 20;
      user-select: none;
    }
    /* Ajout des joysticks mobile */
	.joystick-container {
	  position: fixed;
	  z-index: 10000;
	  touch-action: none;
	  pointer-events: auto; /* <-- IMPORTANT : le conteneur doit capter les events */
	}
    .joystick-base, .joystick-stick {
      pointer-events: auto;
      user-select: none;
    }
	#shopModal {
	  animation: shopPopIn 0.22s;
	  backdrop-filter: blur(0.5px);
	  -webkit-overflow-scrolling: touch; /* ← Ajout ici */
	}
	#shopModal { z-index: 10010 !important; }
	#shopModal:focus-within { outline: 2px solid #4dfc82; }
	#shopModal::-webkit-scrollbar { width: 6px; }
	#shopModal::-webkit-scrollbar-thumb { background: #2a5; border-radius: 4px; }

	/* Étape 1 — structure interne du panneau (scroll propre) */
	#shopModal {
	  display: flex;
	  flex-direction: column;
	}

	#shopUpgrades {
	  overflow-y: auto;
	  /* prend toute la hauteur restante du panneau */
	  max-height: 100%;
	}


		
@media (hover: none) and (pointer: coarse) {
  /* Contraintes + anim spécifiques mobile */
  #shopModal {
    box-sizing: border-box;

    /* dimensions qui tiennent toujours dans l'écran */
    width: auto;
    max-width: min(92vw, 420px) !important;
    max-height: calc(100dvh - 24px) !important;

    overflow-y: auto;
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;

    /* apparition mobile + easing voulu */
    transform: scale(0.5);
    transform-origin: bottom right;
    animation: shopPopInMobile 0.22s ease-out;
  }

  /* Le bouton doit passer sous le panneau */
  #shopBtn { z-index: 10005 !important; }
}



@keyframes shopPopInMobile {
  0%   { opacity: 0; transform: translateY(80px) scale(0.5); }
  100% { opacity: 1; transform: scale(0.5); }
}




	@keyframes shopPopIn {
	  0% { opacity: 0; transform: translateY(80px) scale(0.97);}
	  100% { opacity: 1; transform: none; }
	}
	#shopClose:hover { color: #ff6464; transform: scale(1.13); }
	.bought-flash {
	  animation: flashBtn 0.22s;
	}
	@keyframes flashBtn {
	  0% { box-shadow: 0 0 0px #67fa62, 0 0 0px #fff; background: #34c24c;}
	  55% { box-shadow: 0 0 11px #67fa62, 0 0 22px #fff9;}
	  100% { box-shadow: 0 0 0px #67fa62, 0 0 0px #fff; }
	}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="hudStats">
    <div id="hudAlive"></div>
	<div id="hudMoney"></div>
    <div id="hudZombies"></div>
    <div id="hudKills"></div>
    <div id="hudRound"></div>
    <div id="hudHP"></div>
  </div>

  <div id="deathScreen">
    <div id="deathScreenInner">
      <h2 id="deathTitle"></h2>
      <div id="deathStats"></div>
      <button id="btnReplay"></button>
    </div>
  </div>
  <div id="lobbyScreen">
    <div id="lobbyBox">
      <div id="lobbyTitle" style="font-size: 28px; margin-bottom: 18px;"><b>Zombination.io</b></div>
      <div id="lobbyPlayers"></div>
      <div id="lobbyTimer"></div>
      <div id="lobbyStatus"></div>
      <input type="text" id="pseudoInput" maxlength="15" placeholder="" />
      <br>
      <button id="lobbyJoin"></button>
      <div id="langSelectRow"></div>
    </div>
  </div>
	 <button id="shopBtn" title="Boutique" style="display: flex; align-items: center; position: fixed; right: 20px; bottom: 52px; z-index: 21; background: #232; color: #fff; border-radius: 13px; border: none; font-size: 22px; padding: 10px 26px 10px 19px; box-shadow: 0 2px 14px #0006; cursor: pointer; gap: 13px; transition: background 0.17s;">
	  <img src="/icons/cart.svg" alt="Shop" style="width: 27px; height: 27px; margin-right: 8px; filter: brightness(1.25) drop-shadow(0 2px 5px #0006);" />
	  SHOP
	</button>
	
	
	

<!-- ==== BARRE D'ACHATS STRUCTURES (au-dessus du SHOP) ==== -->
<div id="buildBar" style="position:fixed; right:20px; bottom:122px; z-index:10006; display:flex; gap:10px; flex-direction:column; align-items:flex-end;">
  <!-- Conteneur horizontal des 4 tuiles -->
  <div id="buildTiles" style="display:flex; gap:10px;">
    <!-- Grande tourelle (avec petit canon) -->
    <button class="build-tile" data-type="T" data-tip="Tourelle (HP: 500, Dégâts: 5, Cadence: ~6.7/s)" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
      <div style="width:42px;height:42px;background:#d33;border:2px solid #3a0b0b;box-shadow:0 2px 8px #0007; position:relative;">
        <!-- petit canon -->
        <div style="position:absolute; left:50%; top:50%; width:16px; height:3px; background:#3a0b0b; transform:translate(0,-50%); border-radius:2px;"></div>
      </div>
      <div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$1000</div>
    </button>

    <!-- Mini-tourelle (avec petit canon) -->
    <button class="build-tile" data-type="t" data-tip="Mini-tourelle (HP: 200, Dégâts: 5, Cadence: 1/s)" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
      <div style="width:42px;height:42px;background:#3aa6ff;border:2px solid #0b1b2a;box-shadow:0 2px 8px #0007; position:relative;">
        <!-- petit canon -->
        <div style="position:absolute; left:50%; top:50%; width:14px; height:3px; background:#0b1b2a; transform:translate(0,-50%); border-radius:2px;"></div>
      </div>
      <div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$250</div>
    </button>

    <!-- Mur (barricade) -->
    <button class="build-tile" data-type="B" data-tip="Mur (HP: 200)" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
      <div style="width:42px;height:42px;background:#7b4b2a;border:2px solid #000;box-shadow:0 2px 8px #0007;"></div>
      <div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$100</div>
    </button>

    <!-- Porte -->
    <button class="build-tile" data-type="D" data-tip="Porte (HP: 200)" style="display:flex; flex-direction:column; align-items:center; gap:6px; background:#0000; border:none; cursor:pointer;">
      <div style="width:42px;height:42px;background:#a57b4a;border:2px solid #000;box-shadow:0 2px 8px #0007;"></div>
      <div style="font-size:13px;color:#fff;background:#232;padding:3px 6px;border-radius:8px;box-shadow:0 1px 6px #0006;">$200</div>
    </button>
  </div>

  <!-- Tooltip hover -->
  <div id="buildTooltip" style="display:none; position:absolute; right:0; bottom:70px; max-width:260px; background:#111c; color:#fff; font-size:13px; padding:8px 10px; border-radius:8px; box-shadow:0 4px 18px #000a; pointer-events:none; white-space:nowrap;"></div>
</div>


	
	
	<div id="shopModal" style="display:none; position:fixed; right:34px; bottom:90px; background:#181e19ee; border-radius:18px; box-shadow:0 8px 28px #000c; min-width:340px; min-height:280px; padding:32px 26px 22px 26px;">
	  <button id="shopClose" style="position:absolute; right:17px; top:10px; background:none; border:none; color:#fff; font-size:26px; cursor:pointer; filter:drop-shadow(0 2px 6px #0009);">✕</button>
	  <div style="font-size:26px; margin-bottom:15px; display:flex; align-items:center; gap:10px;">
		<img src="/icons/cart.svg" alt="Shop" style="width:30px; filter:brightness(1.2); vertical-align:middle;">
		<span>SHOP</span>
	  </div>
	  <div id="shopUpgrades">
		<!-- Ici viendront les lignes d’améliorations à l’étape suivante -->
		<div style="color:#fff6; font-size:17px; margin-top:18px;">Boutique à venir : <i>Affichage des améliorations ici à l’étape 3</i></div>
	  </div>
	</div>
  <div id="versionBox">Version 1.0.0 par Myg</div>
  <div id="waveMessage"></div>
  <script src="/translations.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  
  
    <!-- === Mobile Build Buttons === -->
<div id="mobile-build" class="mobile-build">
  <button class="mb-btn" data-type="B" aria-label="Construire Mur (B)">Mur</button>
  <button class="mb-btn" data-type="D" aria-label="Construire Porte (D)">Porte</button>
  <button class="mb-btn" data-type="t" aria-label="Construire Mini-Tourelle (t)">Mini-T</button>
  <button class="mb-btn" data-type="T" aria-label="Construire Grande Tourelle (T)">Tourelle</button>
</div>

<style>
  /* Mobile only */
  
	 @media (max-width: 768px) and (orientation: portrait) {
	  .mobile-build { 
		display: none !important; 
	  }
	}
  @media (max-width: 768px) {
	.mobile-build {
	  position: fixed;
	  left: 50%;
	  bottom: calc(env(safe-area-inset-bottom, 0px) + 96px); /* marge iOS + au-dessus du Shop */
	  transform: translateX(-50%);
	  display: grid;
	  grid-template-columns: repeat(4, auto);
	  gap: 10px;
	  padding: 10px 12px;
	  background: rgba(0,0,0,0.35);
	  backdrop-filter: blur(6px);
	  border-radius: 14px;
	  z-index: 10007; /* supérieur au Shop */
	  user-select: none;
	}
 .mb-btn {
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      background: #222;
      color: #fff;
    }
    .mobile-build .mb-btn:active {
      transform: translateY(1px);
    }
  }

  /* Desktop: hide */
  @media (min-width: 769px) {
    .mobile-build { display: none; }
  }
</style>
<!-- === /Mobile Build Buttons === -->
  
  
  
  <script>
  



  window.addEventListener('contextmenu', e => e.preventDefault(), { passive: false });
    // --- LANG/LOBBY ---
    const LANGS = [
      { code: 'en', flag: 'gb.png', label: 'English' },
      { code: 'cn', flag: 'cn.png', label: '中文' },
      { code: 'ru', flag: 'ru.png', label: 'Русский' },
      { code: 'es', flag: 'es.png', label: 'Español' },
      { code: 'pt', flag: 'pt.png', label: 'Português' },
      { code: 'de', flag: 'de.png', label: 'Deutsch' },
      { code: 'jp', flag: 'jp.png', label: '日本語' },
      { code: 'fr', flag: 'fr.png', label: 'Français' },
      { code: 'pl', flag: 'pl.png', label: 'Polski' },
      { code: 'kr', flag: 'kr.png', label: '한국어' }
    ];
    function getDefaultLang() { return "en"; }
    let currentLang = getDefaultLang();
    let lobbyData = { started: false, count: 0, max: 6, timeLeft: 30, players: {} };
    let lobbyJoined = false, lobbyStarted = false;
    function initLobbyTexts() {
      updateLobbyTexts();
      pseudoInput.placeholder = TRANSLATIONS[currentLang].enterPseudo;
      lobbyJoin.textContent = TRANSLATIONS[currentLang].join;
    }
    function updateLobbyTexts() {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      lobbyPlayers.textContent = `${tr.playersInGame} : ${lobbyData.count}/${lobbyData.max}`;
      lobbyTimer.textContent = `${tr.timeLeft} : ${lobbyData.timeLeft}s`;
      const readyCount = Object.values(lobbyData.players).filter(p=>p.ready).length;
      lobbyStatus.textContent = `${tr.waitingStart} (${readyCount} ${tr.playersReady}${readyCount>1?'s':''})`;
    }
    function updateUITexts() {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      document.getElementById('lobbyTitle').innerHTML = `<b>${tr.zombination}</b>`;
      pseudoInput.placeholder = tr.enterPseudo;
      lobbyJoin.textContent = lobbyJoined ? tr.waiting : tr.join;
      document.getElementById('deathTitle').textContent = tr.youDied;
      btnReplay.textContent = tr.replay;
      if (!lobbyStarted) { updateLobbyTexts(); }
    }
    const langSelectRow = document.getElementById('langSelectRow');
    function renderLangFlags() {
      langSelectRow.innerHTML = '';
      LANGS.forEach(lang => {
        const img = document.createElement('img');
        img.src = `/flags/${lang.flag}`;
        img.alt = lang.label;
        img.title = lang.label;
        img.className = 'langFlag' + (lang.code === currentLang ? ' selected' : '');
        img.onclick = () => {
          if (currentLang !== lang.code) {
            currentLang = lang.code;
            renderLangFlags(); updateUITexts(); drawHUD();
          }
        };
        langSelectRow.appendChild(img);
      });
    }
    const pseudoInput = document.getElementById('pseudoInput');
	pseudoInput.addEventListener('input', function() {
	  this.value = this.value.replace(/[^a-zA-Z0-9]/g, '');
	});

    const lobbyJoin = document.getElementById('lobbyJoin');
    const lobbyPlayers = document.getElementById('lobbyPlayers');
    const lobbyTimer = document.getElementById('lobbyTimer');
    const lobbyStatus = document.getElementById('lobbyStatus');
    const deathTitle = document.getElementById('deathTitle');
    const deathStats = document.getElementById('deathStats');
    const btnReplay = document.getElementById('btnReplay');
	const deathScreen = document.getElementById('deathScreen');
    renderLangFlags(); initLobbyTexts();

    // --- JEU ---
    const socket = io({ transports: ['websocket'] });
// ---- Throttle pour moveDir (anti-flood) ----
let lastMoveSent = { x: 0, y: 0 };
let lastMoveEmitTs = 0;
const MOVE_EMIT_INTERVAL_MS = 50;   // max ~20 Hz
const MOVE_EPS = 0.02;              // tolérance de changement (évite les micros variations)
const MOVE_HEARTBEAT_MS = 500;      // pour éviter les timeouts si on reste immobile

function nearlyEqual(a, b, eps) { return Math.abs(a - b) < eps; }

function emitMoveThrottled(move) {
  const now = performance.now();
  const changed =
    !nearlyEqual(move.x, lastMoveSent.x, MOVE_EPS) ||
    !nearlyEqual(move.y, lastMoveSent.y, MOVE_EPS);

  const due = (now - lastMoveEmitTs) >= MOVE_EMIT_INTERVAL_MS;
  const heartbeatDue = (now - lastMoveEmitTs) >= MOVE_HEARTBEAT_MS;

  if ((changed && due) || heartbeatDue) {
    socket.emit('moveDir', move);
    lastMoveSent = { x: move.x, y: move.y };
    lastMoveEmitTs = now;
  }
}

let currentRound = 1;
let playersHealth = {};
let zombies = {};
let bullets = {};
let turretLasers = [];
const turretAngleCache = new Map(); // key: "turret_c_r" -> { ang, t }

// ---- Perf caches (par frame) ----
let FRAME_ID = 0;
let ZOMBIES_FRAME = [];
let ZOMBIES_FRAME_ID = -1;

// portée max (monde) à laquelle une tourelle cherche une cible
const TURRET_TARGET_MAX_DIST = 1000;
const TURRET_TARGET_MAX_DIST2 = TURRET_TARGET_MAX_DIST * TURRET_TARGET_MAX_DIST;

// Met à jour la liste plate des zombies une seule fois par frame
function refreshZombiesFrame() {
  if (ZOMBIES_FRAME_ID !== FRAME_ID) {
    // Array “plat” (évite Object.values(...) X fois)
    ZOMBIES_FRAME = [];
    for (const z of Object.values(zombies)) {
      // on peut ignorer les morts si jamais présents
      if (!z || z.hp <= 0) continue;
      ZOMBIES_FRAME.push(z);
    }
    ZOMBIES_FRAME_ID = FRAME_ID;
  }
}


const TURRET_ANGLE_TTL_MS = 180;    // durée de cache (ms)
let zombiesRemaining = 0;
let waveTotalZombies = 0;
let waveKilledThisWave = 0;
let structures = null;
let structHPGrid = null;

socket.on('stateUpdate', (payload) => {
  if (!payload) return;

  if (payload.zombies)        zombies = payload.zombies;
  if (payload.bullets)        bullets = payload.bullets;
  if (payload.playersHealth)  playersHealth = payload.playersHealth;
  if (typeof payload.round === 'number') currentRound = payload.round;

  // 1) Grille HP optionnelle + application immédiate aux structures existantes
  if (payload.structuresHP) {
    structHPGrid = payload.structuresHP;

    // Si on n'a PAS reçu de nouvelle grille de structures,
    // on pousse quand même les HP dans la grille locale pour mettre à jour les barres
    if (structures && !payload.structures) {
      const rows = Math.min(structHPGrid.length, MAP_ROWS);
      for (let y = 0; y < rows; y++) {
        const cols = Math.min(structHPGrid[y]?.length || 0, MAP_COLS);
        for (let x = 0; x < cols; x++) {
          const hp = structHPGrid[y][x];
          const cell = structures[y]?.[x];
          if (cell) {
            if (typeof cell === 'object') {
              cell.hp = hp;
            } else if (typeof cell === 'string') {
              structures[y][x] = { type: cell, hp };
            }
            // si HP <= 0 → on supprime visuellement
            if (typeof hp === 'number' && hp <= 0) {
              structures[y][x] = null;
            }
          }
        }
      }
    }
  }

  // 2) Normalisation/merge de la grille structures reçue
  if (payload.structures) {
    const grid = payload.structures;
    const rows = grid.length || 0;
    const cols = rows ? (grid[0]?.length || 0) : 0;

    structures = Array.from({ length: rows }, (_, y) =>
      Array.from({ length: cols }, (_, x) => {
        const cell = grid[y][x];
        if (!cell || cell === 0) return null;

        // HP prioritaire : structuresHP, sinon ancien HP local, sinon valeur par défaut
        const hpFromGrid = structHPGrid?.[y]?.[x];
        const previousHP = structures?.[y]?.[x]?.hp;

        if (typeof cell === 'object') {
          const type = cell.type;
          let hp = (typeof cell.hp === 'number') ? cell.hp
                  : (typeof hpFromGrid === 'number') ? hpFromGrid
                  : (typeof previousHP === 'number') ? previousHP
                  : (type === 'T' ? 500 : (type === 't' ? 200 : 200));
          if (hp <= 0) return null;
          return { type, hp };
        }

        if (typeof cell === 'string') {
          const type = cell;
          let hp = (typeof hpFromGrid === 'number') ? hpFromGrid
                  : (typeof previousHP === 'number') ? previousHP
                  : (type === 'T' ? 500 : (type === 't' ? 200 : 200));
          if (hp <= 0) return null;
          return { type, hp };
        }

        return null;
      })
    );
  }

  // 3) Destructions éventuelles en lot
  if (Array.isArray(payload.destroyedStructures)) {
    payload.destroyedStructures.forEach(({ tx, ty }) => {
      if (structures?.[ty]) structures[ty][tx] = null;
      if (structHPGrid?.[ty]) structHPGrid[ty][tx] = 0;
    });
  }

  drawHUD();
});

	
	setInterval(() => {
	  if (socket && socket.connected) {
		socket.emit('clientPing');
	  }
	}, 10000); // Toutes les 8 secondes (tu peux mettre 10000 pour 10s)
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
	let mapBuffer = null, mapBufCtx = null, mapBufW = 0, mapBufH = 0;
    const hudAlive = document.getElementById('hudAlive');
    const hudZombies = document.getElementById('hudZombies');
    const hudKills = document.getElementById('hudKills');
    const hudRound = document.getElementById('hudRound');
    const hudHP = document.getElementById('hudHP');
	const hudMoney = document.getElementById('hudMoney');
	let myMoney = 0;
	

const UPGRADES = [
  {
    id: "maxHp",
    label: "+10% Vie max",
    desc: "Augmente les PV max.",
    icon: "/icons/heart.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 100,
    statLabel: "PV max",
    format: v => v + " PV"
  },
  {
    id: "speed",
    label: "+10% Vitesse",
    desc: "Déplace-toi plus vite.",
    icon: "/icons/speed.svg",
    getValue: (base, level) => +(base * Math.pow(1.1, level)).toFixed(1),
    baseValue: 50,
    statLabel: "Vitesse",
    format: v => v + " px/s"
  },
  {
    id: "regen",
    label: "Régénération PV",
    desc: "Regénère tes PV.",
    icon: "/icons/regen.svg",
    getValue: (base, level) => {
      if (level <= 10) return level;                 // 0..10 linéaire
      return +(10 * Math.pow(1.1, level - 10)).toFixed(2); // >10 : +10%/niv
    },
    baseValue: 0,
    statLabel: "Régén.",
    format: v => v + " PV/s"
  },
  {
    id: "damage",
    label: "+10% Dégâts",
    desc: "Tire plus fort.",
    icon: "/icons/bullet.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 5,
    statLabel: "Dégâts",
    format: v => v
  },
  {
    id: "goldGain",
    label: "+10% d'or gagné",
    desc: "Gagne plus d’or sur les zombies.",
    icon: "/icons/gold.svg",
    getValue: (base, level) => Math.round(base * Math.pow(1.1, level)),
    baseValue: 10, // goldGain commence à 10 côté serveur
    statLabel: "$/zombie",
    format: (v) => {
      const min = Math.round(10 * (v / 10));
      const max = Math.round(20 * (v / 10));
      return `$${min}–${max}`;
    }
  }
];


	// Niveau des upgrades du joueur local (simulé pour l’instant)
	let myUpgrades = {
	  maxHp: 0,
	  speed: 0,
	  regen: 0,
	  damage: 0,
	  goldGain: 0
	};

const waveMessage = document.getElementById('waveMessage');


function resetWaveCounters(total = 0) {
  waveTotalZombies   = Number(total) || 0;
  waveKilledThisWave = 0;
  zombiesRemaining   = waveTotalZombies; // au départ, il reste tout le monde
  drawHUD();
}

    let myId = null, playerHealth = 100, isDead = false, myKills = 0, myPseudo = "";
	let shootBlocked = false;
	let moneyFloatingTexts = []; // Pour stocker les "+$" à afficher
	let buildMode = null;         // 'T' | 't' | 'B' | 'D' | null
	let buildHover = { tx: -1, ty: -1 }; // tuile survolée pendant le placement

	function curve(v) {
	  // 0.55 = plus sensible au centre (augmente si tu trouves encore trop mou)
	  const e = 0.55;
	  const s = Math.sign(v);
	  return s * Math.pow(Math.abs(v), e);
	}

    // Détection mobile
    function isMobile() { return /android|iphone|ipad|ipod|opera mini|iemobile|mobile/i.test(navigator.userAgent); }
    const isMobileDevice = isMobile();
	const HAS_POINTER = ('PointerEvent' in window);


	// === [ZOOM MOBILE PAYSAGE] ===
	let renderScale = 1;
	function updateRenderScale() {
	  if (!isMobileDevice) {
		renderScale = 1;
		return;
	  }
	  const isLandscape = window.matchMedia('(orientation: landscape)').matches;
	  // x2 en paysage => 0.5 ; x3 en portrait => ~0.333
	  renderScale = isLandscape ? 0.5 : 1/3;
	}


	updateRenderScale();
    const TILE_SIZE = 40;
    const PLAYER_RADIUS = 10;
    const ZOMBIE_RADIUS = 10;
	const CLIENT_VIEW_RADIUS = 420;
    let map = [], MAP_ROWS = 0, MAP_COLS = 0;

// === Helpers map/structures (client) ===
function worldToTile(x, y) {
  return { tx: Math.floor(x / TILE_SIZE), ty: Math.floor(y / TILE_SIZE) };
}
function isWallAt(tx, ty) {
  if (!map || ty < 0 || ty >= MAP_ROWS || tx < 0 || tx >= MAP_COLS) return true;
  return map[ty][tx] === 1;
}
function structAtWorld(x, y) {
  if (!structures) return null;
  const { tx, ty } = worldToTile(x, y);
  if (ty < 0 || ty >= MAP_ROWS || tx < 0 || tx >= MAP_COLS) return null;
  return structures[ty]?.[tx] || null;
}
function isSolidForZombieClient(struct) {
  // pour la ligne de vue côté client : tout ce qui a des PV bloque
  return struct && struct.hp > 0; // B, D, T…
}
function losBlockedForZombieClient(x0, y0, x1, y1) {
  const dx = x1 - x0, dy = y1 - y0;
  const dist = Math.hypot(dx, dy);
  if (dist < 1) return false;
  const steps = Math.ceil(dist / 8);
  for (let s = 1; s < steps; s++) {
    const ix = x0 + (dx * s / steps);
    const iy = y0 + (dy * s / steps);
    const { tx, ty } = worldToTile(ix, iy);
    if (isWallAt(tx, ty)) return true;
    const st = structures?.[ty]?.[tx];
    if (isSolidForZombieClient(st)) return true;
  }
  return false;
}




// Version optimisée :
// - lit une liste ZOMBIES_FRAME rafraîchie une fois par frame
// - filtre par distance max avant de tester la LOS
function findTurretTargetAngle(turretKey, cxWorld, cyWorld) {
  const now = performance.now();

  // 1) Cache angle récent
  const cached = turretAngleCache.get(turretKey);
  if (cached && (now - cached.t) <= TURRET_ANGLE_TTL_MS) {
    return cached.ang;
  }

  // 2) S'assure que la liste des zombies est rafraîchie pour ce frame
  refreshZombiesFrame();

  // 3) Cherche la cible la plus proche dans la portée
  let bestDist2 = Infinity;
  let bdx = 1, bdy = 0;

  for (let i = 0; i < ZOMBIES_FRAME.length; i++) {
    const z = ZOMBIES_FRAME[i];
    const dx = z.x - cxWorld;
    const dy = z.y - cyWorld;
    const d2 = dx*dx + dy*dy;

    // filtre distance (très bon gain)
    if (d2 > TURRET_TARGET_MAX_DIST2) continue;

    // on ne paie la LOS que si d2 est déjà meilleur
    if (d2 < bestDist2) {
      if (!losBlockedForZombieClient(cxWorld, cyWorld, z.x, z.y)) {
        bestDist2 = d2;
        bdx = dx; bdy = dy;
      }
    }
  }

  const ang = Math.atan2(bdy, bdx);
  turretAngleCache.set(turretKey, { ang, t: now });
  return ang;
}


    let cameraX = 0, cameraY = 0;
    const keys = {};
    let mouseDown = false, mousePos = { x: 0, y: 0 };
    let aimDir = { x: 1, y: 0 }; // direction de visée par défaut (droite)
	let lastAimDir = { x: 1, y: 0 };
	
	window.addEventListener('keydown', e => {
	  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
		e.preventDefault(); // évite le scroll de la page !
	  }
	  keys[e.key.toLowerCase()] = true;
	});
	window.addEventListener('keyup', e => {
	  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
		e.preventDefault();
	  }
	  keys[e.key.toLowerCase()] = false;
	});
	
window.addEventListener('mousedown', e => {
  if (buildMode) { e.preventDefault(); return; }   // ← ajoute ça
  const sm = document.getElementById('shopModal');
  if (sm && sm.style.display === 'block') return;
  mouseDown = e.button === 0;
});


    window.addEventListener('mouseup', e => { if (e.button === 0) mouseDown = false; });
    window.addEventListener('mousemove', e => {
      mousePos = { x: e.clientX, y: e.clientY };
      if (!isMobileDevice && myId && playersHealth[myId]) {
        const player = playersHealth[myId];
		aimDir = {
		  x: (cameraX + mousePos.x / renderScale) - player.x,
		  y: (cameraY + mousePos.y / renderScale) - player.y
		};
        let len = Math.hypot(aimDir.x, aimDir.y);
        if (len > 0) {
          aimDir.x /= len;
          aimDir.y /= len;
        }
      }
    });
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

function createMapBuffer() {
  if (!map || !map.length) return;

  mapBufW = MAP_COLS * TILE_SIZE;
  mapBufH = MAP_ROWS * TILE_SIZE;

  // (Re)crée le canvas offscreen
  mapBuffer = document.createElement('canvas');
  mapBuffer.width  = mapBufW;
  mapBuffer.height = mapBufH;
  mapBufCtx = mapBuffer.getContext('2d');

  // Fond neutre (optionnel) : on laisse transparent, on ne dessine que les murs
  // Rendu des tuiles MURS une seule fois
  mapBufCtx.fillStyle = '#363636';
  for (let r = 0; r < MAP_ROWS; r++) {
    for (let c = 0; c < MAP_COLS; c++) {
      if (map[r][c] === 1) {
        mapBufCtx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }
  }
}



    // JOYSTICK PATCH MOBILE
    let moveJoy = null, aimJoy = null;
	let moveJoyVal = {x:0, y:0}, aimJoyVal = {x:0, y:0}; // valeurs normalisées [-1..1]
	
function createJoystick(container, baseX, baseY, id) {
  const size = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.23);
  const joyDiv = document.createElement('div');
  joyDiv.className = 'joystick-container';
  joyDiv.style.left = baseX + 'px';
  joyDiv.style.top = baseY + 'px';
  joyDiv.style.width = size + 'px';
  joyDiv.style.height = size + 'px';
  joyDiv.id = id;
  joyDiv.style.pointerEvents = 'auto';
  document.body.appendChild(joyDiv);

  const base = document.createElement('div');
  base.className = 'joystick-base';
  base.style.width = size + 'px';
  base.style.height = size + 'px';
  base.style.background = 'rgba(255,255,255,0.12)';
  base.style.borderRadius = '50%';
  base.style.position = 'absolute';
  base.style.left = '0px';
  base.style.top = '0px';
  base.style.pointerEvents = 'auto';
  joyDiv.appendChild(base);

  const stick = document.createElement('div');
  stick.className = 'joystick-stick';
  stick.style.width = (size * 0.52) + 'px';
  stick.style.height = (size * 0.52) + 'px';
  stick.style.background = 'rgba(160,255,240,0.45)';
  stick.style.borderRadius = '50%';
  stick.style.position = 'absolute';
  stick.style.left = (size * 0.24) + 'px';
  stick.style.top = (size * 0.24) + 'px';
  stick.style.pointerEvents = 'auto';
  joyDiv.appendChild(stick);

  return { joyDiv, base, stick, size };
}



function addJoystickHandlers(joy, which) {
  const size = joy.size;
  const radius = size / 2;
  const stickRadius = (size * 0.52) / 2;
  const center = { x: radius, y: radius };

  let activeId = null;

  function setVec(dx, dy) {
    const max = radius - stickRadius;
    const len = Math.hypot(dx, dy);

    // clamp visuel
    let nx = dx, ny = dy;
    if (len > max && len > 0) {
      nx = dx * (max / len);
      ny = dy * (max / len);
    }

    // position visuelle
    joy.stick.style.left = (center.x - stickRadius + nx) + "px";
    joy.stick.style.top  = (center.y - stickRadius + ny) + "px";

    // vecteur normalisé [-1..1]
    const out = (max > 0) ? { x: nx / max, y: ny / max } : { x: 0, y: 0 };
    if (which === "move") moveJoyVal = out;
    else aimJoyVal = out;
  }

  function reset() {
    activeId = null;
    setVec(0, 0);
  }

  function localCoords(clientX, clientY) {
    const r = joy.joyDiv.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }

  function onDown(e) {
    if (activeId !== null) return;
    activeId = e.pointerId;
    joy.joyDiv.setPointerCapture(activeId);
    const p = localCoords(e.clientX, e.clientY);
    setVec(p.x - center.x, p.y - center.y);
    e.preventDefault();
  }

  function onMove(e) {
    if (e.pointerId !== activeId) return;
    const p = localCoords(e.clientX, e.clientY);
    setVec(p.x - center.x, p.y - center.y);
    e.preventDefault();
  }

  function onUp(e) {
    if (e.pointerId !== activeId) return;
    try { joy.joyDiv.releasePointerCapture(activeId); } catch {}
    reset();
    e.preventDefault();
  }

  // down sur toute la zone
  joy.joyDiv.addEventListener('pointerdown', onDown, { passive: false });
  joy.base.addEventListener('pointerdown', onDown, { passive: false });
  joy.stick.addEventListener('pointerdown', onDown, { passive: false });

  // move/up globaux
  window.addEventListener('pointermove', onMove, { passive: false });
  window.addEventListener('pointerup', onUp, { passive: false });
  window.addEventListener('pointercancel', onUp, { passive: false });

  reset();
}


	function addJoystickTouchHandlers(joy, which) {
	  const size = joy.size;
	  const radius = size / 2;
	  const stickRadius = (size * 0.52) / 2;
	  const center = { x: radius, y: radius };

	  let active = false;
	  let lastId = null;

	  function setVec(dx, dy) {
		const max = radius - stickRadius;
		const len = Math.hypot(dx, dy);
		let nx = dx, ny = dy;
		if (len > max && len > 0) {
		  nx = dx * (max / len);
		  ny = dy * (max / len);
		}
		joy.stick.style.left = (center.x - stickRadius + nx) + "px";
		joy.stick.style.top  = (center.y - stickRadius + ny) + "px";
		const out = (max > 0) ? { x: nx / max, y: ny / max } : { x: 0, y: 0 };
		if (which === "move") moveJoyVal = out;
		else aimJoyVal = out;
	  }

	  function reset() {
		active = false;
		lastId = null;
		setVec(0, 0);
	  }

	  function localCoords(clientX, clientY) {
		const r = joy.joyDiv.getBoundingClientRect();
		return { x: clientX - r.left, y: clientY - r.top };
	  }

	  function onStart(e) {
		if (active) return;
		const t = e.changedTouches ? e.changedTouches[0] : null;
		if (!t) return;
		active = true;
		lastId = t.identifier;
		const p = localCoords(t.clientX, t.clientY);
		setVec(p.x - center.x, p.y - center.y);
		e.preventDefault();
	  }

	  function onMove(e) {
		if (!active) return;
		const touches = e.changedTouches;
		for (let i = 0; i < touches.length; i++) {
		  const t = touches[i];
		  if (t.identifier !== lastId) continue;
		  const p = localCoords(t.clientX, t.clientY);
		  setVec(p.x - center.x, p.y - center.y);
		  e.preventDefault();
		  break;
		}
	  }

	  function onEnd(e) {
		if (!active) return;
		const touches = e.changedTouches;
		for (let i = 0; i < touches.length; i++) {
		  const t = touches[i];
		  if (t.identifier !== lastId) continue;
		  reset();
		  e.preventDefault();
		  break;
		}
	  }

	  // down sur toute la zone
	  joy.joyDiv.addEventListener('touchstart', onStart, { passive: false });
	  joy.base.addEventListener('touchstart', onStart, { passive: false });
	  joy.stick.addEventListener('touchstart', onStart, { passive: false });

	  // move/up globaux
	  window.addEventListener('touchmove', onMove, { passive: false });
	  window.addEventListener('touchend', onEnd, { passive: false });
	  window.addEventListener('touchcancel', onEnd, { passive: false });

	  reset();
	}




function setupJoysticks() {
  if (!isMobileDevice) return;

  // Nettoyage
  if (moveJoy && moveJoy.joyDiv) moveJoy.joyDiv.remove();
  if (aimJoy && aimJoy.joyDiv) aimJoy.joyDiv.remove();

  const padding = 36;
  const joySize = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.23);
  let joyY = window.innerHeight - joySize - padding;
  if (joyY < padding) joyY = padding;

  // Crée les deux joysticks
  moveJoy = createJoystick(document.body, padding, joyY, "moveJoy");
  aimJoy  = createJoystick(document.body, window.innerWidth - joySize - padding, joyY, "aimJoy");

  // 👉 branchement selon le support
  if (HAS_POINTER) {
    addJoystickHandlers(moveJoy, "move");
    addJoystickHandlers(aimJoy,  "aim");
  } else {
    addJoystickTouchHandlers(moveJoy, "move");
    addJoystickTouchHandlers(aimJoy,  "aim");
  }

  // Repositionne l’UI shop
  positionShopUI();
}


// ===== remplace entièrement cette fonction =====
function positionShopUI() {
  if (!isMobileDevice) return;
  const shopBtnEl   = document.getElementById('shopBtn');
  const shopModalEl = document.getElementById('shopModal');
  const buildBarEl  = document.getElementById('buildBar');
  if (!aimJoy || !aimJoy.joyDiv || !shopBtnEl) return;

  const isPortrait = window.matchMedia("(orientation: portrait)").matches;
  const joyRect = aimJoy.joyDiv.getBoundingClientRect();

  // --- Bouton SHOP au-dessus du joystick droit ---
  const btnGap = 20; // espace entre bouton et joystick
  shopBtnEl.style.position = "fixed";
  shopBtnEl.style.zIndex   = "10005";
  shopBtnEl.style.right    = (window.innerWidth - joyRect.right) + "px";
  shopBtnEl.style.bottom   = (window.innerHeight - joyRect.top) + btnGap + "px";

  // --- Panneau SHOP : aligné à droite du joystick, et assez haut pour ne pas chevaucher ---
  if (shopModalEl) {
    const gap = isPortrait ? 28 : 12;
    const availableHeightAboveJoystick = Math.max(0, joyRect.top - gap);
    const margin = 10;

    const maxH = Math.max(180, Math.min(availableHeightAboveJoystick - margin, window.innerHeight - 2*margin));
    shopModalEl.style.maxHeight = maxH + "px";
    shopModalEl.style.overflowY = "auto";

    if (!isPortrait) {
      shopModalEl.style.minWidth = "300px";
      shopModalEl.style.maxWidth = Math.min(360, window.innerWidth - 20) + "px";
    }

    // ancrage horizontal à droite du joystick
    shopModalEl.style.right = (window.innerWidth - joyRect.right + 14) + "px";

    // recalage vertical au-dessus du joystick
    let computedBottom = (window.innerHeight - joyRect.top) + gap;
    const minBottom = 8;
    const maxBottom = window.innerHeight - 120;
    if (computedBottom < minBottom) computedBottom = minBottom;
    if (computedBottom > maxBottom) computedBottom = maxBottom;
    shopModalEl.style.bottom = computedBottom + "px";
  }

  // --- ❶ NOUVEAU : positionner la barre de construction juste au-dessus du bouton SHOP ---
  if (buildBarEl) {
    // aligne horizontalement avec le bouton SHOP
    buildBarEl.style.position = "fixed";
    buildBarEl.style.right = shopBtnEl.style.right;

    // place la barre juste au-dessus du bouton SHOP (écart 12px)
    const btnBottomPx = parseFloat(shopBtnEl.style.bottom) || 0;
    const btnHeight   = shopBtnEl.offsetHeight || 56; // fallback si non rendu
    const gapAboveBtn = 12;
    buildBarEl.style.bottom = (btnBottomPx + btnHeight + gapAboveBtn) + "px";

    // priorité d’affichage au-dessus du SHOP
    buildBarEl.style.zIndex = "10006";
  }
}





function drawMap() {
  if (!map || !map.length) return;
  // Génère le buffer si nécessaire (ou si tailles non prêtes)
  if (!mapBuffer || mapBufW !== MAP_COLS * TILE_SIZE || mapBufH !== MAP_ROWS * TILE_SIZE) {
    createMapBuffer();
  }
  if (!mapBuffer) return;

  // Calcule la portion visible (en coordonnées monde)
  const viewW = Math.ceil(canvas.width  / renderScale);
  const viewH = Math.ceil(canvas.height / renderScale);
  const sx = Math.floor(cameraX);
  const sy = Math.floor(cameraY);
  const sW = Math.min(viewW, mapBufW - sx);
  const sH = Math.min(viewH, mapBufH - sy);
  if (sW <= 0 || sH <= 0) return;

  // Dessine le morceau nécessaire du buffer à la bonne position
  ctx.drawImage(
    mapBuffer,
    sx, sy, sW, sH,              // source rect (dans le buffer)
    sx - cameraX, sy - cameraY,  // destination (coord. monde → après setTransform)
    sW, sH
  );
}


function drawStructures() {
  if (!structures) return;

  // HP helpers
  function getHP(r, c, type, cell) {
    const defaultMax = (type === 'T') ? 500 : (type === 't' ? 200 : 200);
    const hpFromObj  = (typeof cell === 'object') ? cell.hp : undefined;
    const hpNorm = (structHPGrid && structHPGrid[r]) ? structHPGrid[r][c] : undefined;
    const hpSwap = (structHPGrid && structHPGrid[c]) ? structHPGrid[c][r] : undefined;
    if (typeof hpNorm === 'number') return hpNorm;
    if (typeof hpFromObj === 'number') return hpFromObj;
    if (typeof hpSwap === 'number') return hpSwap;
    return defaultMax;
  }
  function destroyCell(r, c) {
    if (structures?.[r]) structures[r][c] = null;
    if (structHPGrid) {
      if (!structHPGrid[r]) structHPGrid[r] = [];
      structHPGrid[r][c] = 0;
      if (!structHPGrid[c]) structHPGrid[c] = [];
      structHPGrid[c][r] = 0;
    }
  }

  // Liste des zombies : 1 rafraîchissement par frame
  refreshZombiesFrame();

  const viewW = canvas.width / renderScale;
  const viewH = canvas.height / renderScale;
  const startCol = Math.floor(cameraX / TILE_SIZE);
  const startRow = Math.floor(cameraY / TILE_SIZE);
  const visibleCols = Math.ceil(viewW / TILE_SIZE) + 2;
  const visibleRows = Math.ceil(viewH / TILE_SIZE) + 2;

  for (let row = startRow; row < startRow + visibleRows; row++) {
    if (row < 0 || row >= MAP_ROWS) continue;
    for (let col = startCol; col < startCol + visibleCols; col++) {
      if (col < 0 || col >= MAP_COLS) continue;

      let cell = structures[row]?.[col];
      if (!cell) continue;

      let type, hp;
      if (typeof cell === 'object') type = cell.type; else type = cell;
      if (!type) continue;

      hp = getHP(row, col, type, cell);
      if (!(hp > 0)) {
        destroyCell(row, col);
        continue;
      }

      if (typeof cell !== 'object') {
        if (structures[row]) structures[row][col] = { type, hp };
        cell = structures[row][col];
      } else {
        cell.hp = hp;
      }

      const x = col * TILE_SIZE - cameraX;
      const y = row * TILE_SIZE - cameraY;

      if (type === 'B') {
        ctx.fillStyle = '#7b4b2a';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

      } else if (type === 'D') {
        ctx.fillStyle = '#a57b4a';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

      } else if (type === 'T' || type === 't') {
        const isBig = (type === 'T');
        ctx.fillStyle = isBig ? '#d33' : '#3aa6ff';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.strokeStyle = isBig ? '#3a0b0b' : '#0b1b2a';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

        // Canon orienté
        const cx = x + TILE_SIZE / 2;
        const cy = y + TILE_SIZE / 2;
        const cxW = col * TILE_SIZE + TILE_SIZE / 2;
        const cyW = row * TILE_SIZE + TILE_SIZE / 2;

        const turretKey = `turret_${col}_${row}`;
        const ang = findTurretTargetAngle(turretKey, cxW, cyW);

        const L = TILE_SIZE * 0.38;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(ang) * L, cy + Math.sin(ang) * L);
        ctx.stroke();
      }
    }
  }
}


	function drawPlayers() {
	  for (const id in playersHealth) {
		const p = playersHealth[id];
		if (!p.alive) continue;
		const screenX = p.x - cameraX;
		const screenY = p.y - cameraY;
		ctx.beginPath();
		ctx.fillStyle = (id === myId) ? 'lime' : '#cfc';
		ctx.arc(screenX, screenY, PLAYER_RADIUS, 0, Math.PI * 2);
		ctx.fill();
		ctx.font = "bold 17px Arial";
		ctx.textAlign = "center";
		ctx.fillStyle = "#aad8ff";
		ctx.fillText(p.pseudo || "Joueur", screenX, screenY - PLAYER_RADIUS - 22);
		// <-- largeur fixe 30 pour joueur
		drawHealthBar(
		  screenX,
		  screenY - PLAYER_RADIUS - 13,
		  p.health,
		  p.maxHealth || 100,
		  30
		);
	  }
	}
	
	
function drawZombies() {
  if (!myId || !playersHealth[myId]) return;
  const me = playersHealth[myId];
  const vx = me.x;
  const vy = me.y;

  // Petite marge pour éviter le "clignotement" sur le bord du cercle
  const VIEW_MARGIN = 8;
  const R2 = (CLIENT_VIEW_RADIUS - VIEW_MARGIN) * (CLIENT_VIEW_RADIUS - VIEW_MARGIN);

  for (const id in zombies) {
    const z = zombies[id];

    // ❌ N’AFFICHE PAS les zombies au-delà de la zone visible
    const dx = z.x - vx;
    const dy = z.y - vy;
    if ((dx * dx + dy * dy) > R2) continue;

    const screenX = z.x - cameraX;
    const screenY = z.y - cameraY;
    ctx.beginPath();
    ctx.fillStyle = 'red';
    ctx.arc(screenX, screenY, ZOMBIE_RADIUS, 0, Math.PI * 2);
    ctx.fill();

    // Barre de vie
    drawHealthBar(screenX, screenY - ZOMBIE_RADIUS - 10, z.hp, z.maxHp);
  }
}




function drawBullets() {
  const viewW = canvas.width / renderScale;
  const viewH = canvas.height / renderScale;

  // marge pour éviter pop-in/out
  const M = 40;
  const minX = cameraX - M, maxX = cameraX + viewW + M;
  const minY = cameraY - M, maxY = cameraY + viewH + M;

  for (const id in bullets) {
    const b = bullets[id];
    // culling rapide
    if (b.x < minX || b.x > maxX || b.y < minY || b.y > maxY) continue;

    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = (b.owner === myId) ? 'yellow' : '#ff0';
    ctx.lineWidth = 3;
    ctx.moveTo(b.x - cameraX, b.y - cameraY);
    ctx.lineTo(
      b.x - cameraX - b.dx * 8,
      b.y - cameraY - b.dy * 8
    );
    ctx.stroke();
    ctx.restore();
  }
}




function drawTurretLasers() {
  if (!turretLasers.length) return;

  const now = performance.now();
  const LIFE_MS = 80;               // un peu plus court => moins d’objets à dessiner
  const MAX_LASERS_PER_FRAME = 150; // cap dur pour éviter les spikes

  // On garde seulement les plus récents si ça explose
  if (turretLasers.length > MAX_LASERS_PER_FRAME) {
    turretLasers = turretLasers.slice(turretLasers.length - MAX_LASERS_PER_FRAME);
  }

  // Un seul path par frame, sans ombre (shadowBlur coûte cher)
  ctx.save();
  ctx.lineWidth = 2;

  for (let i = turretLasers.length - 1; i >= 0; i--) {
    const b = turretLasers[i];
    const age = now - b.t;
    if (age > LIFE_MS) {
      turretLasers.splice(i, 1);
      continue;
    }

    const alpha = 1 - (age / LIFE_MS);
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = b.color || '#fff';

    ctx.beginPath();
    ctx.moveTo(b.x0 - cameraX, b.y0 - cameraY);
    ctx.lineTo(b.x1 - cameraX, b.y1 - cameraY);
    ctx.stroke();
  }

  ctx.restore();
}




	function drawMoneyFloatingTexts() {
	  const now = Date.now();
	  for (let i = moneyFloatingTexts.length - 1; i >= 0; i--) {
		const f = moneyFloatingTexts[i];
		const t = (now - f.time);
		if (t > f.duration) {
		  moneyFloatingTexts.splice(i, 1); // On le retire
		  continue;
		}
		// Position écran
		const screenX = f.x - cameraX;
		const screenY = f.y - cameraY + f.vy * t;

		ctx.save();
		ctx.globalAlpha = 1 - (t / f.duration); // Fade out progressif
		ctx.font = "bold 28px Arial";
		ctx.textAlign = "center";
		ctx.lineWidth = 3;
		ctx.strokeStyle = "#222";
		ctx.strokeText(`+${f.amount}$`, screenX, screenY);
		ctx.fillStyle = "#32ff72";
		ctx.fillText(`+${f.amount}$`, screenX, screenY);
		ctx.restore();
	  }
	}

	function drawHealthBar(x, y, current, max, width = null, height = 5) {
	  let w;
	  if (width !== null) {
		w = width;  // largeur fixée explicitement
	  } else {
		// largeur variable pour zombies, par exemple
		w = Math.max(30, Math.min(70, 30 + (max - 10) * 0.7));
	  }
	  const ratio = Math.max(0, Math.min(1, current / max));
	  ctx.fillStyle = '#111';
	  ctx.fillRect(x - w / 2, y, w, height);
	  ctx.fillStyle = (ratio < 0.4) ? "#e66" : "#8f8";
	  ctx.fillRect(x - w / 2, y, w * ratio, height);
	  ctx.strokeStyle = '#fff';
	  ctx.strokeRect(x - w / 2, y, w, height);
	}

function drawAimLine() {
  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  const player = playersHealth[myId];
  let dir = { x: 1, y: 0 };
  let show = false;

  if (isMobileDevice) {
    // 👉 même logique que le tir mobile (avec curve)
    let len = Math.hypot(aimJoyVal.x, aimJoyVal.y);
    if (len > 0.06) {
      let ax = aimJoyVal.x / (len || 1);
      let ay = aimJoyVal.y / (len || 1);
      ax = curve(ax);
      ay = curve(ay);
      const n = Math.hypot(ax, ay);
      if (n > 0.0001) dir = { x: ax / n, y: ay / n }; // on renormalise pour tracer une ligne propre
      show = true;
    }
  } else {
    if (mouseDown) {
      let dx = (cameraX + mousePos.x / renderScale) - player.x;
      let dy = (cameraY + mousePos.y / renderScale) - player.y;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 3) {
        dir = { x: dx / dist, y: dy / dist };
        show = true;
      }
    }
  }

  if (!show) return;

  const length = 440;
  const screenX = player.x - cameraX;
  const screenY = player.y - cameraY;

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(screenX, screenY);
  ctx.lineTo(screenX + dir.x * length, screenY + dir.y * length);
  ctx.strokeStyle = 'rgba(255,255,0,0.66)';
  ctx.lineWidth = 2;
  ctx.shadowColor = 'yellow';
  ctx.shadowBlur = 7;
  ctx.stroke();
  ctx.restore();
}

function drawLightMask() {
  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;

  // Centre du joueur en coordonnées écran (on tient compte du zoom)
  const p = playersHealth[myId];
  const screenX = (p.x - cameraX) * renderScale;
  const screenY = (p.y - cameraY) * renderScale;

  // On dessine l’overlay en coordonnées écran
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  ctx.save();
  // Couleur d’assombrissement de l’extérieur du halo
  ctx.fillStyle = 'rgba(0,0,0,0.45)';

  // Un seul chemin : un grand rectangle + un cercle au centre
  // puis on remplit avec la règle 'evenodd' => trou net dans le halo.
  ctx.beginPath();
  ctx.rect(0, 0, canvas.width, canvas.height);
  ctx.moveTo(screenX + CLIENT_VIEW_RADIUS, screenY); // facultatif, pour éviter une ligne
  ctx.arc(screenX, screenY, CLIENT_VIEW_RADIUS, 0, Math.PI * 2, true);
  ctx.fill('evenodd');

  ctx.restore();

  // On remet la transform monde pour le reste du rendu
  ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);
}



function update(deltaTime) {
  if (isDead || !myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
  let player = playersHealth[myId];
  let move = { x: 0, y: 0 };

  // ---- MOUVEMENT ----
  if (!isMobileDevice) {
    if (keys['arrowup'] || keys['w']) move.y -= 1;
    if (keys['arrowdown'] || keys['s']) move.y += 1;
    if (keys['arrowleft'] || keys['a']) move.x -= 1;
    if (keys['arrowright'] || keys['d']) move.x += 1;
  } else {
    const len = Math.hypot(moveJoyVal.x, moveJoyVal.y);
    if (len > 0.06) {
      let mx = moveJoyVal.x / (len || 1);
      let my = moveJoyVal.y / (len || 1);
      move.x = curve(mx);
      move.y = curve(my);
    }
  }

  // ⚠️ Remplacement de l'ancien "socket.emit('moveDir', move);" par :
  emitMoveThrottled(move);

  // ---- TIR ----
  let shooting = false;
  let shootDir = { x: 1, y: 0 };

  if (!isMobileDevice) {
    // ✅ corrige avec / renderScale
    let dx = (cameraX + mousePos.x / renderScale) - player.x;
    let dy = (cameraY + mousePos.y / renderScale) - player.y;
    let len = Math.hypot(dx, dy);
    if (len > 3) shootDir = { x: dx / len, y: dy / len };
    shooting = mouseDown;
  } else {
    const len = Math.hypot(aimJoyVal.x, aimJoyVal.y);
    if (len > 0.06) {
      let ax = aimJoyVal.x / (len || 1);
      let ay = aimJoyVal.y / (len || 1);
      ax = curve(ax);
      ay = curve(ay);
      shootDir = { x: ax, y: ay };
      shooting = true;
    }
  }

  if (shooting) {
    const n = Math.hypot(shootDir.x, shootDir.y);
    if (n > 0.0001) lastAimDir = { x: shootDir.x, y: shootDir.y };
  }

  if (shooting && !shootBlocked) {
    shootBlocked = true;
    socket.emit('shoot', {
      targetX: player.x + shootDir.x * 120,
      targetY: player.y + shootDir.y * 120
    });
    setTimeout(() => { shootBlocked = false; }, 300);
  }
}




if (isMobileDevice) {
  canvas.addEventListener('pointerdown', (e) => {
    if (buildMode) return;
    if (e.clientX <= window.innerWidth * 0.5) return;
    if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;

    const p = playersHealth[myId];
    const dx = (cameraX + e.clientX / renderScale) - p.x;
    const dy = (cameraY + e.clientY / renderScale) - p.y;
    const d  = Math.hypot(dx, dy);
    const dir = d > 4 ? { x: dx / d, y: dy / d } : lastAimDir;

    if (!shootBlocked) {
      shootBlocked = true;
      socket.emit('shoot', {
        targetX: p.x + dir.x * 120,
        targetY: p.y + dir.y * 120
      });
      setTimeout(() => { shootBlocked = false; }, 300);
    }
  }, { passive: true });
}


// ---- Aide : écran -> monde -> tuile ----
function screenToWorldTile(clientX, clientY) {
  const wx = cameraX + clientX / renderScale;
  const wy = cameraY + clientY / renderScale;
  return {
    tx: Math.floor(wx / TILE_SIZE),
    ty: Math.floor(wy / TILE_SIZE)
  };
}

// Survol pour l'aperçu de placement
canvas.addEventListener('mousemove', (e) => {
  if (!buildMode) return;
  const { tx, ty } = screenToWorldTile(e.clientX, e.clientY);
  buildHover.tx = tx; buildHover.ty = ty;
}, { passive: true });

canvas.addEventListener('pointermove', (e) => {
  if (!buildMode) return;
  const { tx, ty } = screenToWorldTile(e.clientX, e.clientY);
  buildHover.tx = tx; buildHover.ty = ty;
}, { passive: true });


// Survol mobile pour l’aperçu de placement
canvas.addEventListener('touchmove', (e) => {
  if (!buildMode) return;
  const t = e.changedTouches && e.changedTouches[0];
  if (!t) return;
  const { tx, ty } = screenToWorldTile(t.clientX, t.clientY);
  buildHover.tx = tx; 
  buildHover.ty = ty;
}, { passive: true });



// ---- Placement sur mobile (touch) ----
canvas.addEventListener('touchstart', (e) => {
  if (!buildMode) return;
  const t = e.changedTouches && e.changedTouches[0];
  if (!t) return;
  e.preventDefault();
  e.stopPropagation();
  tryPlaceStructureAtCursor(t.clientX, t.clientY);
  mouseDown = false;
}, { passive: false });



canvas.addEventListener('pointerdown', (e) => {
  if (!buildMode) return;
  e.preventDefault();
  e.stopPropagation();
  tryPlaceStructureAtCursor(e.clientX, e.clientY);
  mouseDown = false;
});



function drawBuildPreview() {
  if (!buildMode || buildHover.tx < 0 || buildHover.ty < 0) return;

  const tx = buildHover.tx, ty = buildHover.ty;
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) return;

  // rouge si bloqué, vert si OK
  const blocked = isWallAt(tx, ty) || (structures?.[ty]?.[tx]);
  const x = tx * TILE_SIZE - cameraX;
  const y = ty * TILE_SIZE - cameraY;

  ctx.save();
  ctx.globalAlpha = 0.5;
  // couleur selon le type
  if (buildMode === 'T') ctx.fillStyle = '#d33';
  else if (buildMode === 't') ctx.fillStyle = '#3aa6ff';
  else if (buildMode === 'B') ctx.fillStyle = '#7b4b2a';
  else if (buildMode === 'D') ctx.fillStyle = '#a57b4a';
  else ctx.fillStyle = '#888';

  ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

  // liseré rouge si bloqué / vert sinon
  ctx.globalAlpha = 1;
  ctx.lineWidth = 2;
  ctx.strokeStyle = blocked ? '#ff3b3b' : '#34e05a';
  ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
  ctx.restore();
}




function tryPlaceStructureAtCursor(clientX, clientY) {
  const { tx, ty } = screenToWorldTile(clientX, clientY);

  // bornes / murs
  if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) {
    console.debug('[build] Hors carte', { tx, ty });
    return;
  }
  if (isWallAt(tx, ty)) {
    console.debug('[build] Case murale', { tx, ty });
    return;
  }

  // bloc déjà occupé par une structure ?
  if (structures?.[ty]?.[tx]) {
    console.debug('[build] Case déjà occupée par une structure', { tx, ty, existing: structures[ty][tx] });
    return;
  }

  // payload (on envoie aussi centre monde pour aider le serveur s'il en a besoin)
  const payload = {
    type: buildMode,
    tx,
    ty,
    x: tx * TILE_SIZE + TILE_SIZE / 2,
    y: ty * TILE_SIZE + TILE_SIZE / 2
  };

  console.debug('[emit] buyStructure', payload);

  // ↘️ on attend l’ACK du serveur pour savoir si on sort du mode placement
  try {
    socket.emit('buyStructure', payload, (ack) => {
      console.debug('[ack] buyStructure', ack);
      if (ack && ack.ok) {
        // succès confirmé → sortir du mode placement
        buildMode = null;
        buildHover = { tx: -1, ty: -1 };
      } else {
        // refus: on reste en mode placement pour réessayer ailleurs
        const reason = ack && ack.reason ? ack.reason : 'unknown';
        console.warn('[build] Refusé par le serveur:', reason);
      }
    });
  } catch (err) {
    console.error('[emit] buyStructure error:', err);
  }
}




	function updateCamera() {
	  if (!myId || !playersHealth[myId] || !playersHealth[myId].alive) return;
	  let player = playersHealth[myId];

	  const viewW = canvas.width / renderScale;
	  const viewH = canvas.height / renderScale;

	  cameraX = player.x - viewW / 2;
	  cameraY = player.y - viewH / 2;

	  cameraX = Math.max(0, Math.min(cameraX, MAP_COLS * TILE_SIZE - viewW));
	  cameraY = Math.max(0, Math.min(cameraY, MAP_ROWS * TILE_SIZE - viewH));
	}



function drawHUD() {
  const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
  const aliveCount = Object.values(playersHealth).filter(p => p.alive).length;

  hudAlive.textContent = `${tr.alive} : ${aliveCount}`;
  hudMoney.textContent = `Money : $${myMoney}`;

  // ⚠️ Libellé imposé : "Zombies left" (pas de fallback "Active zombies")
  const labelZ = 'Zombies left';

  // Compteur : priorise zombiesRemaining, sinon on compte les zombies actifs
  const countZ = (Number.isFinite(zombiesRemaining) && zombiesRemaining >= 0)
    ? zombiesRemaining
    : (zombies && typeof zombies === 'object' ? Object.keys(zombies).length : 0);

  hudZombies.textContent = `${labelZ}: ${countZ}`;

  hudKills.textContent = `${tr.kills}: ${myKills}`;
  hudRound.textContent = `${tr.round}: ${currentRound}`;

  const me = playersHealth[myId];
  hudHP.textContent = me && me.maxHealth
    ? `${tr.health}: ${Math.round(me.health)} / ${me.maxHealth}`
    : `${tr.health}: ${Math.round(me ? me.health : 0)}`;
}


    function showDeathScreen(kills = myKills, round = currentRound) {
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      deathStats.innerHTML = `${tr.zombiesKilled}: <b>${kills}</b><br>${tr.roundReached}: <b>${round}</b>`;
      deathScreen.style.display = 'flex';
    }
    btnReplay.onclick = () => { location.reload(); };

let lastTime = 0;
function gameLoop(timestamp = 0) {
  FRAME_ID++; // <- important : identifie le frame courant pour nos caches

  const deltaTime = Math.max(0.008, Math.min(0.05, (timestamp - lastTime) / 1000));
  lastTime = timestamp;

  update(deltaTime);
  updateCamera();

  // Remet la transform, clear, puis applique le scale (zoom)
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.setTransform(renderScale, 0, 0, renderScale, 0, 0);

  drawMap();
  drawBuildPreview();
  drawStructures();        // utilise refreshZombiesFrame() (1x/frame)
  drawBullets();           // culling
  drawTurretLasers();
  drawZombies();
  drawMoneyFloatingTexts();
  drawPlayers();
  drawAimLine();
  drawLightMask();

  drawHUD();

  if (!isDead) requestAnimationFrame(gameLoop);
}



    socket.on('connect', () => { myId = socket.id; });
    socket.on('lobbyUpdate', (data) => {
      lobbyData = {
        ...data,
        players: {...data.players}
      };
      const tr = TRANSLATIONS[currentLang] || TRANSLATIONS['en'];
      if (data.started) {
        lobbyScreen.style.display = 'none';
        lobbyStarted = true;
        return;
      }
      lobbyScreen.style.display = 'flex';
      updateLobbyTexts();
      lobbyJoin.disabled = lobbyJoined;
      pseudoInput.disabled = lobbyJoined;
      if (lobbyJoined) lobbyJoin.textContent = tr.waiting;
      else lobbyJoin.textContent = tr.join;
    });

    lobbyJoin.onclick = () => {
      if (!pseudoInput.value.trim()) {
        pseudoInput.focus();
        pseudoInput.style.background = "#fdd";
        setTimeout(() => pseudoInput.style.background = "", 600);
        return;
      }
      socket.emit('setPseudoAndReady', pseudoInput.value.trim());
      myPseudo = pseudoInput.value.trim();
      lobbyJoined = true;
      lobbyJoin.disabled = true;
      pseudoInput.disabled = true;
      lobbyJoin.textContent = TRANSLATIONS[currentLang].waiting;
    };

    pseudoInput.onkeydown = (e) => {
      if (e.key === "Enter") lobbyJoin.click();
    };

    socket.on('gameStarted', (data) => {
      map = data.map;
	  createMapBuffer();
      MAP_ROWS = map.length;
      MAP_COLS = map[0].length;
      playersHealth = data.players;
      currentRound = data.round;
      lobbyScreen.style.display = 'none';
      isDead = false; playerHealth = 100; myKills = 0;
      if (isMobileDevice) setTimeout(setupJoysticks, 300);
      setTimeout(()=>{ gameLoop(); }, 400);
	  structures = data.structures || null;
	if (data.structurePrices) {
	  STRUCTURE_PRICES = { ...STRUCTURE_PRICES, ...data.structurePrices };
	}
	updateBuildTilesState(); // rafraîchir les étiquettes + disabled
    });



socket.on('waveStarted', ({ totalZombies }) => {
  resetWaveCounters(totalZombies);
});



// --- MISE À JOUR DES STRUCTURES PAR LE SERVEUR ---
// Reçoit une grille 2D (chaque case = null ou { type, hp } ou juste "type")
socket.on('structuresUpdate', (grid) => {
  structures = grid;

  // seed/rafraîchir structHPGrid si la grille contient des hp
  if (!structHPGrid) structHPGrid = [];
  for (let ty = 0; ty < grid.length; ty++) {
    const row = grid[ty];
    if (!structHPGrid[ty]) structHPGrid[ty] = [];
    for (let tx = 0; tx < row.length; tx++) {
      const cell = row[tx];
      if (cell && typeof cell === 'object' && typeof cell.hp === 'number') {
        structHPGrid[ty][tx] = cell.hp;
      } else if (cell == null) {
        structHPGrid[ty][tx] = 0; // détruit
      }
    }
  }
});


   
   
   socket.on('laserBeam', ({ x0, y0, x1, y1, color }) => {
  // On stocke pour le prochain rendu; l’effet disparaît très vite
  turretLasers.push({
    x0, y0, x1, y1, color,
    t: performance.now()
  });
});

   
   socket.on('laserBeams', (arr) => {
  const t = performance.now();
  // On push dans le même buffer que d’habitude
  for (let i = 0; i < arr.length; i++) {
    const b = arr[i];
    turretLasers.push({ x0: b.x0, y0: b.y0, x1: b.x1, y1: b.y1, color: b.color, t });
  }
});

   
   
	socket.on('zombiesRemaining', (n) => {
	  zombiesRemaining = Number(n) || 0;
	  drawHUD();
	});

    socket.on('killsUpdate', (kills) => { myKills = kills; drawHUD(); });
	
socket.on('zombieDied', () => {
  if (zombiesRemaining > 0) zombiesRemaining--;
  waveKilledThisWave++;
  drawHUD();
});
	



    socket.on('youDied', (data) => {
      isDead = true;
      playerHealth = 0;
      showDeathScreen(data.kills, data.round);
    });

	socket.on('moneyEarned', ({ amount, x, y }) => {
	  // Position sur la map, converti en coordonnées écran pour affichage temporaire
	  moneyFloatingTexts.push({
		amount,
		x,
		y,
		time: Date.now(),
		duration: 1200, // ms
		vy: -0.14 // pixels/ms (vitesse vers le haut)
	  });
	  myMoney += amount;          // <--- ajoute
	  drawHUD();                  // <--- ajoute
	  updateBuildTilesState();    // <--- ajoute
	});


socket.on('upgradeUpdate', ({ myUpgrades: u, myMoney: m }) => {
  if (u) myUpgrades = { ...myUpgrades, ...u };
  if (typeof m === 'number') myMoney = m;
  renderShopUpgrades();
  drawHUD();
  updateBuildTilesState();
});





    socket.on('waveMessage', (msg) => {
      waveMessage.textContent = msg;
      waveMessage.style.opacity = '1';
      setTimeout(() => { waveMessage.style.opacity = '0'; }, 2500);
    });

	socket.on('upgradeBought', ({ upgId, newLevel, newMoney }) => {
	  if (!upgId) return;
	  myUpgrades[upgId] = newLevel;
	  myMoney = newMoney;
	  renderShopUpgrades();
	  drawHUD();
	  updateBuildTilesState();

	  // Trouve le bouton correspondant et applique l'animation
	  setTimeout(() => {
		const btn = document.querySelector(`#shopUpgrades button[data-upgid="${upgId}"]`);
		if (btn) {
		  btn.classList.remove('bought-flash'); // Si jamais déjà présente
		  // Force reflow pour relancer l'anim même si le bouton venait d'être upgradé
		  void btn.offsetWidth;
		  btn.classList.add('bought-flash');
		  setTimeout(() => btn.classList.remove('bought-flash'), 280);
		}
	  }, 60); // petit délai pour que le bouton existe après le render
	});

    setInterval(drawHUD, 150);

	// --- SHOP BTN LOGIC ---
	const shopBtn = document.getElementById('shopBtn');
	const shopModal = document.getElementById('shopModal');
	const shopClose = document.getElementById('shopClose');


// ====== UI Achat Structures (au-dessus du SHOP) ======
const buildBar = document.getElementById('buildBar');
const buildTiles = document.querySelectorAll('#buildTiles .build-tile');
const buildTooltip = document.getElementById('buildTooltip');
let STRUCTURE_PRICES = { T: 1000, t: 250, B: 100, D: 200 };

// Hover → tooltip
buildTiles.forEach(btn => {
  const tip = btn.getAttribute('data-tip') || '';
  btn.addEventListener('mouseenter', () => {
    buildTooltip.textContent = tip;
    buildTooltip.style.display = 'block';
  }, { passive: true });
  btn.addEventListener('mouseleave', () => {
    buildTooltip.style.display = 'none';
  }, { passive: true });
});



// Click → entrer/sortir du mode placement (toggle)
let buildClickCooldown = false;
buildTiles.forEach(btn => {
  btn.addEventListener('click', () => {
    if (buildClickCooldown) return;
    buildClickCooldown = true;
    setTimeout(() => (buildClickCooldown = false), 250);

    const type = btn.getAttribute('data-type');

    // Si on reclique sur le même type → on annule le placement
    if (buildMode === type) {
      buildMode = null;
      buildHover = { tx: -1, ty: -1 };
      try { console.log(`[build] Mode placement annulé pour '${type}'.`); } catch {}
      return;
    }

    // Sinon, on entre en mode placement pour ce type
    buildMode = type;
    try { console.log(`[build] Mode placement pour '${type}'. Clique/tape une case vide.`); } catch {}
  });
});




updateBuildTilesState();

// Ajuster la position quand on bouge le shop (mobile)
function positionBuildBar() {
  // Sur mobile, on se base sur la position recalculée du SHOP (déjà gérée par positionShopUI)
  // Ici, on laisse le buildBar accrochée en haut du shopBtn (style inline déjà ok).
  // Si besoin d’ajustements fins mobile, on les ferait ici sans toucher au reste.
}
window.addEventListener('resize', positionBuildBar);
window.addEventListener('orientationchange', positionBuildBar);


// Normalise les coordonnées reçues : supporte {tx,ty} ou {x,y} en pixels
function normalizeTileCoords(obj) {
  let tx = (typeof obj.tx === 'number') ? obj.tx
        : (typeof obj.x === 'number') ? Math.floor(obj.x / TILE_SIZE)
        : null;
  let ty = (typeof obj.ty === 'number') ? obj.ty
        : (typeof obj.y === 'number') ? Math.floor(obj.y / TILE_SIZE)
        : null;
  return { tx, ty };
}

// Tente d'appliquer sur [ty][tx], puis fallback sur [tx][ty] si nécessaire
function setStructureHP(tx, ty, hp) {
  if (!structures) return false;

  // bornes “normales”
  if (ty >= 0 && ty < MAP_ROWS && tx >= 0 && tx < MAP_COLS && structures?.[ty]) {
    const cell = structures[ty][tx];
    if (cell != null) {
      if (typeof cell === 'object') structures[ty][tx].hp = hp;
      else structures[ty][tx] = { type: cell, hp };
      if (!structHPGrid) structHPGrid = [];
      if (!structHPGrid[ty]) structHPGrid[ty] = [];
      structHPGrid[ty][tx] = hp;
      return true;
    }
  }

  // fallback si inversion tx/ty côté serveur
  if (tx >= 0 && tx < MAP_ROWS && ty >= 0 && ty < MAP_COLS && structures?.[tx]) {
    const cell = structures[tx][ty];
    if (cell != null) {
      if (typeof cell === 'object') structures[tx][ty].hp = hp;
      else structures[tx][ty] = { type: cell, hp };
      if (!structHPGrid) structHPGrid = [];
      if (!structHPGrid[tx]) structHPGrid[tx] = [];
      structHPGrid[tx][ty] = hp;
      return true;
    }
  }

  return false;
}

socket.on('structureHP', (payload) => {
  // --- 1) Coords tuile fiables (accepte {tx,ty} OU {x,y} en pixels) ---
  const tx = (typeof payload.tx === 'number') ? payload.tx
            : (typeof payload.x  === 'number') ? Math.floor(payload.x / TILE_SIZE) : null;
  const ty = (typeof payload.ty === 'number') ? payload.ty
            : (typeof payload.y  === 'number') ? Math.floor(payload.y / TILE_SIZE) : null;
  const hp = Number(payload.hp);

  if (!Number.isFinite(tx) || !Number.isFinite(ty) || !Number.isFinite(hp)) return;

  // --- 2) Miroir HP (grille) : on met à jour la case "normale",
  // et si nécessaire on tente aussi l’inversion [tx][ty] (serveur inversé)
  if (!structHPGrid) structHPGrid = [];
  if (!structHPGrid[ty]) structHPGrid[ty] = [];
  structHPGrid[ty][tx] = hp;

  // Si la case "normale" n'existe pas côté structures mais l’inversée oui,
  // on maintien aussi le miroir inversé pour l’affichage
  if (!(structures?.[ty]?.[tx]) && (structures?.[tx]?.[ty])) {
    if (!structHPGrid[tx]) structHPGrid[tx] = [];
    structHPGrid[tx][ty] = hp;
  }

  // --- 3) Mise à jour de la grille visuelle (si elle existe déjà) ---
  const applyHP = (r, c) => {
    if (!structures || !structures[r]) return false;
    const cell = structures[r][c];
    if (cell == null) return false; // rien à mettre à jour

    if (typeof cell === 'object') {
      structures[r][c].hp = hp;
    } else {
      // Le serveur a peut-être envoyé juste le type (string) :
      // on le convertit en objet pour avoir un HP visible qui descend.
      structures[r][c] = { type: cell, hp };
    }

    // HP <= 0 → suppression visuelle immédiate
    if (hp <= 0) {
      structures[r][c] = null;
      if (structHPGrid?.[r]) structHPGrid[r][c] = 0;
    }
    return true;
  };

  // Essai en [ty][tx], puis fallback en [tx][ty] si besoin
  if (!applyHP(ty, tx)) applyHP(tx, ty);
});


function clearStructureAt(tx, ty) {
  if (!structures) return false;

  // chemin “normal” [ty][tx]
  if (ty >= 0 && ty < MAP_ROWS && tx >= 0 && tx < MAP_COLS && structures?.[ty]) {
    if (structures[ty][tx] !== undefined) {
      structures[ty][tx] = null;
      if (structHPGrid?.[ty]) structHPGrid[ty][tx] = 0;
      return true;
    }
  }
  // fallback inversion [tx][ty]
  if (tx >= 0 && tx < MAP_ROWS && ty >= 0 && ty < MAP_COLS && structures?.[tx]) {
    if (structures[tx][ty] !== undefined) {
      structures[tx][ty] = null;
      if (structHPGrid?.[tx]) structHPGrid[tx][ty] = 0;
      return true;
    }
  }
  return false;
}

socket.on('structureDestroyed', (payload) => {
  const { tx, ty } = normalizeTileCoords(payload);
  if (!Number.isFinite(tx) || !Number.isFinite(ty)) return;

  const ok = clearStructureAt(tx, ty);
  if (!ok) console.warn('[structureDestroyed] cellule introuvable', { payload, tx, ty });
});



// Réception du résultat d’achat d’une structure
socket.on('buildResult', (payload) => {
  const {
    ok,
    reason,
    type,
    tx,
    ty,
    newMoney,
    structurePrices,
    hp: hpFromServer
  } = payload || {};

  console.debug('[on] buildResult', payload);

  // Maj argent et éventuellement la table des prix
  if (typeof newMoney === 'number') {
    myMoney = newMoney;
  }
  if (structurePrices) {
    STRUCTURE_PRICES = { ...STRUCTURE_PRICES, ...structurePrices };
  }

  // Rafraîchir l’UI
  drawHUD();
  updateBuildTilesState();

  if (!ok) {
    let msg = '';
    switch (reason) {
      case 'game_not_running': msg = "Impossible d’acheter : la partie n’est pas en cours."; break;
      case 'player_invalid':   msg = "Action impossible : joueur inactif."; break;
      case 'invalid_type':     msg = "Type d’objet invalide."; break;
      case 'not_enough_money': msg = "Pas assez d’argent."; break;
      case 'tile_blocked':     msg = "Case indisponible (mur, structure, autre joueur ou zombie)."; break;
      default:                 msg = "Achat impossible."; break;
    }
    console.warn('[buildResult] Refusé:', msg, { type, tx, ty });
    // on reste en mode placement pour réessayer ailleurs
    return;
  }

  // ✅ Succès : on pose localement la structure pour l'afficher tout de suite
  console.log(`[buildResult] OK: posé '${type}' en ${tx},${ty}`);

  // S'assure que la grille existe
  if (!structures) {
    structures = Array.from({ length: MAP_ROWS }, () => Array(MAP_COLS).fill(null));
  } else if (!structures[ty]) {
    structures[ty] = [];
  }

  // HP par défaut si non fourni par le serveur
  const defaultHp = (type === 'T') ? 500 : (type === 't' ? 200 : 200);
  const hp = (typeof hpFromServer === 'number') ? hpFromServer : defaultHp;

  // Place localement
  structures[ty][tx] = { type, hp };
  
 // Maintenir aussi la grille HP si on l'utilise
if (structHPGrid) {
  if (!structHPGrid[ty]) structHPGrid[ty] = [];
  structHPGrid[ty][tx] = hp;
}

  // Sort du mode placement
  buildMode = null;
  buildHover = { tx: -1, ty: -1 };
});




	function closeShopIfOutside(evt) {
	  if (shopModal.style.display !== 'block') return;
	  const target = evt.target;
	  // Ne ferme pas si on clique sur le bouton ou dans le panneau
	  if (shopModal.contains(target) || shopBtn.contains(target)) return;
	  shopModal.style.display = 'none';
	}
	document.addEventListener('pointerdown', closeShopIfOutside, { passive: true });



function updateBuildTilesState() {
  document.querySelectorAll('#buildTiles .build-tile').forEach(btn => {
    const type = btn.getAttribute('data-type');
    const price = STRUCTURE_PRICES[type] ?? Infinity;

    // maj de l’étiquette sous la tuile (2e div)
    const priceLabel = btn.querySelector('div:nth-child(2)');
    if (priceLabel) priceLabel.textContent = `$${price}`;

    // état “achetable”
    const afford = myMoney >= price;
    btn.style.opacity = afford ? '1' : '0.55';
    btn.style.cursor  = afford ? 'pointer' : 'not-allowed';
    btn.disabled = !afford;
  });
}




const PRICE_TIERS = [10, 25, 50, 75, 100];
const PRICE_STEP_AFTER_TIER = 50;
function getUpgradePrice(nextLevel) {
  if (nextLevel <= PRICE_TIERS.length) return PRICE_TIERS[nextLevel - 1];
  return PRICE_TIERS[PRICE_TIERS.length - 1] + (nextLevel - PRICE_TIERS.length) * PRICE_STEP_AFTER_TIER;
}

function renderShopUpgrades() {
  const el = document.getElementById('shopUpgrades');
  el.innerHTML = "";
  UPGRADES.forEach(upg => {
    const lvl = myUpgrades[upg.id] || 0;                 // <-- définis d’abord
    const price = getUpgradePrice(lvl + 1);              // <-- prix synchro serveur
    const value = upg.getValue(upg.baseValue, lvl);
    const nextValue = upg.getValue(upg.baseValue, lvl + 1);
    const disabled = myMoney < price;

    el.innerHTML += `
      <div style="display:flex; align-items:center; gap:14px; margin-bottom:19px; background:#222a; border-radius:10px; padding:12px 14px 10px 7px;">
        <div style="flex:1;">
          <div style="font-size:18px;"><b>${upg.label}</b></div>
          <div style="font-size:14px; color:#fffa; margin-bottom:3px;">${upg.desc}</div>
          <div style="font-size:15px; color:#bcffa8;">
            ${upg.statLabel} : <b>${upg.format(value)}</b>
            <span style="color:#8f8; font-size:14px; margin-left:7px;">→ ${upg.format(nextValue)}</span>
          </div>
        </div>
        <div style="background:#282;color:#fff;font-weight:bold;border-radius:7px;font-size:15px;min-width:30px;text-align:center;padding:2px 0 1px 0;margin-right:10px;box-shadow:0 1.5px 6px #0007;border:2px solid #232;">
          <span style="font-size:15px;">${lvl}</span>
        </div>
        <button
          style="font-size:16px;background:${disabled ? '#444' : '#393'};color:#fff;border:none;border-radius:7px;padding:7px 18px;box-shadow:0 2px 8px #0004;cursor:${disabled ? 'not-allowed' : 'pointer'};opacity:${disabled ? '0.5' : '1'};margin-left:8px;transition: background 0.16s;"
          data-upgid="${upg.id}" ${disabled?'disabled':''}>
          +1<br>$${price}
        </button>
      </div>
    `;
  });

  el.querySelectorAll('button[data-upgid]').forEach(btn => {
    const upgId = btn.getAttribute('data-upgid');
    btn.onclick = () => socket.emit('upgradeBuy', { upgId });
  });
}



	shopBtn.onclick = () => {
	  renderShopUpgrades();
	  shopModal.style.display = 'block';
	  // Recalage à l’ouverture (tailles DOM connues)
	  positionShopUI();
	};


	shopClose.onclick = () => {
	  shopModal.style.display = 'none';
	};

	// (optionnel, fermer si on clique dehors la fenêtre)
	shopModal.addEventListener('mousedown', function(e) {
	  if (e.target === shopModal) shopModal.style.display = 'none';
	});

    updateUITexts();
    drawHUD();

    window.addEventListener('keydown', e => {
      if (e.key.toLowerCase() === 'p' && myPseudo === 'Myg') {
        socket.emit('killAllZombies');
      }
      if (e.key.toLowerCase() === 'o' && myPseudo === 'Myg') {
        socket.emit('giveMillion');
      }
    });
	
	// --- REAFFICHER LES JOYSTICKS + MAJ ZOOM SUR MOBILE APRÈS CHANGEMENT D'ORIENTATION ---
	if (isMobileDevice) {
	  window.addEventListener('resize', () => {
		updateRenderScale();
		setTimeout(() => { setupJoysticks(); positionShopUI(); }, 200);
	  });
	  window.addEventListener('orientationchange', () => {
		updateRenderScale();
		setTimeout(() => { setupJoysticks(); positionShopUI(); }, 200);
	  });
	}
(() => {
  const container = document.getElementById('mobile-build');
  if (!container) return;

  const buttons = container.querySelectorAll('.mb-btn');

  function setBuildMode(type) {
    // Toggle si on reclique le même type
    if (buildMode === type) {
      buildMode = null;
      buildHover = { tx: -1, ty: -1 };
      return;
    }

    // Vérif argent (évite de passer en mode si pas assez d'argent)
    const price = (STRUCTURE_PRICES && STRUCTURE_PRICES[type]) ?? Infinity;
    if (myMoney < price) {
      if (navigator.vibrate) try { navigator.vibrate(60); } catch {}
      return;
    }

    buildMode = type;
    // reset survol
    buildHover = { tx: -1, ty: -1 };
  }

  function handleTap(type, e) {
    if (e) { e.preventDefault(); e.stopPropagation(); }
    setBuildMode(type);
  }

  buttons.forEach(btn => {
    const type = btn.getAttribute('data-type');
    // Click / Pointer / Touch : on capte tous les cas
    btn.addEventListener('click',       e => handleTap(type, e));
    btn.addEventListener('pointerdown', e => handleTap(type, e), { passive: false });
    btn.addEventListener('touchstart',  e => handleTap(type, e), { passive: false });
  });
})();
	
  </script>
  
  



</body>
</html>